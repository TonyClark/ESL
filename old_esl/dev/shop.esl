export main;

import 'esl/displays.esl', 'esl/lists.esl';

// *******************************************************************************************
// *                                 Start of Type Definitions                               *
// *******************************************************************************************

type Main = Act { Time(Int) };

data State = 
                                         // A customer is in one of the following states...
  NotInShop(Int)                         // Hanging around outside.
| Browsing(Int)                          // Inside the shop looking at items.
| Queuing(Int,Int)                       // Queuing with an item for purchase.
| SeekingHelp(Int)                       // Looking for assistance.
| GettingHelp(Int,Int)                   // Customer gets help.
| OnFloor(Int)                           // Looking around to help shoppers.
| GoTill(Int)                            // Walking to a till.
| AtTill(Int,Int)                        // Serving at a till.
| Helping(Int,Int)                       // Providing assistance.
| Raid                                   // A Raid is occurring.
| NoRaid;                                // Normal behaviour.

type Customer = Act { 
  export state::State; getId::()->Int;   // Check the state of a customer.
  help::(Assistant)->Void;               // An assistant changes the state of a customer.
  Time(Int);                             // Tick.
  SaleConcluded();                       // A purchase was made.
  SaleTimedOut();                        // Customer queued too long.
  Helped()                               // Help was completed.
};   

type GangLeader = Act {                  // This is really an extension of Customer.
  export ready::Bool;                    // Ready to perform a heist.
  Time(Int);                             // Tick.
  OccupyingAssistant(Customer);          // One of the gang members is getting help.
  Leave(Customer)                        // The assistant is no longer occupied.
};   

type Tills = Act { 
  export getState::()->[TillState];      // A collection of tills.
  Time(Int);                             // Next time unit.
  Attend(Assistant);                     // An assistant wants to operate the till.
  Queue(Customer,Int,Int,Int,Int)        // A customer arrives at the till.
};

type Assistant = Act {
  export advising::Customer;getId::()->Int; state::State;     // An assistant can provide help or sell.
  NoTillFound();                         // No free tills available.
  Attending(Int);                        // Started to serve at a free till.
  ReturnToFloor();                       // Finished with this till and return to floor-walking.
  Time(Int)
};

type Transactions = Act {                                            
  export getQueue::()->[Int]; isEmpty::()->Bool;    // Transaction queue at a till.
  Queue(Customer,Int,Int,Int);                      // Add a customer at a till to the end of the queue.
  Do();                                             // Serve next customer.
  Wait()                                            // Ignore all customers.
};

type Facts = KB[State];

type Solver = Rules {
  fact(State);
  hist([Int],[Int],[Int],[ShopState])
};

// *******************************************************************************************
// *                                   End of Type Definitions                               *
// *******************************************************************************************



// *******************************************************************************************
// *                                  Start of History Processing                            *
// *******************************************************************************************

facts::Facts = kb[Facts]{ NoRaid };    // A database recording the history of execution.

time::Int = 0;                         // A shared variable.

solver::Solver = rules {

  // These rules are defined to process a knowledge-base containing facts about the history
  // of execution. Each fact has a time-stamp and the rules will translate the knowledge-base
  // into a sequence of shop-states. Each shop-state is a semantic value that describes a
  // complete snapshot of the shop. As such a sequence of shop-states can be translated into 
  // a sequence of picture snapshots that can be displayed as a filmstrip.
  // 
  // Many of the rules rely on working out what each of the customers and assistants are
  // currently doing. This is achieved by looking backwards through time from NOW and finding
  // the most recent fact that defines their current state.
  
  fact::(State);                           // Access to the supplied knowledge-base.
  before::(State,[State]);                 // First arg occurs before any of the others in the supplied knowledge-base.
  
  nth[T]::(Int,[T],T);                     // Index into a list.
  nth[T](0,[t|_],t) <- !;
  nth[T](n,[_|ts],t) <-
    n' := n - 1,
    nth[T](n',ts,t);
    
  delete[T]::(T,[T],[T]);                  // Delete a list element.
  delete[T](x,[],[]) <- !;
  delete[T](x,[x | l1],l1) <- !;
  delete[T](x,[y | l1],[y | l2]) <-
    delete[T](x,l1,l2);
    
  append[T]::([T],[T],[T]);                // Append two lists.
  append[T]([],l,l);
  append[T]([h|t],l,[h|t']) <- 
    append[T](t,l,t');
    
  hist::([Int],[Int],[Int],[ShopState]);   // Associates sequences of customer, assistant and till ids 
                                           // with a sequence of shop-states. Processing is performed 
                                           // with respect to a supplied temporal knowledge-base of facts. 
                                           // The modal operator 'next' is used to step through the facts
                                           // in order to produce the filmstrip.
  hist(cIds,aIds,tIds,[s]) <- 
    end, !, state(cIds,aIds,tIds,s);
  hist(cIds,aIds,tIds,[s|ss]) <- 
    state(cIds,aIds,tIds,s), !, 
    next[hist(cIds,aIds,tIds,ss)];
  
  custStates::(Int,[State]);               // Produces a list of possible states for a particular customer.
  custStates(id,[NotInShop(id),Browsing(id),SeekingHelp(id),GettingHelp(id,aId),Queuing(id,tId)]);
  
  assStates::(Int,[State]);                // produces a list of possible states for a particular assistant.
  assStates(id,[OnFloor(id),AtTill(id,tId),Helping(id,cId),GoTill(id)]);
  
  state::([Int],[Int],[Int],Shop(CustomersOutside,AssistantsOnFloor,CustomersBrowsing,[CustomerHelp],[TillState],Int));
  state(cIds,aIds,tIds,Shop(cOut,aFloor,cBrowse,cHelp,tState,raid)) <-
  
    // A shop-state contains the identifiers of customers, assistants and tills and describes
    // where they are in terms of the shop. Each shop state is constructed by interrogating
    // the knowledge-base at the current time to find out the state of each actor. Each of 
    // the following goals contribute to the overall shop state.
    
    isRaid(raid),                          // Is there a current raid?
    getCStates(0,cIds,cOut),               // Get all the customers that are outside the shop. 
    getCStates(1,cIds,cBrowse),            // Get all the customers that are browsing.
    getAStates(0,aIds,aFloor),             // Get all the assistants who are on the floor.
    getCStates(2,cIds,cSeekingHelp),       // Get all the customers seeking help.
    seekHelp(cSeekingHelp,cHelp1),         // Create Waiting(c) records.
    getCStates(3,cIds,cGettingHelp),       // Get all the custmers who are being helped.
    getHelp(cGettingHelp,cHelp2),          // Create CustomerHelped(c,a) records.
    cHelp := cHelp1 + cHelp2,              // Build part of the overal shop state.
    getAStates(1,aIds,atTills),            // Get all the assistants at the tills.
    getCStates(4,cIds,cQueuing),           // Get all the customers who are queueing.
    tState(tIds,atTills,cQueuing,tState);  // Build the ATill(t,as,q) records.
    
  isRaid::(Int);                           // If the most recent fact is NoRaid then 0 else 1.
  isRaid(0) <- before(NoRaid,[Raid]), !;
  isRaid(1);
    
  tState::([Int],[Int],[Int],[TillState]); // Constructs a sequence of till-states for all tills.
  tState([],_,_,[]);
  tState([tId|tIds],aIds,cIds,[ATill(tId,aState,qState) | rest]) <-
    attendantState(tId,aIds,aState),
    qState(tId,cIds,qState), !,
    tState(tIds,aIds,cIds,rest);
    
  qState::(Int,[Int],[Int]);               // Constructs a sequence of customers queueing at a till.
  qState(tId,[],[]) <- !;
  qState(tId,[cId|cIds],[cId|rest]) <-
    isQueueing(cId,tId), !,
    qState(tId,cIds,rest);
  qState(tId,[_|cIds],rest) <- qState(tId,cIds,rest);
  
  isQueueing::(Int,Int);                   // A customer is queueing if the most recent fact says so.
  isQueueing(cId,tId) <- past[fact(Queuing(cId,tId2)),!], tId=tId2;
    
  attendantState::(Int,[Int],AttendantState);
  attendantState(tId,[],NoAttendant);
  attendantState(tId,[aId|aIds],Attendant(aId)) <- isAtTill(aId,tId);
  attendantState(tId,[_|aIds],aState) <- attendantState(tId,aIds,aState);
  
  isAtTill::(Int,Int);                     // An assistant is serving if the most recent fact says so.
  isAtTill(aId,tId) <-  past[fact(AtTill(aId,tId2)), !], tId=tId2;
    
  seekHelp::([Int],[CustomerHelp]);        // Constructs a sequence of waiting records.
  seekHelp([],[]);
  seekHelp([id|ids],[Waiting(id) | rest]) <- seekHelp(ids,rest);
    
  getHelp::([Int],[CustomerHelp]);         // Filters those customers that are getting help.
  getHelp([],[]);
  getHelp([id|ids],[CustomerHelped(id,aId) | rest]) <- past[fact(GettingHelp(id,aId)),!], getHelp(ids,rest);
    
  getCStates::(Int,[Int],[Int]);           // Filters customers who are in the nth state generated by custStates.
  getCStates(_,[],[]) <- !;
  getCStates(n,[id|idsIn],[id|idsOut]) <- custStates(id,ss), nth[State](n,ss,s), delete[State](s,ss,ss'), before(s,ss'), !, getCStates(n,idsIn,idsOut);
  getCStates(n,[id|idsIn],idsOut) <- getCStates(n,idsIn,idsOut);
    
  getAStates::(Int,[Int],[Int]);           // Filters assistants who are in the nth state generated bu assStates.
  getAStates(_,[],[]) <- !;
  getAStates(n,[id|idsIn],[id|idsOut]) <- assStates(id,ss), nth[State](n,ss,s),delete[State](s,ss,ss'), before(s,ss'), !, getAStates(n,idsIn,idsOut);
  getAStates(n,[id|idsIn],idsOut) <- getAStates(n,idsIn,idsOut);
};


// *******************************************************************************************
// *                                    End of History Processing                            *
// *******************************************************************************************


// *******************************************************************************************
// *                                  Start of Display Processing                            *
// *******************************************************************************************

type CustomersOutside = [Int];
type AssistantsOnFloor = [Int];
type CustomersBrowsing = [Int];
data CustomerHelp = CustomerHelped(Int,Int) | Waiting(Int);
data AttendantState = Attendant(Int) | NoAttendant;
data TillState = ATill(Int,AttendantState,[Int]);
type ShopState = Shop(CustomersOutside,AssistantsOnFloor,CustomersBrowsing,[CustomerHelp],[TillState],Int);

shopperIcon::Str = 'https://www.shareicon.net/data/512x512/2015/10/26/662313_man_512x512.png';
assistantIcon::Str = 'https://cdn1.iconfinder.com/data/icons/people-ios/64/peo-shopkeeper-male-512.png';
blackLine::Str = 'stroke:black; fill-opacity:0;';
tillIcon::Str = 'http://icons.iconarchive.com/icons/iconsmind/outline/128/Cash-register-2-icon.png';
criminalIcon::Str = 'https://image.freepik.com/free-icon/criminal-carrying-money-bag-at-his-back_318-56444.jpg';
bossIcon::Str = 'https://cdn0.iconfinder.com/data/icons/social-flat-rounded-rects/512/anonymous-512.png';
iconWidth::Int = 50;
iconHeight::Int = 50;
textWidth::Int = 10;
textHeight::Int = 10;
gap::Int = 4;

type Display = Act { 
  RegisterCustomer(Int,Str,[Str]); 
  ChangeState(Int,Str); 
  Sale(Int); 
  TimeOut(Int) 
};

type CustomerDisplay = C(Int,Str,[Str],Int,Int);

type History = Act {
  export getHistory::()->[ShopState]; setHistory::([ShopState])->Void;
  SeekHelp(Int);
  EnterShop(Int);
  HelpTimeout(Int);
  QueueAtTill(Int,Int);
  AssistantHelps(Int,Int);
  AssistantStopsHelp(Int);
  SaleConcludedAtTill(Int);
  SaleTimeOutAtTill(Int);
  AssistantAtTill(Int,Int);
  AssistantLeavesTill(Int)
};

shopHistory::History = null;

act history(history::[ShopState])::History {

  export getHistory, setHistory;
  
  getHistory()::[ShopState] = history;
  setHistory(h::[ShopState])::Void = {
    history := h;
    wake()
  };
  addSeekingHelp(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,browsing,Waiting(cid):helping,ts,raid)
    };
  addOutsideShop(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(cid:out,onFloor,browsing,helping,ts,raid)
    };
  addBrowsing(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,cid:browsing,helping,ts,raid)
    };
  addAssistantOnFloor(aid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,aid:onFloor,browsing,helping,ts,raid)
    };
  addToTill(cid::Int,tid::Int,s::ShopState)::ShopState =
    let addTill(t::TillState)::TillState = case t { ATill(i::Int,a::AttendantState,cids::[Int]) -> if tid = i then ATill(i,a,cid:cids) else ATill(i,a,cids) }
    in case s {
         Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
           Shop(out,onFloor,browsing,helping,map[TillState,TillState](addTill,ts),raid)
       };
  addAssistantToTill(aid::Int,tid::Int,s::ShopState)::ShopState =
    let addTill(t::TillState)::TillState = case t { ATill(i::Int,a::AttendantState,cids::[Int]) -> if tid = i then ATill(i,Attendant(aid),cids) else ATill(i,a,cids) }
    in case s {
         Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
           Shop(out,onFloor,browsing,helping,map[TillState,TillState](addTill,ts),raid)
       };
  addHelping(aid::Int,cid::Int,s::ShopState)::ShopState =
   case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
         Shop(out,onFloor,browsing,CustomerHelped(cid,aid):helping,ts,raid)
       };
  removeOutsideShop(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(remove[Int](cid,out),onFloor,browsing,helping,ts,raid)
    };
  removeFromFloor(aid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,remove[Int](aid,onFloor),browsing,helping,ts,raid)
    };
  removeWaitingOrHelped(cid::Int,s::ShopState)::ShopState =
    let notBrowsing(c::CustomerHelp)::Bool = case c { Waiting(i::Int) -> i <> cid; CustomerHelped(i::Int,j::Int) -> i <> cid }
    in case s {
         Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
           Shop(out,onFloor,browsing,filter[CustomerHelp](notBrowsing,helping),ts,raid)
       };
  removeWaiting(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,browsing,remove[CustomerHelp](Waiting(cid),helping),ts,raid)
    };
  removeFromTill(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,browsing,helping,map[TillState,TillState](removeTillCustomer(cid),ts),raid)
    };
  removeAssistantFromTill(aid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,browsing,helping,map[TillState,TillState](removeTillAttendant(aid),ts),raid)
    };
  removeBrowsing(cid::Int,s::ShopState)::ShopState =
    case s {
      Shop(out::[Int],onFloor::[Int],browsing::[Int],helping::[CustomerHelp],ts::[TillState],raid::Int) ->
        Shop(out,onFloor,remove[Int](cid,browsing),helping,ts,raid)
    }
    
  -> sleep();
  SeekHelp(cid::Int) -> history := addSeekingHelp(cid,removeBrowsing(cid,head[ShopState](history))):history;
  SaleConcludedAtTill(cid::Int) -> history := addOutsideShop(cid,removeFromTill(cid,head[ShopState](history))):history;
  SaleTimeOutAtTill(cid::Int) -> history := addOutsideShop(cid,removeFromTill(cid,head[ShopState](history))):history;
  EnterShop(cid::Int) -> history := addBrowsing(cid,removeOutsideShop(cid,head[ShopState](history))):history;
  HelpTimeout(cid::Int) -> history := addOutsideShop(cid,removeWaiting(cid,head[ShopState](history))):history;
  QueueAtTill(cid::Int,tid::Int) -> history := addToTill(cid,tid,removeWaitingOrHelped(cid,head[ShopState](history))):history;
  AssistantHelps(aid::Int,cid::Int) -> history := addHelping(aid,cid,removeFromFloor(aid,removeWaiting(cid,head[ShopState](history)))):history;
  AssistantStopsHelp(aid::Int) -> history := addAssistantOnFloor(aid,head[ShopState](history)):history;
  AssistantAtTill(aid::Int,tid::Int) -> history := addAssistantToTill(aid,tid,removeFromFloor(aid,head[ShopState](history))):history;
  AssistantLeavesTill(aid::Int) -> history := addAssistantOnFloor(aid,removeAssistantFromTill(aid,head[ShopState](history))):history
};

removeTillCustomer(cid::Int)::(TillState)->TillState =
  fun(t::TillState)::TillState
    case t {
      ATill(tid::Int,s::AttendantState,cids::[Int]) ->
        ATill(tid,s,remove[Int](cid,cids))
    };

removeTillAttendant(aid::Int)::(TillState)->TillState =
  fun(t::TillState)::TillState
    case t {
      ATill(tid::Int,Attendant(a::Int),cids::[Int]) when a = aid->
        ATill(tid,NoAttendant,cids);
      ATill(tid::Int,s::AttendantState,cids::[Int]) ->
        ATill(tid,s,cids)
    };

row(ds::[Data([Property],EDBDisplay)])::Row([Property],[Data(Props,EDBDisplay)]) = Row([Prop('style','border: 1px solid black;')],ds);
tdata(d::EDBDisplay)::Data([Property],EDBDisplay) = Data([Prop('style','border: 1px solid black;')],d);
rdata(d::EDBDisplay)::Data([Property],EDBDisplay) = Data([Prop('style','border: 1px solid black;background-color:red;')],d);
bdata(d::EDBDisplay)::Data([Property],EDBDisplay) = Data([Prop('style','border: 1px solid black;background-color:lightblue;')],d);

act displayB::Display {
  customers::[CustomerDisplay] = [][CustomerDisplay];
  asTable()::EDBDisplay =
    letrec
      rows(cs::[CustomerDisplay])::[Row([Property],[Data([Property],EDBDisplay)])] =
        case cs {
          [][CustomerDisplay] -> [][Row([Property],[Data([Property],EDBDisplay)])];
            C(c::Int,s::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] -> 
              [row([bdata(fold[EDBDisplay]HTML('Customer-' + c))] + 
                   (states(s,ss)) + 
                   [tdata(fold[EDBDisplay]HTML('Sales = ' + sales)),
                    tdata(fold[EDBDisplay]HTML('Walkouts = ' + walkouts))])
              ] + rows(rest)
        };
      
      states(current::Str,allStates::[Str])::[Data([Property],EDBDisplay)] =
        case allStates {
          state::Str;
          ss::[Str];
          [][Str] -> [][Data([Property],EDBDisplay)];
          state:ss when state = current -> [rdata(fold[EDBDisplay]HTML(state+''))] + states(current,ss);
          state:ss -> [tdata(fold[EDBDisplay]HTML(state+''))] + states(current,ss)
        }
    in fold[EDBDisplay]Table([][Property],[row([tdata(fold[EDBDisplay]Table([][Property],rows(customers)))])]+[row([tdata(fold[EDBDisplay](HTML('time = ' + now)))])]);
  changeState(c::Int,s::Str,cs::[CustomerDisplay])::[CustomerDisplay] =
    case cs {
      [][CustomerDisplay] -> cs;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] when c1 = c-> C(c,s,ss,sales,walkouts):rest;
      (c1::CustomerDisplay):rest::[CustomerDisplay] -> c1 : (changeState(c,s,rest))
    };
  getSales(cs::[CustomerDisplay])::Int =
    case cs {
      [][CustomerDisplay] -> 0;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] -> sales + getSales(rest)
    };
  getWalkouts(cs::[CustomerDisplay])::Int =
    case cs {
      [][CustomerDisplay] -> 0;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] -> walkouts + getWalkouts(rest)
    };
  getEvents(cs::[CustomerDisplay])::Int =
    case cs {
      [][CustomerDisplay] -> 0;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] -> walkouts + sales + getEvents(rest)
    };
  sale(customer::Int,customers::[CustomerDisplay])::[CustomerDisplay] =
    case customers {
      [][CustomerDisplay] -> customers;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] when c1 = customer -> C(c1,s1,ss,sales+1,walkouts):rest;
      (c1::CustomerDisplay):rest::[CustomerDisplay] -> c1 : (sale(customer,rest))
    };
  timeout(customer::Int,customers::[CustomerDisplay])::[CustomerDisplay] =
    case customers {
      [][CustomerDisplay] -> customers;
      C(c1::Int,s1::Str,ss::[Str],sales::Int,walkouts::Int):rest::[CustomerDisplay] when c1 = customer-> C(c1,s1,ss,sales,walkouts+1):rest;
      (c1::CustomerDisplay):rest::[CustomerDisplay] -> c1 : (timeout(customer,rest))
    }
  ChangeState(c::Int,s::Str) -> {
    customers := changeState(c,s,customers);
    let events::Int = getEvents(customers) in
    let sales::Int = getSales(customers);
        walkouts::Int = getWalkouts(customers)
    in {
      if events = 0 then events := 1 else {};
      edb <-Show('customers',fold[EDBDisplay]Table([][Property],[
        Row([][Property],[
          Data([][Property],asTable()),
          Data([][Property],fold[EDBDisplay]Pie([][Property],'Satisfaction',500,300,[
            Slice([][Property],'satisfied',(sales * 100)/events),
            Slice([][Property],'unsatisfied',(walkouts * 100)/events)
          ]))
        ])
      ]))
    }
  };
  Sale(c::Int) -> customers := sale(c,customers);
  TimeOut(c::Int) -> {
    customers := timeout(c,customers)
  };
  RegisterCustomer(c::Int,state::Str,states::[Str]) -> {
    customers := customers + [C(c,state,states,0,0)];
    edb <- Show('customers',asTable())
  } 
};

display::Display = new displayB;

// *******************************************************************************************
// *                                    End of Display Processing                            *
// *******************************************************************************************


// *******************************************************************************************
// *                                  Start of Simulation Definition                         *
// *******************************************************************************************

act assistant(id::Int,tills::Tills)::Assistant {

  // An assistant helps customers either by providing answers to questions on the shop sloor, or
  // by attending tills where customers can purchase items from the shop. Providing help and
  // attending tills is giverned by probabilities.

  export state,getId,advising;
  
  probOfSelling::Int = 50;                      // Chance of assistant moving from floor to a till.
  probOfAttendingCustomer::Int = 50;            // Chance of assistant helping a customer on floor.
  state::State = OnFloor(id);                   // An assistant starts on the floor.
  adviceDuration::Int = 100;                    // How long does help take?
  counter::Int = 0;                             // A general purpose counter.
  advising::Customer = null;                    // Who is this customer advising?
  
  getId()::Int = id;
  
  customerSeeksHelp(cs::[Customer])::Customer =
    // Find a customer who is seeking help. Return null otherwise...
    case cs {
      [][Customer] -> null;
      c::Customer:cc::[Customer] when c.state = SeekingHelp(c.getId()) -> c;
      c::Customer:cc::[Customer] -> customerSeeksHelp(cc)
    };
    
  help(c::Customer)::Void = {
    // Help the supplied customer. We think they need help, but we should check...
    grab(c.state) {
      // We have exclusive access to the state of the customer...
      if c.state = SeekingHelp(c.getId())
      then {
        // Go ahead and help the customer...
        // print[Str]('HELPING ' + c);
        c.help(self);
        state := Helping(id,c.getId());
        shopHistory <- AssistantHelps(id,c.getId());
        grab(facts,time) {
          facts.add(state,time);
          time := time + 1
        };
        advising := c;
        counter := 0;
        wait(delay)
      } else {
        // Whoops someone else got there before us...
        // print[Str]('MISSED OPPORTUNITY TO HELP ' + c)
      }
    }
  };
  
  advisingId()::Int = if advising=null then (0-1) else advising.getId();
  
  goTill()::Void = {
    // We have decided to sell stuff. Try to find a till to attend...
    tills <- Attend(self);
    state := GoTill(id);
    wait(delay)
  }
  
  NoTillFound -> {
    // No till was free. Just go back to the floor...
    state := OnFloor(id)
  };
  
  Attending(id::Int) -> {
    // A till accepted this assistant...
    state := AtTill(self.getId(),id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    shopHistory <- AssistantAtTill(getId(),id);
    wait(delay)
  };
  
  ReturnToFloor -> {
    // Completed at a till and returning to floor...
    state := OnFloor(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    shopHistory <- AssistantLeavesTill(id);
    wait(delay)
  };
  
  Time(n::Int) when (state = OnFloor(id)) and customerSeeksHelp(customers) <> null -> probably(probOfAttendingCustomer) {
   let c::Customer = customerSeeksHelp(customers)
   in if c <> null
      then help(c)
      else goTill()
  } else goTill();
  
  Time(n::Int) when state = OnFloor(id) -> probably(probOfSelling) {
   goTill()
  };
  
  Time(n::Int) when (state = Helping(id,advisingId())) and (counter < adviceDuration) -> {
    counter := counter + 1;
    wait(delay)
  };
  
  Time(n::Int) when (state = Helping(id,advisingId())) and (counter = adviceDuration) -> {
    state := OnFloor(id);
    shopHistory <- AssistantStopsHelp(id);
    advising <- Helped;
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    advising := null;
    wait(delay)
  };
  
  Time(n::Int) -> {}
};

act customer(id::Int,tills::Tills)::Customer {

  // A customer is interested in making purchases from the shop. They may be outside and have 
  // a probability of entering the shop after which they may need help from an assistant or
  // may queue at a till to make a purchase (both governed by probailities). If a customer
  // waits too long to receieve service then they will becomse angry and leave the shop without
  // making a purchase.

  export state, help, getId;

  state::State = NotInShop(id);           // Initially outside the shop.
  getId()::Int = id;                      // Each customer has a unique id.
  probOfEnteringShop::Int = 30;           // How likely are they to enter the shop?
  probOfBuying::Int = 20;                 // How likely to make a purchase?
  probOfSeekingHelp::Int = 30;            // How likely is it that they wil need help?
  salesTime::Int = 50;                    // How long this customer takes to make a purchase.
  waitLimit::Int = 100;                   // How long they are prepared to wait.
  counter::Int = 0;                       // Used to calculate timeouts.
  helpedBy::Assistant = null;             // The assistant who is providing help.
  
  help(a::Assistant)::Void = {
    state := GettingHelp(id,a.getId());
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    helpedBy := a;
    display <- ChangeState(id,'GettingHelp');
    wait(delay)
  }
  
  Time(n::Int) when state = NotInShop(id) -> probably(probOfEnteringShop) {
    display <- ChangeState(id,'Browsing');
    shopHistory <- EnterShop(id);
    state := Browsing(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  Time(n::Int) when state = Browsing(id)  -> probably(probOfSeekingHelp) {
    display <- ChangeState(id,'SeekingHelp');
    state := SeekingHelp(id);
    shopHistory <- SeekHelp(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    counter := 0;
    wait(delay)
  };
  
  Time(n::Int) when (state = SeekingHelp(id)) and (counter < waitLimit) -> {
    counter := counter + 1;
    wait(delay)
  };
  
  Time(n::Int) when (state = SeekingHelp(id)) and (counter = waitLimit) -> {
    display <- TimeOut(id);
    display <- ChangeState(id,'NotInShop');
    shopHistory <- HelpTimeout(id);
    state := NotInShop(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  Time(n::Int) when state = Browsing(id)  -> probably(probOfBuying) {
    let till::Int = random(numOfTills)
    in {
      display <- ChangeState(id,'Queueing');
      shopHistory <- QueueAtTill(id,till);
      state := Queuing(id,till);
      grab(facts,time) {
        facts.add(state,time);
        time := time + 1
      };
      tills <- Queue(self,till,now,salesTime,waitLimit);
      wait(delay)
    }
  };
  
  SaleConcluded -> {
    display <- Sale(id);
    display <- ChangeState(id,'NotInShop');
    shopHistory <- SaleConcludedAtTill(id);
    state := NotInShop(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  SaleTimedOut -> {
    display <- TimeOut(id);
    display <- ChangeState(id,'NotInShop');
    shopHistory <- SaleTimeOutAtTill(id);
    state := NotInShop(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  Helped -> {
    let till::Int = random(numOfTills)
    in {
      display <- ChangeState(id,'Queueing');
      state := Queuing(id,till);
      shopHistory <- QueueAtTill(id,till);
      grab(facts,time) {
        facts.add(state,time);
        time := time + 1
      };
      tills <- Queue(self,till,now,salesTime,waitLimit);
      wait(delay)
    }
  };
  
  Time(n::Int) -> {}
};

act leader(size::Int)::GangLeader {

  // A gang leader keeps track of the activities of the members of the gang. When
  // all the members are occupying the sales assistants, the gang leader can steal
  // an item from the shop.

  export ready;
  
  ready::Bool = false;               // Can we start a raid?
  counter::Int = 0;                  // Used to count the members who are occupying assistants.
  state::State = NotInShop(0);       // Where is the gang leader?
  probOfRaid::Int = 10               // How often will raids occur?
  
  Time(n::Int) when not(ready) and (counter=0)-> probably(probOfRaid) {
    ready := true
  };
  
  Time(n::Int) -> {};
  
  OccupyingAssistant(c::Customer) -> {
    counter := counter + 1;
    if counter = size 
    then {
      // print[Str]('RAID SUCCEEDED ' + now);
      state := NotInShop(0);
      grab(facts,time) {
        facts.add(Raid,time);
        time := time + 1;
        facts.add(NoRaid,time);
        time := time + 1
      };
      ready := false;
      wait(delay)
    } else {} 
  };
  
  Leave(c::Customer) -> {
    counter := counter - 1;
    if counter = 0
    then {
      state := NotInShop(0);
      ready := false;
      wait(delay)
    } else {}
  }
};
      

act gangMember(id::Int,leader::GangLeader)::Customer {

  // A gang member pretends to be a customer, but is really answerable to the
  // gang leader. The only thing a gand member is interested in is to seek help
  // from a sales assistant.
  
  export state, help, getId;

  state::State = NotInShop(id);
  getId()::Int = id;
  waitLimit::Int = 10;
  
  help(a::Assistant)::Void = {
    leader <- OccupyingAssistant(self);
    state := GettingHelp(id,a.getId());
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  }
  
  Time(n::Int) when (state = NotInShop(id)) and leader.ready -> {
    state := SeekingHelp(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  SaleConcluded -> { };
  
  SaleTimedOut -> { };
  
  Helped -> {
    leader <- Leave(self);
    state := NotInShop(id);
    grab(facts,time) {
      facts.add(state,time);
      time := time + 1
    };
    wait(delay)
  };
  
  Time(n::Int) -> {}
};

act noTransactions::Transactions {

  export isEmpty, getQueue;
  
  getQueue()::[Int] = [][Int];
  isEmpty()::Bool = true
  
  Queue(c::Customer,tStart::Int,tDelay::Int,tLim::Int) -> {
    become aTransaction(c,tStart,tDelay,tLim,new noTransactions)
  };
  
  Do -> {};
  
  Wait -> {}
};

act aTransaction(c::Customer,tStart::Int,tDelay::Int,tLim::Int,next::Transactions)::Transactions {

  export isEmpty,getQueue;
  
  getQueue()::[Int] = c.getId():next.getQueue();
  isEmpty()::Bool = false
  
  Wait -> {
    next <- Wait;
    tLim := tLim - 1;
    //print[Str]('WAIT[' + now + ']: ' + c + ' tLim = ' + tLim);;
    wait(delay);
    if tLim = 0
    then {
      c <- SaleTimedOut;
      become transacted(next)
    } else {}
  };
  
  Do -> {
    next <- Wait;
    tDelay := tDelay - 1;
    wait(delay);
    if tDelay = 0
    then {
      c <- SaleConcluded;
      become transacted(next)
    } else {}
  };
  
  Queue(c::Customer,tStart::Int,tDelay::Int,tLim::Int) -> next <- Queue(c,tStart,tDelay,tLim)
};

act transacted(next::Transactions)::Transactions {

  export isEmpty,getQueue;
  
  isEmpty()::Bool = next.isEmpty();
  getQueue()::[Int] = next.getQueue()
  
  Do -> next <- Do;
  Wait -> next <- Wait;
  Queue(c::Customer,tStart::Int,tDelay::Int,tLim::Int) -> next <- Queue(c,tStart,tDelay,tLim)
};
  

act noTills::Tills {
  export getState;
  getState()::[TillState] = [][TillState]
  Time(n::Int) -> {};
  Attend(a::Assistant) -> a <- NoTillFound;
  Queue(c::Customer,n::Int,tStart::Int,tDelay::Int,tLim::Int) -> {}
};

act aTill(id::Int,next::Tills)::Tills {
  export getState;
  
  getState()::[TillState] = ATill(id,if assistant <> null then Attendant(assistant.getId()) else NoAttendant,transactions.getQueue()):next.getState();
  broken::Bool = false;
  assistant::Assistant = null;
  probOfBreaking::Int = 0;
  transactions::Transactions = new noTransactions
  Time(n::Int) when (not(broken)) and (not(assistant = null)) and not(transactions.isEmpty()) -> {
    //edb.saveState('history' + now);
    transactions <- Do
  };
  Time(n::Int) when (not(assistant = null)) and transactions.isEmpty() -> {
    transactions := new noTransactions;
    assistant <- ReturnToFloor;
    assistant := null;
    wait(delay)
  };
  Time(n::Int) -> {
    probably(probOfBreaking) {
      //print[Str]('Break Till' + id);
      broken := true
    };
    transactions <- Wait
  };
  Attend(a::Assistant) ->
    if (assistant = null) and not(transactions.isEmpty())
    then {
      assistant := a;
      a <- Attending(id)
    } else next <- Attend(a);
  Queue(c::Customer,till::Int,tStart::Int,tDelay::Int,tLim::Int) -> {
    if till = id
    then transactions <- Queue(c,tStart,tDelay,tLim)
    else next <- Queue(c,till,tStart,tDelay,tLim)
  }
};
  
historyLabel::Str     = 'd';
numOfCustomers::Int   = 12;
numOfTills::Int       = 5;
numOfAssistants::Int  = 15;
numOfGangMembers::Int = 2;
numOfSteps::Int       = 7000;
delay::Int            = 5;
pictureWidth::Int     = 1000;
pictureHeight::Int    = 1000;

assistants::[Assistant] = [][Assistant];
customers::[Customer]   = [][Customer];
tills::Tills            = null;

toPicture(s::ShopState)::EDBDisplay =
  case s {
    cOut::[Int];
    aFloor::[Int];
    cBrowse::[Int];
    h::[CustomerHelp];
    ts::[TillState];
    raid::Int;
    Shop(cOut,aFloor,cBrowse,h,ts,raid) -> 
      letrec customerIcon(id::Int)::Str =
        if id < numOfCustomers
        then shopperIcon
        else criminalIcon;
        customerOutside(ids::[Int],x::Int)::[PictureElement] = 
               if ids = [][Int] 
               then [][PictureElement] 
               else [Image(x,0,iconWidth,iconHeight,customerIcon(head[Int](ids))),Text(x,(iconHeight+textHeight),head[Int](ids)+'','')]+customerOutside(tail[Int](ids),x+iconWidth);
             walkingAssistants(ids::[Int],x::Int,y::Int)::[PictureElement] = 
               if ids = [][Int] 
               then [][PictureElement] 
               else [Image(x,y,iconWidth,iconHeight,assistantIcon),Text(x,y+(iconHeight+textHeight),head[Int](ids)+'','')]+walkingAssistants(tail[Int](ids),x,y+(iconHeight+textHeight));
             browsingCustomers(ids::[Int],x::Int,y::Int)::[PictureElement] = 
               if ids = [][Int] 
               then [][PictureElement] 
               else [Image(x,y,iconWidth,iconHeight,customerIcon(head[Int](ids))),Text(x,y+(iconHeight+textHeight),head[Int](ids)+'','')]+browsingCustomers(tail[Int](ids),x,y+(iconHeight+textHeight));
             helpedCustomers(cs::[CustomerHelp],x::Int,y::Int)::[PictureElement] =
               if cs = [][CustomerHelp]
               then [][PictureElement]
               else 
                 case head[CustomerHelp](cs) {
                   CustomerHelped(cId::Int,aId::Int) -> [
                     Image(x,y,iconWidth,iconHeight,customerIcon(cId)),Text(x,y+(iconHeight+textHeight),cId+'',''),
                     Image(x+iconWidth,y,iconWidth,iconHeight,assistantIcon),Text(x+iconWidth,y+(iconHeight+textHeight),aId+'','')]+helpedCustomers(tail[CustomerHelp](cs),x,y+(iconHeight+textHeight));
                   Waiting(cId::Int) ->
                     [Image(x,y,iconWidth,iconHeight,customerIcon(cId)),Text(x,y+iconHeight+textHeight,cId+'','')]+helpedCustomers(tail[CustomerHelp](cs),x,y+(iconHeight+textHeight))
                 };
              tillStates(ts::[TillState],x::Int,y::Int)::[PictureElement] =
                if ts = [][TillState]
                then [][PictureElement]
                else case head[TillState](ts) {
                  ATill(n::Int,Attendant(a::Int),cids::[Int]) -> [
                    Text(x,y+textHeight+gap,'Till('+n+')',''),
                    Text(x,y+iconHeight+(textHeight*3)+gap+gap,a+'',''),
                    Image(x,y+textHeight+gap,iconWidth,iconHeight+textHeight+gap+gap,tillIcon)] + queue(cids,x,y+(iconHeight+(textHeight*3)+gap+gap)) + tillStates(tail[TillState](ts),x+iconWidth+gap,y);
                  ATill(n::Int,NoAttendant,cids::[Int]) -> [
                    Text(x,y+textHeight+gap,'Till('+n+')',''),
                    Image(x,y+textHeight + gap,iconWidth,iconHeight+textHeight+gap+gap,tillIcon)] + queue(cids,x,y+(iconHeight+textHeight+textHeight+gap+gap)) + tillStates(tail[TillState](ts),x+iconWidth+gap,y)
                };
              queue(cids::[Int],x::Int,y::Int)::[PictureElement] =
                if cids = [][Int]
                then [][PictureElement]
                else [Image(x,y,iconWidth,iconHeight,customerIcon(head[Int](cids))),Text(x,y+(iconHeight+textHeight),head[Int](cids)+'','')] + queue(tail[Int](cids),x,y+(iconHeight+textHeight))
                    
                    
                    
      in let line::PictureElement = Line(0,iconHeight*2,length[Customer](customers) * (iconWidth*2),iconHeight*2,blackLine)
         in fold[EDBDisplay]Picture(pictureWidth,pictureHeight,customerOutside(cOut,0) + [line] + (if raid = 1 then [Image(length[Customer](customers) * (iconWidth*2),(iconHeight*3)/2,iconWidth,iconHeight,bossIcon)] else [][PictureElement]) +
              [Text(0,(iconHeight*2)+gap+textHeight,'Floor','')] +
              walkingAssistants(aFloor,0,gap+textHeight+(iconHeight*2)) + 
              [Text(iconWidth*2,(iconHeight*2)+gap+textHeight,'Browsing','')] +
              browsingCustomers(cBrowse,iconWidth*2,(gap*2)+textHeight+(iconHeight*2)) + 
              [Text(iconWidth*4,(iconHeight*2)+gap+textHeight,'Helping','')] +
              helpedCustomers(h,iconWidth*4,(gap*2)+textHeight+(iconHeight*2)) +
              tillStates(ts,iconWidth*6,(iconHeight*2)))
  };
  
  
  shopSnapshot()::ShopState =
    let customersOutside::[Int] = [ c.getId() | c::Customer <- customers, ?(c.state = NotInShop(c.getId())) ];
        assistantsOnFloor::[Int] =[ a.getId() | a::Assistant <- assistants, ?(a.state = OnFloor(a.getId())) ];
        customersBrowsing::[Int] = [ c.getId() | c::Customer <- customers, ?(c.state = Browsing(c.getId())) ];
        customersHelped::[CustomerHelp] = [ Waiting(c.getId()) | c::Customer <- customers, ?(c.state = SeekingHelp(c.getId())) ] +
                                          [ CustomerHelped(c.getId(),a.getId()) | c::Customer <- customers, a::Assistant <- assistants, ?(c.state = GettingHelp(c.getId(),a.getId())), ?(a.advising = c) ];
        tillStates::[TillState] = tills.getState()
    in Shop(customersOutside,assistantsOnFloor,customersBrowsing,customersHelped,tillStates,0);

act main::Main {
  -> {
    tills := new noTills;
    shopHistory := new history([][ShopState]);
    for n::Int in 0..(numOfTills-1) do {
      tills := new aTill(n,tills)
    };
    for n::Int in 0..(numOfCustomers-1) do {
      customers :=  new customer(n,tills):customers;
      facts.add(NotInShop(n),time);
      time := time + 1;
      display <- RegisterCustomer(n,'NotInShop',['NotInShop','Queueing','Browsing','SeekingHelp','GettingHelp'])
    };
    for n::Int in 0..(numOfAssistants-1) do {
      assistants := new assistant(n,tills):assistants;
      facts.add(OnFloor(n),time);
      time := time + 1
    };
    let g::GangLeader = new leader(numOfGangMembers)
    in for n::Int in 0..(numOfGangMembers-1) do {
         customers := new gangMember(n+numOfCustomers,g):customers;
         facts.add(NotInShop(n+numOfCustomers),time);
         time := time + 1
       };
       shopHistory.setHistory([shopSnapshot()])
  };
  
  Time(n::Int) when n > numOfSteps -> {
    stopOthers();
    edb.saveHistory('end' + numOfCustomers + historyLabel);
    print[Str]('Shopped ' + time + ' ' + facts);
    let cIds::[Int] = 0..(numOfCustomers+numOfGangMembers);
        aIds::[Int] = 0..(numOfAssistants-1);
        tIds::[Int] = 0..(numOfTills-1)
    in show hist(cIds,aIds,tIds,history) [cIds,aIds,tIds] from solver using facts {
         print[Int](length[ShopState](history));
         if length[ShopState](history) > 500 then history := take[ShopState](history,500) else {};
         edb <- Filmstrip('ShopFromRules',[ toPicture(s) | s::ShopState <- history ])
       } else print[Str]('FAIL');
    stopAll()
  };
  
  Time(n::Int) -> {}
}







