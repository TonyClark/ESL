export main;

import 'esl/lists.esl';

// This file contains an implementation of a history monitor based on temporal logic.
// The language for expressing conditions over histories is:
//
// p,q ::= nothing         always satisfied.
//     | action(A)         always satisfied and performs A.
//     | always(p)         satisfied when the history h is x:y:z:... and when p is satisfied by h, y:..., z:... etc.
//     | rec n. p[n]       satisfied when q=p[q/n] and when q is satisfied.
//     | n                 a name bound in a surrounding scope.
//     | p;q               satisfied when p and q are satisfied.
//     | p+q               satisfied when p or q are satisfied.
//     | N(p)              satisfied when the history is _:h and p is satisfied for h.
//     | is(c)             satisfied when c(x) and the history is x:h.
//
// Note that the conventional approach to achieving a language such as that above is to
// encode it as an operational language in functions with continuations. The encoding below
// provides a novel alternative encoding in terms of actors.

// An actor with behaviour Traced[T] produces a history of elements of type T.
// Monitors will regularly inspect the history...

type Traced[T] = Act { export history::[T]; Time(Int) };

// A monitor is supplied with a traced actor and will regularly inspect its history.
// The type Monitor is paremtetric ith respect to the type T of the history elements.
// The message Check(a,c,s,f) is sent to a monitor to start monitoring the traced
// actor a. The integer c is the index into the history of a that defines the current
// position of the next element to consume. Once the monitor is satisfied with the
// history, it will send the monitor m a Check message. If the monitor is not satisfied
// it invokes f()...

type Monitor[T] = rec M. Act { Check(Traced[T],Int,M,()->Void); Time(Int) };

// A word on FOLD and UNFOLD...
// A recursive type (such as Monitor[T] above) has a form T[rec X.T/X] which
// substitutes rec X.T for X in T. If A = rec X.T then:
//
// (a) unfold[A]e::T[rec X.T/X] when e::A
// (b) fold[A]e::A when e::T[A/X]
//
// Insertion of fold and unfold is required because recursive types have the
// two forms such as A and T[A/X]. Currently these must be inserted manually. It should
// be possible to automatically insert these at some later stage.

// The nothing monitor does nothing...

nothing[T]()::Monitor[T] = 
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) ->
      if s = self
      then {}
      else (unfold[Monitor[T]]s) <- Check(a,c,fold[Monitor[T]]self,f);
    Time(n::Int) -> {}
  };

// Create a constant called idle that does nothing...

idle[T]::Monitor[T] = new (nothing[T])();

// An action is a monitor that performs a command each time is checks the traced actor.
// The command does not return anything of interest. Once the action is performed, it
// passes control onto the monitor s...

action[T](command::()->Void)::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> {
      command();
      (unfold[Monitor[T]]s) <- Check(a,c,idle[T],f)
    };
    Time(n::Int) -> {}
  };

// An always monitor is supplied with an actor p. For always(p) to be satisfied, it must be 
// satsified by the the traced actor's history at positions c, c+1, c+2, c+3, ...
// Note that always(p) = both(p,next(always(p))).

always[T](p::Monitor[T])::Monitor[T] = new (rec[T])(fun(q::Monitor[T])::Monitor[T] new (both[T])(p,new (next[T])(always[T](q))));

rec[T](g::(Monitor[T]) -> Monitor[T])::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> (unfold[Monitor[T]](g(new (rec[T])(g)))) <- Check(a,c,s,f);
    Time(n::Int) -> {}
  };

// A both(p,q) monitor is satisfied when both p and q are satisfied at the same index c.
// Note that both(idle,p) = both(p,idle) = p...

both[T](p::Monitor[T],q::Monitor[T])::Monitor[T] = 
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> 
      if s = idle
      then { (unfold[Monitor[T]]p) <- Check(a,c,q,f) }
      else { (unfold[Monitor[T]]p) <- Check(a,c,new (both[T])(q,s),f) } ;
    Time(n::Int) -> {}
  };

// A alt(p,q) monitor is satisfied at index c when p is satisfied at index c or when q
// is satisfied at index q...

alt[T](p::Monitor[T],q::Monitor[T])::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> 
      (unfold[Monitor[T]]p) <- Check(a,c,s,fun()::Void (unfold[Monitor[T]]q) <- Check(a,c,s,f));
    Time(n::Int) -> {}
};

next[T](p::Monitor[T])::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> (unfold[Monitor[T]]p) <- Check(a,c+1,s,f);
    Time(n::Int) -> {}
  };

is[T](pred::(T)->Bool)::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> 
      become (activeIs[T])(pred,a,c,s,f);
    Time(n::Int) -> {}
};

activeIs[T](pred::(T)->Bool,actor::Traced[T],cc::Int,succ::Monitor[T],fail::()->Void)::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> {};
    Time(n::Int) ->
      if length[T](actor.history) > cc
      then { 
        become (is[T])(pred);
        if pred(nth[T](actor.history,cc))
        then (unfold[Monitor[T]]succ) <- Check(actor,cc,idle[T],fail)
        else fail()
      }
      else {}
  };

debug[T](message::Str)::Monitor[T] =
  fold[Monitor[T]] act {
    Check(a::Traced[T],c::Int,s::Monitor[T],f::()->Void) -> {
      print[Str](message + ': ' + c + ' ' + a.history);
      (unfold[Monitor[T]]s) <- Check(a,c,idle[T],f)
    };
    Time(n::Int) -> {}
  };

//type TrueOrFalse = union{T(Int), F(Int)};
//cnstr T = TrueOrFalse.T;
//cnstr F = TrueOrFalse.F;

isF(0)::Bool = true;
isF(1)::Bool = false;

isAnything(n::Int)::Bool = true;

act a::Traced[Int] {
  export history;
  frequency::Int = 3;
  c::Int = 0;
  history::[Int] = [][Int]
  Time(t::Int) -> {
    c := c + 1;
    if c = frequency
    then {
      c := 0;
      //history := history + [F,F,T,F]
      history := history + [probably(50):Int 0 else 1]
    } else {}
  }
};

type Main = Act { Time(Int) };

act main::Main {

  -> { let p::Monitor[Int] = always[Int](new (alt[Int])(new (both[Int])(new (is[Int])(isF),new (both[Int])(new (next[Int])(new (is[Int])(isF)),new (both[Int])(new (next[Int])(new (is[Int])(isF)),new (action[Int])(fun()::Void print[Str]('OK'))))),new (is[Int])(isAnything)))
       in (unfold[Monitor[Int]]p) <- Check(new a,0,idle[T],fun()::Void {})
     };

  Time(1000) -> stopAll();

  Time(n::Int) -> {}

}







