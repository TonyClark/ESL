export remove,length,flatten,count,hasPrefix,nth,take,drop;

remove[T](v::T,l::[T])::[T] =
  case l {
    h::T;
    t::[T];
    h:t when (h=v) -> remove[T](v,t);
    h:t        -> h:remove[T](v,t);
    []         -> [][T]
  };

length[T](l::[T])::Int =
  case l {
    h::T;
    t::[T];
    x::T;
    b::Bag{T};
    s::Set{T};
    h:t -> 1 + length[T](t);
    [] -> 0
  };

bagLength[T](b::Bag{T})::Int =
  case b {
    h::T;
    t::Bag{T};
    bag{h|t} -> 1 + bagLength[T](t);
    bag{}[T] -> 0
  };

setLength[T](s::Set{T})::Int =
  case s {
    h::T;
    t::Set{T};
    set{h|t} -> 1 + setLength[T](t);
    set{}[T] -> 0
  };
      
flatten[T](lists::[[T]])::[T] =
  case lists {
    h::[T];
    t::[[T]];
    h:t -> h+flatten[T](t);
    [][[T]] -> [][T]
  };
        
count[T](x::T,l::[T])::Int =
  case l {
    h::T;
    t::[T];
    h:t -> if h = x then 1+count[T](x,t) else count[T](x,t);
    []  -> 0
  };
  
hasPrefix[T](list::[T],prefix::[T])::Bool =
  case list,prefix {
    x::T;
    y::T;
    l1::[T];
    l2::[T];
    l1,[][T] -> true;
    x:list,y:prefix when x=y -> hasPrefix[T](list,prefix);
    l1,l2 -> false
  };
  
nth[T](l::[T],n::Int)::T =
  case l {
    h::T;
    t::[T];
    h:t    -> if n = 0 then h else nth[T](t,n-1);
    [][T]  -> throw[T]('cannot take nth element.')
  };
  
take[T](l::[T],n::Int)::[T] = 
  if n = 0
  then [][T]
  else 
    case l {
      h::T;
      t::[T];
      h:t -> h:(take[T](t,n-1));
      [][T] -> throw[[T]]('cannot take element ' + n)
    };
  
drop[T](l::[T],n::Int)::[T] = 
  if n = 0
  then l
  else 
    case l {
      h::T;
      t::[T];
      h:t -> drop[T](t,n-1);
      [] -> throw[[T]]('cannot drop element ' + n)
    }




























