export patternNames,decName,decLoc,bindingLoc,bindingName,JBecome,JNow,JCaseBool,AST,ActExp,ActType,ActorDynamicRef,ActorDynamicRef,Apply,ApplyType,ApplyTypeExp,ApplyTypeFun,Arm,ArrayRef,ArrayType,ArrayUpdate,BArm,BArm,BQual,BQual,BagType,Become,BinExp,Binding,Binding,Block,BoolArm,BoolArm,BoolExp,BoolType,Case,CaseBool,CaseBoolsArm,CaseError,CaseInt,CaseIntsArm,CaseList,CaseStr,CaseStrsArm,CaseTerm,CaseTermArm,Cmp,CnstrBind,CnstrBind,Cons,DRef,DataBind,DataBind,Dec,Dec,Error,FieldType,FloatExp,FloatType,Fold,For,ForallType,FunBind,FunBind,FunExp,FunType,Grab,Head,IArm,IArm,If,IntExp,IntType,JActorType,JApply,JArrayRef,JArrayUpdate,JBArm,JBehaviour,JBinExp,JBlock,JBoolArm,JBooleanType,JCase,JCaseInt,JCaseList,JCaseOf,JCaseOf,JCaseStr,JCaseTerm,JCast,JCastp,JCommand,JCommandExp,JConst,JConstBool,JConstBool,JConstDouble,JConstDouble,JConstExp,JConstInt,JConstInt,JConstStr,JConstStr,JDec,JDec,JDeclaration,JDoubleType,JEnv,JError,JExp,JField,JField,JFieldDef,JFlatten,JFor,JFun,JFunType,JGrab,JHead,JIArm,JIArm,JIfCommand,JIfExp,JIntArm,JIntegerType,JLet,JLetRec,JList,JListType,JMap,JMap,JMapFun,JMod,JModule,JModule,JNew,JNewArray,JNewJava,JNil,JNot,JNull,JNullType,JObject,JProbably,JRef,JReturn,JSArm,JSArm,JSelf,JSend,JStatement,JStrArm,JStringType,JSwitch,JSwitchList,JTArm,JTArm,JTMap,JTail,JTerm,JTermArm,JTermRef,JTermType,JTry,JType,JUnknown,JUpdate,JVar,LArm,LArm,Let,Letrec,List,ListType,Loc,MType,Map,Map,MessageType,MessageType,Module,New,NewArray,NewJava,Not,Now,NullExp,NullType,PApplyType,PBagCons,PBool,PCons,PEmptyBag,PEmptySet,PInt,PNil,PNull,PQual,PQual,PSetCons,PStr,PTerm,PVar,Pattern,Pos,Pos,Probably,Qualifier,RecType,Record,RecordType,Ref,SArm,SArm,Self,Send,SetType,StrExp,StrType,TArm,TArm,TBind,TDec,TEnv,TMap,TVar,TaggedFunType,Tail,Term,TermRef,TermType,Throw,Try,Type,TypeBind,TypeBind,TypeClosure,TypeError,TypeError,TypeFun,Unfold,UnfoldType,UnionRef,UnionType,Update,V,V,Var,VarDynamicRef,VarDynamicRef,VarType,VoidType,isBinding,isFunBind;

import 'esl/lists.esl';

data Loc = Pos(Int,Int);
data TDec = Dec(Loc,Str,Type,Type);

decName(d::TDec)::Str =
  case d {
    Dec(l::Loc,n::Str,t::Type,dt::Type) -> n;
  }

decLoc(d::TDec)::Loc =
  case d {
    Dec(l::Loc,n::Str,t::Type,dt::Type) -> l;
  }

data DRef = 
  VarDynamicRef(Loc,AST)
| ActorDynamicRef(Loc,AST,Str);

data TMap = Map(Str,Type);
type TEnv = [TMap];

data JTMap = JMap(Str,JType);
type JEnv = [JTMap]; 

cnstr JMap = JTMap.JMap;

data MType = MessageType(Loc,[Type]);  
data Error = TypeError(Loc,Str);
 
type Type  = rec T. union { 
  ApplyType(Loc,Str,[T]),
  ApplyTypeFun(Loc,T,[T]),
  ArrayType(Loc,T),
  StrType(Loc),
  IntType(Loc),
  FloatType(Loc),
  BoolType(Loc),
  NullType(Loc),
  ActType(Loc,[TDec],[MType]),
  UnionType(Loc,[T]),
  TermType(Loc,Str,[T]),
  VarType(Loc,Str),
  RecType(Loc,Str,T),
  RecordType(Loc,[T]),
  FieldType(Loc,Str,T),
  ListType(Loc,T),
  BagType(Loc,T),
  SetType(Loc,T),
  TaggedFunType(Loc,[T],Str,T),
  UnionRef(Loc,T,Str),
  UnfoldType(Loc,T),
  FunType(Loc,[T],T),
  VoidType(Loc),
  ForallType(Loc,[Str],T),
  TypeFun(Loc,[Str],T),
  TypeClosure(() -> T)
}

type Pattern = rec P. union {
  PVar(Loc,Str,Type),
  PTerm(Loc,Str,[Type],[P]),
  PApplyType(Loc,P,[Type]),
  PNil(Loc),
  PNull(Loc),
  PInt(Loc,Int),
  PStr(Loc,Str),
  PBool(Loc,Bool),
  PCons(Loc,P,P),
  PBagCons(Loc,P,P),
  PEmptyBag(Loc),
  PSetCons(Loc,P,P),
  PEmptySet(Loc)
}

patternNames(x::Pattern)::[Str] = {
  case x {
    PVar(v0::Loc,v1::Str,v2::Type) -> [v1];
    PTerm(v0::Loc,v1::Str,v2::[Type],v3::[Pattern]) -> [ n | p::Pattern <- v3, n::Str <- patternNames(p) ];
    PApplyType(v0::Loc,v1::Pattern,v2::[Type]) -> patternNames(v1);
    PNil(v0::Loc) -> [];
    PNull(v0::Loc) -> [];
    PInt(v0::Loc,v1::Int) -> [];
    PStr(v0::Loc,v1::Str) -> [];
    PBool(v0::Loc,v1::Bool) -> [];
    PCons(v0::Loc,v1::Pattern,v2::Pattern) -> patternNames(v1) + patternNames(v2);
    PBagCons(v0::Loc,v1::Pattern,v2::Pattern) -> patternNames(v1) + patternNames(v2);
    PEmptyBag(v0::Loc) -> [];
    PSetCons(v0::Loc,v1::Pattern,v2::Pattern) -> patternNames(v1) + patternNames(v2);
    PEmptySet(v0::Loc) -> [];
  }
}



data TBind = 
   TypeBind(Loc,Str,Type,AST)
|  CnstrBind(Loc,Str,Type,AST)
|  FunBind(Loc,Str,[Pattern],Type,Type,AST,AST)
|  Binding(Loc,Str,Type,Type,AST)
|  DataBind(Loc,Str,Type,AST);

isBinding(b::TBind)::Bool =
  case b {
    Binding(l::Loc,n::Str,t::Type,st::Type,e::AST) -> true;
    b::TBind -> false;
  }

isFunBind(b::TBind)::Bool =
  case b {
    FunBind(l::Loc,n::Str,args::[Pattern],t::Type,st::Type,g::AST,e::AST) -> true;
    b::TBind -> false;
  }

bindingName(b::TBind)::Str =
  case b {
    TypeBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v1;
    CnstrBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v1;
    FunBind(v0::Loc,v1::Str,v2::[Pattern],v3::Type,v4::Type,v5::AST,v6::AST) -> v1;
    Binding(v0::Loc,v1::Str,v2::Type,v3::Type,v4::AST) -> v1;
    DataBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v1;
  }

bindingLoc(b::TBind)::Loc =
  case b {
    TypeBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v0;
    CnstrBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v0;
    FunBind(v0::Loc,v1::Str,v2::[Pattern],v3::Type,v4::Type,v5::AST,v6::AST) -> v0;
    Binding(v0::Loc,v1::Str,v2::Type,v3::Type,v4::AST) -> v0;
    DataBind(v0::Loc,v1::Str,v2::Type,v3::AST) -> v0;
  }

data Arm = 
  BArm(Loc,[Pattern],AST,AST)
| LArm(Loc,[Pattern],[[TBind]],AST,AST);

data Qualifier =
   BQual(Loc,Pattern,AST)
|  PQual(Loc,AST);

data CaseTermArm = TArm(Str,AST);

data CaseIntsArm = IArm(Int,AST);

data CaseStrsArm = SArm(Str,AST);

data CaseBoolsArm = BoolArm(Bool,AST);

type AST = rec A. union {
  Module(Str,Str,[Str],[Str],Null,Null,[TBind]), 
  FunExp(Loc,A,[TDec],Type,A),
  IntExp(Loc,Int),
  StrExp(Loc,Str),
  BoolExp(Loc,Bool),
  FloatExp(Loc,Float),
  Term(Loc,Str,[Type],[A]),
  TermRef(A,Int),
  List(Loc,[A]),
  NullExp(Loc),
  CaseError(Loc),
  Case(Loc,[TDec],[A],[Arm]),
  CaseTerm(Loc,A,[CaseTermArm],A),
  CaseList(Loc,A,A,A,A),
  CaseInt(Loc,A,[CaseIntsArm],A),
  CaseStr(Loc,A,[CaseStrsArm],A),
  CaseBool(Loc,A,[CaseBoolsArm],A),
  Var(Loc,Str),
  Block(Loc,[A]),
  Apply(Loc,A,[A]),
  ApplyTypeExp(Loc,A,[Type]),
  ArrayUpdate(Loc,A,A,A),
  ArrayRef(Loc,A,A),
  BinExp(Loc,A,Str,A),
  For(Loc,Pattern,A,A),
  Head(A),
  Tail(A),
  Cons(A,A),
  Throw(Loc,Type,A),
  ActExp(Loc,A,[TDec],[Str],Str,[TBind],A,[Arm]),
  If(Loc,A,A,A),
  Ref(Loc,A,Str),
  Update(Loc,Str,A),
  Self(Loc),
  Send(Loc,A,A),
  Cmp(Loc,A,[Qualifier]),
  New(Loc,A,[A]),
  NewJava(Loc,Str,Type,[A]),
  NewArray(Loc,Type,A),
  Let(Loc,[TBind],A),
  Letrec(Loc,[TBind],A),
  Grab(Loc,[DRef],A),
  Probably(Loc,A,Type,A,A),
  Not(Loc,A),
  Fold(Loc,Type,A),
  Unfold(Loc,Type,A),
  Now(Loc),
  Become(Loc,A),
  Try(Loc,A,[Arm]),
  Record(Loc,[TBind])
}

data TVar = V(Int);

type JType = rec T. union {
  JIntegerType,
  JStringType,
  JBooleanType,
  JDoubleType,
  JListType(T),
  JFunType([T],T),
  JTermType,
  JActorType,
  JObject,
  JNullType(T),
  JUnknown(TVar)
}
data JMod = JModule(Str,[Str],[Str],[JFieldDef]);

data JFieldDef = JField(Str,JType,JExp);

data JDeclaration = JDec(Str,JType);

data JConst =
  JConstInt(Int)
| JConstStr(Str)
| JConstBool(Bool)
| JConstDouble(Float);


type JExp = rec E. union {
  JFun(E,[JDeclaration],JType,JCommand),
  JApply(E,[E]),
  JArrayUpdate(E,E,E),
  JArrayRef(E,E),
  JBecome(E,[E]),
  JBinExp(E,Str,E),
  JCommandExp(JCommand,JType),
  JIfExp(E,E,E),
  JConstExp(JConst),
  JTerm(Str,[E]),
  JTermRef(E,Int),
  JList(JType,[E]),
  JNil(JType),
  JVar(Str,JType),
  JNull,
  JError(E),
  JHead(E),
  JTail(E),
  JCastp(JType,JType,E),
  JCast(JType,E),
  JMapFun(E,E),
  JFlatten(E),
  JNot(E),
  JNow,
  JBehaviour([Str],[JFieldDef],E,E,JCommand),
  JNew(E,[E]),
  JNewArray(E),
  JNewJava(Str,[E]),
  JSend(E,Str,[E]),
  JSelf,
  JRef(E,Str),
  JGrab([E],E),
  JProbably(E,E,E),
  JTry(E,Str,JCommand)
}

data JCase = JCaseOf(JConst,JCommand);
data JTermArm = JTArm(Str,Int,JCommand);
data JIntArm = JIArm(Int,JCommand);
data JStrArm = JSArm(Str,JCommand);
data JBoolArm = JBArm(Bool,JCommand);

type JCommand = rec C. union {
  JBlock([C]),
  JReturn(JExp),
  JSwitch(JExp,[JCase],C),
  JSwitchList(JExp,C,C,C),
  JIfCommand(JExp,C,C),
  JCaseList(JExp,C,C,C),
  JCaseTerm(JExp,[JTermArm],C),
  JCaseInt(JExp,[JIntArm],C),
  JCaseStr(JExp,[JStrArm],C),
  JCaseBool(JExp,[JBoolArm],C),
  JLet([JFieldDef],C),
  JLetRec([JFieldDef],C),
  JUpdate(Str,JExp),
  JStatement(JExp),
  JFor(Str,Str,JExp,C)
}

// Everything below this line is required for the old type checker.
// When the new type checker is available these will be redundant...

cnstr JBlock = unfold[JCommand].JBlock;
cnstr JReturn = unfold[JCommand].JReturn;
cnstr JSwitch = unfold[JCommand].JSwitch;
cnstr JSwitchList = unfold[JCommand].JSwitchList;
cnstr JIfCommand = unfold[JCommand].JIfCommand;
cnstr JCaseList = unfold[JCommand].JCaseList;
cnstr JLet = unfold[JCommand].JLet;
cnstr JLetRec = unfold[JCommand].JLetRec;
cnstr JUpdate = unfold[JCommand].JUpdate;
cnstr JStatement = unfold[JCommand].JStatement;
cnstr JFor = unfold[JCommand].JFor;

cnstr JCaseOf = JCase.JCaseOf;
cnstr JTArm = JTermArm.JTArm;
cnstr JIArm = JIntArm.JIArm;
cnstr JSArm = JStrArm.JSArm;
cnstr JBArm = JBoolArm.JBArm;
cnstr JCaseTerm = unfold[JCommand].JCaseTerm;
cnstr JCaseInt = unfold[JCommand].JCaseInt;
cnstr JCaseStr = unfold[JCommand].JCaseStr;
cnstr JCaseBool = unfold[JCommand].JCaseBool;

cnstr JConstExp = unfold[JExp].JConstExp;
cnstr JArrayUpdate = unfold[JExp].JArrayUpdate;
cnstr JArrayRef = unfold[JExp].JArrayRef;
cnstr JBinExp = unfold[JExp].JBinExp;
cnstr JBecome = unfold[JExp].JBecome;
cnstr JCommandExp = unfold[JExp].JCommandExp;
cnstr JIfExp = unfold[JExp].JIfExp;
cnstr JApply = unfold[JExp].JApply;
cnstr JTerm = unfold[JExp].JTerm;
cnstr JTermRef = unfold[JExp].JTermRef;
cnstr JList = unfold[JExp].JList;
cnstr JNil = unfold[JExp].JNil;
cnstr JNull = unfold[JExp].JNull;
cnstr JNow = unfold[JExp].JNow;
cnstr JError = unfold[JExp].JError;
cnstr JVar = unfold[JExp].JVar;
cnstr JFun = unfold[JExp].JFun;
cnstr JHead = unfold[JExp].JHead;
cnstr JTail = unfold[JExp].JTail;
cnstr JCastp = unfold[JExp].JCastp;
cnstr JCast = unfold[JExp].JCast;
cnstr JMapFun = unfold[JExp].JMapFun;
cnstr JFlatten = unfold[JExp].JFlatten;
cnstr JNot = unfold[JExp].JNot;
cnstr JBehaviour = unfold[JExp].JBehaviour;
cnstr JNew = unfold[JExp].JNew;
cnstr JNewArray = unfold[JExp].JNewArray;
cnstr JNewJava = unfold[JExp].JNewJava;
cnstr JSend = unfold[JExp].JSend;
cnstr JSelf = unfold[JExp].JSelf;
cnstr JRef = unfold[JExp].JRef;
cnstr JGrab = unfold[JExp].JGrab;
cnstr JProbably = unfold[JExp].JProbably;
cnstr JTry = unfold[JExp].JTry;

cnstr JConstInt = JConst.JConstInt;
cnstr JConstStr = JConst.JConstStr;
cnstr JConstBool = JConst.JConstBool;
cnstr JConstDouble = JConst.JConstDouble;

cnstr JIntegerType = unfold[JType].JIntegerType;
cnstr JStringType = unfold[JType].JStringType;
cnstr JBooleanType = unfold[JType].JBooleanType;
cnstr JDoubleType = unfold[JType].JDoubleType;
cnstr JListType = unfold[JType].JListType;
cnstr JFunType = unfold[JType].JFunType;
cnstr JTermType = unfold[JType].JTermType;
cnstr JActorType = unfold[JType].JActorType;
cnstr JObject = unfold[JType].JObject;
cnstr JUnknown = unfold[JType].JUnknown;
cnstr JNullType = unfold[JType].JNullType;

cnstr JModule = JMod.JModule;

cnstr JField = JFieldDef.JField;

cnstr JDec = JDeclaration.JDec;

cnstr Module = unfold[AST].Module;
cnstr FunExp = unfold[AST].FunExp;
cnstr StrExp = unfold[AST].StrExp;
cnstr IntExp = unfold[AST].IntExp;
cnstr BoolExp = unfold[AST].BoolExp;
cnstr FloatExp = unfold[AST].FloatExp;
cnstr Term = unfold[AST].Term;
cnstr TermRef = unfold[AST].TermRef;
cnstr List = unfold[AST].List;
cnstr NullExp = unfold[AST].NullExp;
cnstr CaseError = unfold[AST].CaseError;
cnstr Case = unfold[AST].Case;
cnstr CaseTerm = unfold[AST].CaseTerm;
cnstr CaseList = unfold[AST].CaseList;
cnstr CaseInt = unfold[AST].CaseInt;
cnstr CaseStr = unfold[AST].CaseStr;
cnstr CaseBool = unfold[AST].CaseBool;
cnstr Var = unfold[AST].Var;
cnstr Block = unfold[AST].Block;
cnstr Apply = unfold[AST].Apply;
cnstr ApplyTypeExp = unfold[AST].ApplyTypeExp;
cnstr ArrayUpdate = unfold[AST].ArrayUpdate;
cnstr ArrayRef = unfold[AST].ArrayRef;
cnstr BinExp = unfold[AST].BinExp;
cnstr For = unfold[AST].For;
cnstr Head = unfold[AST].Head;
cnstr Tail = unfold[AST].Tail;
cnstr Cons = unfold[AST].Cons;
cnstr Throw = unfold[AST].Throw;
cnstr ActExp = unfold[AST].ActExp;
cnstr If = unfold[AST].If;
cnstr Ref = unfold[AST].Ref;
cnstr Update = unfold[AST].Update;
cnstr Self = unfold[AST].Self;
cnstr Send = unfold[AST].Send;
cnstr Cmp = unfold[AST].Cmp;
cnstr New = unfold[AST].New;
cnstr NewArray = unfold[AST].NewArray;
cnstr NewJava = unfold[AST].NewJava;
cnstr Let = unfold[AST].Let;
cnstr Letrec = unfold[AST].Letrec;
cnstr Grab = unfold[AST].Grab;
cnstr Probably = unfold[AST].Probably;
cnstr Not = unfold[AST].Not;
cnstr Fold = unfold[AST].Fold;
cnstr Unfold = unfold[AST].Unfold;
cnstr Now = unfold[AST].Now;
cnstr Become = unfold[AST].Become;
cnstr Try = unfold[AST].Try;
cnstr Record = unfold[AST].Record;


cnstr IArm = CaseIntsArm.IArm;
cnstr SArm = CaseStrsArm.SArm;
cnstr BoolArm = CaseBoolsArm.BoolArm;

cnstr Pos = Loc.Pos;
cnstr Dec = TDec.Dec;
cnstr VarDynamicRef = DRef.VarDynamicRef;
cnstr ActorDynamicRef = DRef.ActorDynamicRef;
cnstr Map = TMap.Map; 
cnstr MessageType = MType.MessageType;
cnstr TypeError = Error.TypeError;

cnstr ArrayType = unfold[Type].ArrayType;
cnstr ApplyType = unfold[Type].ApplyType;
cnstr ApplyTypeFun = unfold[Type].ApplyTypeFun;
cnstr StrType = unfold[Type].StrType;
cnstr IntType = unfold[Type].IntType;
cnstr FieldType = unfold[Type].FieldType;
cnstr FloatType = unfold[Type].FloatType;
cnstr BoolType = unfold[Type].BoolType;
cnstr NullType = unfold[Type].NullType;
cnstr VoidType = unfold[Type].VoidType;
cnstr ActType = unfold[Type].ActType;
cnstr UnionType = unfold[Type].UnionType;
cnstr TermType = unfold[Type].TermType;
cnstr VarType = unfold[Type].VarType;
cnstr RecType = unfold[Type].RecType;
cnstr RecordType = unfold[Type].RecordType;
cnstr ListType = unfold[Type].ListType;
cnstr SetType = unfold[Type].SetType;
cnstr BagType = unfold[Type].BagType;
cnstr UnfoldType = unfold[Type].UnfoldType;
cnstr UnionRef = unfold[Type].UnionRef;
cnstr FunType = unfold[Type].FunType;
cnstr TaggedFunType = unfold[Type].TaggedFunType;
cnstr TypeFun = unfold[Type].TypeFun;
cnstr ForallType = unfold[Type].ForallType;
cnstr TypeClosure = unfold[Type].TypeClosure;

cnstr PVar = unfold[Pattern].PVar;
cnstr PTerm = unfold[Pattern].PTerm;
cnstr PApplyType = unfold[Pattern].PApplyType;
cnstr PNil = unfold[Pattern].PNil;
cnstr PNull = unfold[Pattern].PNull;
cnstr PInt = unfold[Pattern].PInt;
cnstr PStr = unfold[Pattern].PStr;
cnstr PBool = unfold[Pattern].PBool;
cnstr PCons = unfold[Pattern].PCons;
cnstr PBagCons = unfold[Pattern].PBagCons;
cnstr PEmptyBag = unfold[Pattern].PEmptyBag;
cnstr PSetCons = unfold[Pattern].PSetCons;
cnstr PEmptySet = unfold[Pattern].PEmptySet;

cnstr TypeBind = TBind.TypeBind;
cnstr CnstrBind = TBind.CnstrBind;
cnstr FunBind = TBind.FunBind;
cnstr Binding = TBind.Binding;
cnstr DataBind = TBind.DataBind;
cnstr BArm = Arm.BArm;
cnstr LArm = Arm.LArm;
cnstr BQual = Qualifier.BQual;
cnstr PQual = Qualifier.PQual;

cnstr TArm = CaseTermArm.TArm;
cnstr V = TVar.V;


