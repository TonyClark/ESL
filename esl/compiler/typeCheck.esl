/********************************************************************************************************************************
 *                                                                                                                              *
 *                                                 The ESL Type Checker                                                         *
 *                                                 ====================                                                         *
 *                                                                                                                              *
 *   This file implements the ESL type checker that recursively descends into an ESL module and checks the declared types.      *
 *   The checker performs minimal type inference on patterns, but otherwise relies on the declarations in the source.           *
 *   Where a type mismatch occurs, the source code maintains character start and end positions of each abstract syntax          *
 *   construct and can raise a TypeError containing the location of the problem. The type checker maintains a cache so that     *
 *   imported modules are not re-checked during a single cycle of the type-checker. Care is taken with recursive types to       *
 *   ensure that top-level type bindings refer to the same value and are therefore = rather than equal and can short-circuit    *
 *   comparison (otherwise unfolding in typeEqual will not terminate). Care is also taken to replace all named type references  *
 *   before the source is checked so that no free type variables occur in the type expressions. Note that types are compared    *
 *   for structural equivalence.                                                                                                *
 *                                                                                                                              *
 *                                                                                                                              *
 ********************************************************************************************************************************/

export main,typeCheckModule,typeCheckEntryPoint;

import 'esl/lists.esl','esl/compiler/types.esl','esl/tables.esl'; 

type Main = Act { }

ppPattern(p::Pattern)::Str =
  case p { 
    PVar(l::Loc,n::Str,t::Type) -> n;
    PTerm(l::Loc,n::Str,[][Type],ps::[Pattern]) -> n + ppPatterns(ps);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> n + ppTypes(ts,[]) + '' + ppPatterns(ps); 
    PApplyType(l::Loc,p::Pattern,ts::[Type]) -> ppPattern(p) + ppTypes(ts,[]);
    PNil(l::Loc) -> '[]';
    PInt(l::Loc,n::Int) -> ''+n;
    PBool(l::Loc,b::Bool) -> ''+b;
    PStr(l::Loc,s::Str) -> s;
    PCons(l::Loc,h::Pattern,t::Pattern) -> ppPattern(h) + ':' + ppPattern(t);
    p::Pattern -> '<unknown: ' + p + '>';
  }

ppPatterns(ps::[Pattern])::[Str] = map[Pattern,Str](ppPattern,ps);

p0::Loc = Pos(0,0);

contentType::Type = UnionType(p0,[TermType(p0,'RawText',[StrType(p0)]),TermType(p0,'ESLSource',[StrType(p0),StrType(p0)]),TermType(p0,'JavaSource',[StrType(p0),StrType(p0),StrType(p0)])]);

editMessage::MType = MessageType(p0,[TermType(p0,'Edit',[contentType])]);

env0::TEnv = [
  Map('edb',ActType(p0,[Dec(p0,'button',FunType(p0,[StrType(p0),StrType(p0),StrType(p0),StrType(p0),FunType(p0,[],VoidType(p0))],VoidType(p0)),null[Type]),Dec(p0,'display',ForallType(p0,['T'],FunType(p0,[StrType(p0),VarType(p0,'T')],VarType(p0,'T'))),null[Type])],[editMessage])),
  Map('kill',ForallType(p0,['T'],FunType(p0,[VarType(p0,'T')],VoidType(p0)))),
  Map('print',ForallType(p0,['T'],FunType(p0,[VarType(p0,'T')],VoidType(p0)))),
  Map('parse',ForallType(p0,['T'],FunType(p0,[StrType(p0)],VarType(p0,'T')))),
  Map('random',FunType(p0,[IntType(p0)],IntType(p0))),
  Map('wait',FunType(p0,[IntType(p0)],VoidType(p0))),
  Map('stopAll',FunType(p0,[],VoidType(p0))),
  Map('builtin',ForallType(p0,['T'],FunType(p0,[StrType(p0),StrType(p0),IntType(p0)],VarType(p0,'T'))))
];

cnstrEnv0::TEnv = [
  Map('Time',UnionType(p0,[TermType(p0,'Time',[IntType(p0)])]))
];

tenv0::TEnv = [
  Map('EditType',contentType),
  Map('Time',UnionType(p0,[TermType(p0,'Time',[IntType(p0)])])),
  Map('Point',UnionType(p0,[TermType(p0,'Point',[IntType(p0),IntType(p0)])]))
];

ppTypeEnv(env::TEnv)::Str =
  let s::Str = '[';
  in {
    for Map(n::Str,t::Type) in env do
      s := s + n + '->' + ppType(t,env) + ',';
    s+']';
  }

ppTypes(ts::[Type],env::TEnv)::[Str] = map[Type,Str](ppType0(env),ts);

getTypeName(t0::Type,env::TEnv)::Str =
  let name::Str = null[Str];
  in { 
    for Map(n::Str,t::Type) in env do {
      if typeEqual(t0,t)
      then name := n;
      else {}
    }
    name;
  }

ppType0(env::TEnv)::(Type) ->Str = fun(t::Type)::Str ppType(t,env);

ppHandlers(handlers::[MType],env::TEnv)::Str =
  case handlers {
    [] -> '';
    MessageType(l::Loc,t::Type:ts::[Type]):hs::[MType] -> ppType(t,env) + '; ' + ppHandlers(hs,env);
  }
  
ppType(t::Type,env::TEnv)::Str = { if getTypeName(t,env) <> null[Str] then getTypeName(t,env); else
  case t {
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 'Act{ ' + ppHandlers(handlers,env) + ' }';
    ApplyType(l::Loc,n::Str,args::[Type]) -> n + map[Type,Str](ppType0(env),args);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ppType(op,env) + map[Type,Str](ppType0(env),args);
    ArrayType(l::Loc,t::Type) -> 'Array[' + ppType(t,env) + ']';
    BoolType(l::Loc) -> 'Bool';
    FloatType(l::Loc) -> 'Float';
    FieldType(l::Loc,n::Str,t::Type) -> n + '::' + ppType(t,env);
    ForallType(l::Loc,ns::[Str],t::Type) -> 'Forall' + ns + '.' + ppType(t,env);
    FunType(l::Loc,d::[Type],r::Type) -> map[Type,Str](ppType0(env),d) + '->' + ppType(r,env);
    TaggedFunType(l::Loc,d::[Type],p::Str,r::Type) -> map[Type,Str](ppType0(env),d) + '->' + ppType(r,env);
    IntType(l::Loc) -> 'Int';
    ListType(l::Loc,t::Type) -> '[' + ppType(t,env) + ']';
    NullType(l::Loc) -> 'Null';
    RecType(l::Loc,n::Str,t::Type) -> 'rec ' + n + '.' + ppType(t,env);
    RecordType(l::Loc,fs::[Type])  -> '{' + ppTypes(fs,env) + '}';
    StrType(l::Loc) -> 'Str';
    TermType(l::Loc,n::Str,ts::[Type]) -> n + map[Type,Str](ppType0(env),ts);
    TypeFun(l::Loc,ns::[Str],t::Type) -> 'Fun' + ns + '.' + ppType(t,env);
    UnfoldType(l::Loc,t::Type) -> 'unfold ' + ppType(t,env);
    UnionType(l::Loc,ts::[Type]) -> 'union ' + map[Type,Str](ppType0(env),ts);
    VarType(l::Loc,n::Str) -> n;
    VoidType(l::Loc) -> 'Void';
    UnionRef(l::Loc,t::Type,n::Str) -> ppType(t,env) + '.' + n;
    TypeClosure(f::()->Type) -> f + '';
    x::Type -> '<unknown ' + x + '>';
  }
}
  
typeEnv(defs::[TBind])::TEnv =
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    b::TBind:ds::[TBind] -> typeEnv(ds);
  }
  
cnstrEnv(defs::[TBind],env::TEnv)::TEnv = 
  // For legacy reasons, handle data type definitions that use union explicitly...
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,RecType(ll::Loc,m::Str,UnionType(lll::Loc,ts::[Type])),e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    TypeBind(l::Loc,n::Str,UnionType(lll::Loc,ts::[Type]),e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> cnstrEnv(ds,env);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    b::TBind:ds::[TBind] -> cnstrEnv(ds,env);
  } 

getConstructors(l::Loc,dataType::Type,t::Type)::TEnv = { //print[Str]('get constructors ' + ppType(t));
  // The type name may refer to a normal union, a recursive union, a type function, or a recursive type function...
  // rec Tree.Fun[X].union [Leaf[X],Pair[Tree[X],Tree[X]]]
  case t {
      RecType(l::Loc,n::Str,t::Type) -> getConstructors(l,dataType,t);
      TypeFun(l::Loc,ns::[Str],t::Type) ->  getConstructors(l,dataType,t);
      UnionType(l::Loc,ts::[Type]) ->
        map[Type,TMap](fun(t::Type)::TMap case t { TermType(l::Loc,n::Str,tts::[Type]) -> Map(n,dataType); },ts);
      t -> throw[TEnv] TypeError(l,'cannot extract constructors from ' + ppType(t,[]));
  }}

zipTypeEnv(ns::[Str],ts::[Type])::TEnv =
  case ns,ts {
    [][Str],[][Type] -> [][TMap];
    n::Str:ns::[Str],t::Type:ts::[Type] -> Map(n,t):zipTypeEnv(ns,ts);
  }
  
lookupType(name::Str,env::TEnv)::Type =
  case env {
    [][TMap] -> null[Type];
    Map(n::Str,t::Type):e::TEnv when n = name -> t;
    m::TMap:e::TEnv -> lookupType(name,e);
  }
  
typeEnvDom(e::TEnv)::[Str] =
  case e {
    [][TMap] -> [][Str];
    Map(n::Str,t::Type):x::TEnv -> n:typeEnvDom(x);
  }
  
removeFromDom(e::TEnv,ns::[Str])::TEnv =
  case e {
    [][TMap] -> [][TMap];
    Map(n::Str,t::Type):e::TEnv when member[Str](n,ns) -> removeFromDom(e,ns);
    Map(n::Str,t::Type):e::TEnv -> Map(n,t):removeFromDom(e,ns);
  }
  
restrictTypeEnv(e::TEnv,ns::[Str])::TEnv =
  case e {
    [][TMap] -> [][TMap];
    Map(n::Str,t::Type):e::TEnv when not(member[Str](n,ns)) -> restrictTypeEnv(e,ns);
    Map(n::Str,t::Type):e::TEnv -> Map(n,t):restrictTypeEnv(e,ns);
  }
  
typeEnvRan(e::TEnv)::[Type] =
  case e {
    [][TMap] -> [][Type];
    Map(n::Str,t::Type):x::TEnv -> t:typeEnvRan(x); 
  }

checkFreeTypes(e::TEnv)::Void =

  // Assumes that the types are all recursive and will throw an error
  // if the types in the environment have a free type variable reference
  // that is not bound by the environment...
  
  let dom::[Str] = typeEnvDom(e);
      ran::[Type] = typeEnvRan(e); in
  let freeNames::[Str] = removeAll[Str](dom,flatten[Str](map[Type,[Str]](typeFV,ran)));
  in if freeNames = [][Str]
     then null[Void];
     else throw[Void]('Unbound Types: ' + freeNames);
     
checkSingletonTypes(e::TEnv)::Void =
  
  // Check that no types have the same name...
 
  case e {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):e::TEnv -> 
      if member[Str](n,typeEnvDom(e))
      then throw[Void]('Duplicate type name: ' + n);
      else checkSingletonTypes(e);
  }
     
checkSingletonConstructors(e::TEnv)::Void = 
  
  // Check that no types have the same name...
 
  case e {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):e::TEnv ->
      if member[Str](n,typeEnvDom(e))
      then throw[Void]('Duplicate constructor name: ' + n);
      else checkSingletonConstructors(e);
  }


valueDefs(defs::[TBind])::[TBind] =
  case defs {
    [][TBind] -> [][TBind];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    DataBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    CnstrBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    b::TBind:ds::[TBind] -> b:valueDefs(ds);
  }

 valueDefsToTEnv(defs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv = { 
   case defs {
     [][TBind] -> [][TMap];
     FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,st::Type,b::AST,g::AST):ds::[TBind] ->
     
       // In principle we should be able to define cases of the same function
       // on different lines. That would require us to know the types of the
       // arguments to the function in order to check it. For now, assume just
       // single defintions with pattern-variables...

       Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
          
     Binding(l::Loc,n::Str,t::Type,st::Type,e::AST):ds::[TBind] -> Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
   }
 }

data TRecord = 
  Typed(AST,TEnv,TEnv,TEnv)
| Undefined;

typeCheckModule(path::Str)::Void =
  typeCheckModuleInternal(path,emptyTable[Str,TRecord],fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
 
typeCheckModuleInternal(path::Str,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) ->Void)::Void =
  if hasEntry[Str,TRecord](path,cache)
  then 
    case lookup[Str,TRecord](path,cache) {
      Typed(m::AST,vEnv::TEnv,cEnv::TEnv,tEnv::TEnv) -> handler(cache,vEnv,cEnv,tEnv);
      Undefined                                      -> throw[Void]('recursive reference to ' + path);
    }
  else 
    let m::AST = parse[AST](path);
    in typeCheckModuleCache(m,addEntry[Str,TRecord](path,Undefined,cache),fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void 
      handler(addEntry[Str,TRecord](path,Typed(m,valueEnv,cnstrEnv,typeEnv),cache),valueEnv,cnstrEnv,typeEnv));

typeCheckEntryPoint(module::AST)::Void =
  typeCheckModuleCache(module,emptyTable[Str,TRecord],fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);

typeCheckModuleCache(module::AST,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) -> Void)::Void =
  typeCheckModule0(module,cache,fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void 
    case module {
        Module(path::Str,name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> { 
          handler(cache,restrictTypeEnv(valueEnv,exports),restrictTypeEnv(cnstrEnv,exports),restrictTypeEnv(typeEnv,exports));
        }
    });

typeCheckModule0(module::AST,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) ->Void)::Void = 

  // Called to process a module (including dealing with imports)
  // and to generate type errors where they occur...

  letrec

    processImports(imports::[Str],cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) -> Void)::Void =

      case imports {
        [][Str] -> handler(cache,[][TMap],[][TMap],[][TMap]);
        path::Str:imports::[Str] ->
          let imports::[Str] = imports; in // Closure bug, pattern vars are not closed in...
          typeCheckModuleInternal(path,cache,fun(cache::Table[Str,TRecord],valueEnv0::TEnv,cnstrEnv0::TEnv,typeEnv0::TEnv)::Void
            processImports(imports,cache,fun(cache::Table[Str,TRecord],valueEnv1::TEnv,cnstrEnv1::TEnv,typeEnv1::TEnv)::Void
              handler(cache,valueEnv1+valueEnv0,cnstrEnv1+cnstrEnv0,typeEnv1+typeEnv0)));
      }
  
    main()::Void =
      case module {
        Module(path::Str,name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> { 
          processImports(imports,cache,fun(cache::Table[Str,TRecord],ivalueEnv::TEnv,icnstrEnv::TEnv,itypeEnv::TEnv)::Void
            let e::TEnv = typeEnv(defs);
            in { 
              checkDupBindings(defs);
              checkFreeTypes(e+itypeEnv+tenv0);
              checkSingletonTypes(e);
              let typeEnv::TEnv = recTypes(e + itypeEnv + tenv0); in 
              let cnstrEnv::TEnv = cnstrEnv(defs,typeEnv) + icnstrEnv + cnstrEnv0; 
              in { 
                //print[Str]('******************************************************');
                //print[Str]('module = ' + name);
                //print[Str]('itypeEnv = ' + ppTypeEnv(itypeEnv));
                //print[Str]('typeEnv = ' + ppTypeEnv(typeEnv));
                //print[Str]('cnstrEnv = ' + ppTypeEnv(cnstrEnv));
                //print[Str]('value defs = ' + valueDefs(defs));
                checkSingletonConstructors(cnstrEnv); 
                // Add in the definitions into the type env and
                // then type check each of the definitions and
                // compare the generated type with the declared
                // type...
                let valueEnv::TEnv = typeCheckValues(valueDefs(defs),NullType(p0),ivalueEnv,typeEnv,cnstrEnv);
                in handler(cache,valueEnv,cnstrEnv,typeEnv);
              }
            });
      }
      }
  in main();



typeCheckValues(valueDefs::[TBind],selfType::Type,ivalueEnv::TEnv,typeEnv::TEnv,cnstrEnv::TEnv)::TEnv =

  // Create a value-to-type environment...

  let valueEnv::TEnv = valueDefsToTEnv(valueDefs,selfType,[][TMap],cnstrEnv,typeEnv) + ivalueEnv + env0;
  in {
    for def::TBind in valueDefs do {
    // Get the type of the defined expression and compare it to the
    // declared type...
    typeCheckDef(def,selfType,valueEnv,valueEnv,cnstrEnv,typeEnv);
   }
   valueEnv;
}

genericize(l::Loc,t::Type)::Type = if length[Str](typeFV(t)) = 0 then t; else ForallType(l,typeFV(t),t);

checkPatterns(l::Loc,ps::[Pattern])::Void =
  let names::[Str] = [ n | p::Pattern <- ps, n::Str <- patternNames(p) ];
  in if removeDups[Str](names) <> names 
     then throw[Void] TypeError(l,'duplicate pattern variables');
     else null[Void];

typeCheckDef(def::TBind,selfType::Type,baseValueEnv::TEnv,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =
  case def {
              FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,st::Type,b::AST,g::AST) -> {
                checkPatterns(l,ps);
                let argTypes::[Type] = map[Pattern,Type](fun(p::Pattern)::Type case p { PVar(l::Loc,n::Str,t::Type) -> substTypeEnv(typeEnv,t); },ps);
                    argNames::[Str] = map[Pattern,Str](fun(p::Pattern)::Str case p { PVar(l::Loc,n::Str,t::Type) -> n; },ps);
                in let bodyType::Type = guardedExpType(l,g,b,selfType,zipTypeEnv(argNames,argTypes) + baseValueEnv,cnstrEnv,typeEnv); in
                   let fType::Type = case t { ForallType(l::Loc,ns::[Str],t::Type) -> genericize(l,FunType(l,argTypes,bodyType)); t::Type -> FunType(l,argTypes,bodyType); }
                       dType::Type = substTypeEnv(typeEnv,t);
                   in if typeEqual(fType,dType)
                      then {} //print[Str](n + '::' + ppType(lookupType(n,valueEnv)) + ' = ' + ppType(bodyType));
                      else throw[Void] TypeError(l,'type of ' + n + '::' + ppType(fType,typeEnv) + ' does not match declaration ' + ppType(dType,typeEnv));
              }
              Binding(l::Loc,n::Str,dt::Type,st::Type,e::AST) -> { //print[Str]('type check def ' + def);
               let valueType::Type = expType(e,selfType,baseValueEnv,cnstrEnv,typeEnv); in
               let valueFV::[Str] = typeFV(valueType);
                   declaredType::Type = lookupType(n,valueEnv); in
               let valueType::Type = if valueFV = [][Str] then valueType; else ForallType(l,valueFV,valueType);
               in {
                if typeEqual(valueType,declaredType)
                then {} //print[Str](n + '::' + ppType(declaredType) + ' = ' + ppType(valueType));
                else throw[Void] TypeError(l,'type of ' + n + ' ' + ppType(valueType,typeEnv) + ' does not match declared type = ' + ppType(declaredType,typeEnv));
               }
              }
           }

typeEqual(t1::Type,t2::Type)::Bool = {
  let b::Bool = typeEqual1(t1,t2);
  in {
    //print[Str]('type equal ' + ppType(t1) + ' ' + ppType(t2) + ' = ' + b);
    b;
  }
}

typeEqual1(t1::Type,t2::Type)::Bool = { //print[Str]('type equal: ' + ppType(t1) + ' = ' + ppType(t2));
  if t1 = t2
  then true;
  else case t1,t2 {
    ArrayType(l1::Loc,t1::Type),ArrayType(l2::Loc,t2::Type) -> typeEqual(t1,t2);
    ActType(l1::Loc,exports1::[TDec],handlers1::[MType]),ActType(l2::Loc,exports2::[TDec],handlers2::[MType]) -> actEqual(exports1,exports1,handlers1,handlers2);
    ApplyTypeFun(l1::Loc,op1::Type,args1::[Type]),ApplyTypeFun(l2::Loc,op2::Type,args2::[Type]) -> typeEqual(op1,op2) and typesEqual(args1,args2);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]),t2::Type -> typeEqual(applyTypeFun(l,forceType(op),args),t2);
    t1::Type,ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> typeEqual(t1,applyTypeFun(l,forceType(op),args));
    BoolType(l1::Loc),BoolType(l2::Loc) -> true;
    FloatType(l1::Loc),FloatType(l2::Loc) -> true;
    IntType(l1::Loc),IntType(l2::Loc) -> true;
    ListType(l1::Loc,t1::Type),ListType(l2::Loc,t2::Type) -> typeEqual(t1,t2);
    BagType(l1::Loc,t1::Type),BagType(l2::Loc,t2::Type) -> typeEqual(t1,t2);
    SetType(l1::Loc,t1::Type),SetType(l2::Loc,t2::Type) -> typeEqual(t1,t2);
    StrType(l1::Loc),StrType(l2::Loc) -> true;
    VoidType(l1::Loc),t::Type -> true;
    t::Type,VoidType(l1::Loc) -> true;
    FieldType(l1::Loc,n1::Str,t1::Type),FieldType(l2::Loc,n2::Str,t2::Type) -> n1=n2 and typeEqual(t1,t2);
    TermType(l1::Loc,n1::Str,args1::[Type]),TermType(l2::Loc,n2::Str,args2::[Type]) -> if n1=n2 then typesEqual(args1,args2); else false;
    TermType(l1::Loc,n1::Str,args1::[Type]),t2::Type -> false;
    t1::Type,TermType(l2::Loc,n2::Str,args2::[Type]) -> false;
    FunType(l1::Loc,d1::[Type],r1::Type),FunType(l2::Loc,d2::[Type],r2::Type) -> typeEqual(r1,r2) and typesEqual(d1,d2);
    TypeClosure(f::()->Type),t2::Type -> typeEqual(f(),t2);
    t1::Type,TypeClosure(f::()->Type) -> typeEqual(t1,f());
    RecordType(l1::Loc,fs1::[Type]),RecordType(l2::Loc,fs2::[Type]) -> recordTypeEqual(fs1,fs2);
    RecType(l1::Loc,n1::Str,t1::Type),RecType(l2::Loc,n2::Str,t2::Type) when n1=n2 -> typeEqual(t1,t2);
    RecType(l1::Loc,n1::Str,t1::Type),t2::Type -> typeEqual(substType(RecType(l1,n1,t1),n1,t1),t2);
    t1::Type,RecType(l2::Loc,n2::Str,t2::Type) -> typeEqual(t1,substType(RecType(l2,n2,t2),n2,t2));
    UnionType(l1::Loc,terms1::[Type]),UnionType(l2::Loc,terms2::[Type]) -> typeSetEqual(terms1,terms2);
    VarType(l1::Loc,n1::Str),VarType(l2::Loc,n2::Str) -> n1 = n2;
    ForallType(l1::Loc,ns1::[Str],t1::Type),ForallType(l2::Loc,ns2::[Str],t2::Type) -> ns1 = ns2 and typeEqual(t1,t2);
    // Allow [] to be polymorphic...
    ListType(l1::Loc,t1::Type),ForallType(l2::Loc,[v1::Str],ListType(l3::Loc,VarType(l4::Loc,v2::Str))) when v1=v2 -> true;
    ForallType(l2::Loc,[v1::Str],ListType(l3::Loc,VarType(l4::Loc,v2::Str))),ListType(l1::Loc,t1::Type) when v1=v2 -> true;
    // Assume that types are free...
    ForallType(l1::Loc,ns1::[Str],t1::Type),t2::Type -> typeEqual(t1,t2);
    t1::Type,ForallType(l1::Loc,ns2::[Str],t2::Type) -> typeEqual(t1,t2);
    t1::Type,t2::Type -> false;
  }}

actEqual(exports1::[TDec],exports2::[TDec],handlers1::[MType],handlers2::[MType])::Bool =
  forall[TDec](fun(d1::TDec)::Bool exists[TDec](fun(d2::TDec)::Bool equalDec(d1,d2),exports2),exports1) and
  forall[TDec](fun(d1::TDec)::Bool exists[TDec](fun(d2::TDec)::Bool equalDec(d1,d2),exports1),exports2) and
  forall[MType](fun(m1::MType)::Bool exists[MType](fun(m2::MType)::Bool equalMessage(m1,m2),handlers2),handlers1) and
  forall[MType](fun(m1::MType)::Bool exists[MType](fun(m2::MType)::Bool equalMessage(m1,m2),handlers1),handlers2);

equalDec(d1::TDec,d2::TDec)::Bool =
  case d1,d2 {
    Dec(l1::Loc,n1::Str,t1::Type,st1::Type),Dec(l2::Loc,n2::Str,t2::Type,st2::Type) -> n1=n2 and typeEqual(t1,t2);
  }

equalMessage(m1::MType,m2::MType)::Bool =
  case m1,m2 {
    MessageType(l1::Loc,ts1::[Type]),MessageType(l2::Loc,ts2::[Type]) -> typesEqual(ts1,ts2);
  }

recordTypeEqual(fields1::[Type],fields2::[Type])::Bool = 
  forall[Type](fun(t1::Type)::Bool exists[Type](fun(t2::Type)::Bool typeEqual(t1,t2),fields2),fields1) and
  forall[Type](fun(t1::Type)::Bool exists[Type](fun(t2::Type)::Bool typeEqual(t1,t2),fields1),fields2);

applyTypeFun(l::Loc,op::Type,args::[Type])::Type =
  case op {
    RecType(lr::Loc,n::Str,t::Type) -> applyTypeFun(l,unfoldType(lr,n,t),args);
    TypeFun(l::Loc,names::[Str],t::Type) ->
      if length[Type](args) = length[Str](names)
      then substTypeEnv(zipTypeEnv(names,args),t);
      else throw[Type] TypeError(l,'type fun expects ' + length[Str](names) + ' args, but supplied with ' + length[Type](args));
    op::Type -> throw[Type] TypeError(l,'expecting a type function: ' + ppType(op,[]));
  }

unfoldType(l::Loc,n::Str,t::Type)::Type = substType(RecType(l,n,t),n,t);

forceType(t::Type)::Type =
  case t {
    TypeClosure(f::()->Type) -> forceType(f());
    t::Type -> t;
  }

typesEqual(ts1::[Type],ts2::[Type])::Bool =
  case ts1,ts2 {
    [][Type],[][Type] -> true;
    [][Type],ts2::[Type] -> false;
    ts1::[Type],[][Type] -> false;
    t1::Type:ts1::[Type],t2::Type:ts2::[Type] -> typeEqual(t1,t2) and typesEqual(ts1,ts2);
  }

typeSetEqual(types1::[Type],types2::[Type])::Bool =
  typeSubset(types1,types2) and typeSubset(types2,types1);

typeSubset(sub::[Type],sup::[Type])::Bool =
  case sub {
    [][Type] -> true;
    t::Type:sub::[Type] -> typeMember(t,sup) and typeSubset(sub,sup);
  }

typeMember(t::Type,types::[Type])::Bool =
  case types {
    [][Type] -> false;
    tt::Type:types::[Type] when typeEqual(t,tt) -> true;
    tt::Type:types::[Type] -> typeMember(t,types);
  }

guardedExpType(l::Loc,g::AST,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bt::Type = expType(g,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(bt)
     then expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
     else throw[Type] TypeError(l,'guarded expression requires a boolean value: ' + ppType(bt,typeEnv));

expType(e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = { //print[Str]('exp type: ' + e);
  case e {
    ActExp(l::Loc,n::AST,args::[TDec],exports::[Str],spec::Str,bindings::[TBind],init::AST,arms::[Arm]) -> actType(l,n,args,exports,bindings,init,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Apply(l::Loc,op::AST,args::[AST]) -> applyType(l,op,args,selfType,valueEnv,cnstrEnv,typeEnv);
    ApplyTypeExp(l::Loc,e::AST,ts::[Type]) -> applyTypeExp(l,e,ts,selfType,valueEnv,cnstrEnv,typeEnv);
    ArrayUpdate(l::Loc,a::AST,i::AST,v::AST) -> arrayUpdateType(l,a,i,v,selfType,valueEnv,cnstrEnv,typeEnv);
    ArrayRef(l::Loc,a::AST,i::AST) -> arrayRefType(l,a,i,selfType,valueEnv,cnstrEnv,typeEnv);
    Become(l::Loc,e::AST) -> becomeType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    BinExp(l::Loc,e1::AST,op::Str,e2::AST) -> binExpType(l,e1,op,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    Block(l::Loc,es::[AST]) -> blockType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    BoolExp(l::Loc,b::Bool) -> BoolType(l);
    Case(l::Loc,decs::[TDec],es::[AST],arms::[Arm]) -> caseType(l,es,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Cmp(l::Loc,e::AST,qs::[Qualifier]) -> cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
    Grab(l::Loc,refs::[DRef],e::AST) -> expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    FloatExp(l::Loc,f::Float) -> FloatType(l);
    Fold(l::Loc,t::Type,e::AST) -> foldType(l,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    For(l::Loc,p::Pattern,list::AST,e::AST) -> forType(l,p,list,e,selfType,valueEnv,cnstrEnv,typeEnv);
    FunExp(l::Loc,n::AST,args::[TDec],t::Type,e::AST) -> funType(l,n,args,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    If(l::Loc,e1::AST,e2::AST,e3::AST) -> ifType(l,e1,e2,e3,selfType,valueEnv,cnstrEnv,typeEnv);
    IntExp(l::Loc,n::Int) -> IntType(l);
    Let(l::Loc,bs::[TBind],e::AST) -> letType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Letrec(l::Loc,bs::[TBind],e::AST) -> letrecType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    List(l::Loc,es::[AST]) -> listType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Now(l::Loc) -> IntType(l);
    Probably(l::Loc,p::AST,t::Type,e1::AST,e2::AST) -> probablyType(l,p,t,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    Record(l::Loc,fields::[TBind]) -> recordType(l,fields,selfType,valueEnv,cnstrEnv,typeEnv);
    Ref(l::Loc,e::AST,n::Str) -> refType(l,e,n,selfType,valueEnv,cnstrEnv,typeEnv);
    Self(l::Loc) -> selfType;
    Send(l::Loc,target::AST,Term(tl::Loc,n::Str,ts::[Type],args::[AST])) -> sendType(l,target,n,args,selfType,valueEnv,cnstrEnv,typeEnv);
    StrExp(l::Loc,s::Str) -> StrType(l);
    Term(l::Loc,n::Str,ts::[Type],es::[AST]) -> termType(l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Throw(l::Loc,t::Type,e::AST) -> throwType(l,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Try(l::Loc,e::AST,arms::[Arm]) -> tryType(l,e,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    New(l::Loc,b::AST,args::[AST]) -> newType(l,b,args,selfType,valueEnv,cnstrEnv,typeEnv);
    NewArray(l::Loc,t::Type,i::AST) -> newArrayType(l,t,i,selfType,valueEnv,cnstrEnv,typeEnv);
    NewJava(l::Loc,path::Str,t::Type,args::[AST]) -> { for a::AST in args do expType(a,selfType,valueEnv,cnstrEnv,typeEnv); substTypeEnv(typeEnv,t); }
    Not(l::Loc,e::AST) -> notType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    NullExp(l::Loc) -> ForallType(l,['T'],VarType(l,'T'));
    Update(l::Loc,n::Str,e::AST) -> updateType(l,n,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Var(l::Loc,n::Str) -> varType(l,n,valueEnv);
  }}

throwType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let valType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in substTypeEnv(typeEnv,t); 

foldType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let eType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(substTypeEnv(typeEnv,t),eType)
     then eType;
     else throw[Type] TypeError(l,'fold type ' + ppType(t,typeEnv) + ' does not equal ' + ppType(eType,typeEnv));

arrayUpdateType(l::Loc,a::AST,i::AST,v::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let aType::Type = expType(a,selfType,valueEnv,cnstrEnv,typeEnv);
      iType::Type = expType(i,selfType,valueEnv,cnstrEnv,typeEnv);
      vType::Type = expType(v,selfType,valueEnv,cnstrEnv,typeEnv);
  in case aType {
    ArrayType(al::Loc,t::Type) ->
      if isIntType(iType)
      then 
        if typeEqual(vType,t)
        then aType;
        else throw[Type] TypeError(l,'value type ' + vType + ' does not match array type ' + t);
      else throw[Type] TypeError(l,'array index should be an integer ' + i);
    t::Type -> throw[Type] TypeError(l,'expecting an array ' + aType);
  }

arrayRefType(l::Loc,a::AST,i::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let aType::Type = expType(a,selfType,valueEnv,cnstrEnv,typeEnv);
      iType::Type = expType(i,selfType,valueEnv,cnstrEnv,typeEnv);
  in case aType {
    ArrayType(al::Loc,t::Type) ->
      if isIntType(iType)
      then t;
      else throw[Type] TypeError(l,'array index should be an integer ' + i);
    t::Type -> throw[Type] TypeError(l,'expecting an array ' + aType);
  }

newArrayType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
   let i::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
   in if isIntType(i)
      then ArrayType(l,substTypeEnv(typeEnv,t));
      else throw[Type] TypeError(l,'expecting an integer type: ' + i);

becomeType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(bType,selfType)
     then bType;
     else throw[Type] TypeError(l,'expecting become to match self type: ' + ppType(bType,typeEnv) + ' ' + ppType(selfType,typeEnv));

probablyType(l::Loc,p::AST,t::Type,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let pt::Type = expType(p,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(pt)
     then
       let t::Type = substTypeEnv(typeEnv,t);
           t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
           t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(t,t1) and typeEqual(t,t2)
          then t;
          else throw[Type] TypeError(l,'expecting probably arm types to agree: ' + ppType(t1,typeEnv) + ' ' + ppType(t,typeEnv) + ' ' + ppType(t2,typeEnv));
     else throw[Type] TypeError(l,'expecting an integer: ' + ppType(pt,typeEnv));

newType(l::Loc,b::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  expType(Apply(l,b,args),selfType,valueEnv,cnstrEnv,typeEnv);

sendType(l::Loc,target::AST,n::Str,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case typeNF(derefType(expType(target,selfType,valueEnv,cnstrEnv,typeEnv)),typeEnv) {
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      letrec
        findHandler(handlers::[MType])::MType = 
          case handlers {
            [][MType] -> throw[MType] TypeError(l,'cannot find message handler named ' + n);
            MessageType(ml::Loc,[TermType(tl::Loc,m::Str,ts::[Type])]):rest::[MType] when m = n -> head[MType](handlers);
            m::MType:handlers::[MType] -> findHandler(handlers);
          }
      in case findHandler(handlers) {
        MessageType(ml::Loc,[TermType(tl::Loc,n::Str,ts1::[Type])]) ->
          let ts2::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
          in if length[Type](ts1) = length[Type](ts2)
             then 
               if typesEqual(ts1,ts2)
               then {
                expType(target,selfType,valueEnv,cnstrEnv,typeEnv);
                VoidType(l);
               }
               else throw[Type] TypeError(l,'message argument types ' + ppTypes(ts2,typeEnv) + ' do not match expected types ' + ppTypes(ts1,typeEnv));
             else throw[Type] TypeError(l,'expecting ' + length[Type](ts1) + ' args, but received ' + length[Type](ts2));
        m::MType -> throw[Type] TypeError(l,'cannot find message handler named ' + n + ' in ' + handlers);
      }
  }

actType(l::Loc,n::AST,args::[TDec],exports::[Str],bindings::[TBind],init::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 

  // Create a behaviour type based on the exported bindings and the message types in the type body.
  // The values of the bindings, the initialiser and the bodies of the message handlers must be 
  // checked and must be supplied with the behaviour type as the self type.
  
  letrec
    findLoc(n::Str,bindings::[TBind])::Loc =
      case bindings {
        [][TBind] -> p0;
        Binding(l::Loc,m::Str,t::Type,st::Type,e::AST):bindings::[TBind] when m=n -> l;
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,st::Type,g::AST,e::AST):bindings::[TBind] when m=n -> l;
        b::TBind:bindings::[TBind] -> findLoc(n,bindings);
      }
    findType(n::Str,bindings::[TBind])::Type =
      case bindings {
        [][TBind] -> null[Type];
        Binding(l::Loc,m::Str,t::Type,st::Type,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,st::Type,g::AST,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        b::TBind:bindings::[TBind] -> findType(n,bindings);
      }
    decs(exports::[Str])::[TDec] =
      case exports {
        [][Str] -> [][TDec];
        m::Str:exports::[Str] -> 
          let t::Type = findType(m,bindings);
              l::Loc = findLoc(m,bindings);
          in if t = null[Type]
             then throw[[TDec]] TypeError(l,'cannot find exported name ' + m);
             else Dec(l,m,t,t):decs(exports);
      }
    getMessageTypes(arms::[Arm])::[MType] =
      case arms {
        [][Arm] -> [][MType];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> getMessageType(ps):getMessageTypes(arms);
      }
    getMessageType(ps::[Pattern])::MType =
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in MessageType(pl,[TermType(pl,termName,ts)]);
      }
    typeCheckArms(arms::[Arm],selfType::Type,valueEnv::TEnv)::Void =
      case arms {
        [][Arm] -> null[Void];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> {
          typeCheckArm(l,ps,g,e,selfType,valueEnv);
          typeCheckArms(arms,selfType,valueEnv);
        }
      }
    typeCheckArm(l::Loc,ps::[Pattern],g::AST,e::AST,selfType::Type,valueEnv::TEnv)::Void = 
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in {
            patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(ts::[Type],valueEnv::TEnv)::Type {
              expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
            });
            null[Void];
          }
      }
  in let localEnv::TEnv = parBind(bindings,selfType,valueEnv,cnstrEnv,typeEnv); in
     let exportedDecs::[TDec] = decs(exports); in
     let messageTypes::[MType] = getMessageTypes(arms); in
     let selfType::Type = ActType(l,exportedDecs,messageTypes) ;
     in {
      typeCheckValues(valueDefs(bindings),selfType,localEnv + valueEnv,typeEnv,cnstrEnv);
      expType(init,selfType,localEnv + valueEnv,cnstrEnv,typeEnv);
      typeCheckArms(arms,selfType,localEnv+valueEnv);
      selfType;
     }

cmpType(l::Loc,e::AST,qs::[Qualifier],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case qs {
    [][Qualifier] -> 
      let t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv); 
      in ListType(l,t);
    BQual(l::Loc,p::Pattern,list::AST):qs::[Qualifier] -> 
      let lType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
      in case lType {
        ListType(ll::Loc,t::Type) ->
          let qs::[Qualifier] = qs; in // Closure bug...
          patternType(l,p,substTypeEnv(typeEnv,t),selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type
            cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv));
        t::Type -> throw[Type] TypeError(l,'qualifier binding expects a list: ' + ppType(t,typeEnv));
      }
    PQual(l::Loc,b::AST):qs::[Qualifier] ->
      let bType::Type = expType(b,selfType,valueEnv,cnstrEnv,typeEnv);
      in if isBoolType(bType)
         then cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Type] TypeError(l,'qualifier expects a boolean type: ' + ppType(bType,typeEnv));
  }

updateType(l::Loc,n::Str,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else 
       let valueType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(valueType,t)
          then valueType;
          else throw[Type] TypeError(l,'type of variable ' + n + '::' + ppType(t,typeEnv) + ' does not agree with value type ' + ppType(valueType,typeEnv));

letType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = parBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in {
    for b::TBind in bs do typeCheckDef(b,selfType,valueEnv,env+valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }
  
letrecType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = recBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in { 
    for b::TBind in bs do typeCheckDef(b,selfType,env + valueEnv,env + valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }
    
checkDupBindings(bs::[TBind])::Void = 
  case bs {
    [] -> null[Void];
    b::TBind:bs::[TBind] -> 
      if member[Str](bindingName(b),[ bindingName(b) | b::TBind <- bs ])
      then throw[Void] TypeError(bindingLoc(b),'duplicate definitions for ' + bindingName(b));
      else checkDupBindings(bs);
  }

parBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv = {
  checkDupBindings(bs);
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);
}

recBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv =
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);

caseType(l::Loc,es::[AST],arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts1::[Type] = expTypes(es,selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'case arm types do not agree: ' + ppTypes(ts1,typeEnv) + ' ' + ppTypes(ts2,typeEnv));

tryType(l::Loc,e::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let ts1::[Type] = expTypes([e],selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'try arm types do not agree: ' + ppTypes(ts1,typeEnv) + ' ' + ppTypes(ts2,typeEnv));
}

armTypes(arms::[Arm],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] = 
  case arms {
    [][Arm] -> [][Type];
    a::Arm:arms::[Arm] -> armType(a,ts,selfType,valueEnv,cnstrEnv,typeEnv):armTypes(arms,ts,selfType,valueEnv,cnstrEnv,typeEnv);
  }

armType(arm::Arm,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case arm {
    BArm(l::Loc,ps::[Pattern],guard::AST,exp::AST) -> {
      checkPatterns(l,ps);
      if length[Pattern](ps) = length[Type](ts)
      then patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(types::[Type],valueEnv::TEnv)::Type guardedExpType(l,guard,exp,selfType,valueEnv,cnstrEnv,typeEnv));
      else throw[Type] TypeError(l,'number of patterns ' + length[Pattern](ps) + ' does not match supplied values: ' + length[Type](ts));
    }
  }
}
  
refType(l::Loc,e::AST,n::Str,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    t::Type = derefType(expType(e,selfType,valueEnv,cnstrEnv,typeEnv));
    findExport(decs::[TDec])::Type = 
      case decs {
        [][TDec] -> null[Type];
        Dec(l::Loc,m::Str,t::Type,st::Type):decs::[TDec] when m=n -> t;
        d::TDec:decs::[TDec] -> findExport(decs);
      }
    findField(fs::[Type])::Type =
      case fs {
        [][Type] -> throw[Type] TypeError(l,'cannot find field name ' + n);
        FieldType(l::Loc,m::Str,t::Type):fs::[Type] when m=n -> t;
        t::Type:fs::[Type] -> findField(fs);
      }
  in case t {
    StrType(sl::Loc) when n = 'explode' -> ListType(sl,IntType(sl));
    StrType(sl::Loc) when n = 'writeDate' -> FloatType(sl);
    ListType(ll::Loc,t::Type) when n = 'implode' -> StrType(ll);
    RecordType(rl::Loc,fs::[Type]) -> findField(fs);
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      let t::Type = findExport(exports);
      in if t = null[Type]
         then throw[Type] TypeError(l,'behaviour type does not export ' + n);
         else substTypeEnv(typeEnv,t);
    t::Type -> throw[Type] TypeError(l,'expecting a record type, but received ' + ppType(t,typeEnv));
  }

derefType(t::Type)::Type =
  case t {
    TypeClosure(f::()->Type) -> derefType(f());
    t::Type -> t;
  }

recordType(l::Loc,fields::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    fieldTypes(fields::[TBind])::[Type] =
      case fields {
        [][TBind] -> [][Type];
        Binding(l::Loc,n::Str,t::Type,st::Type,e::AST):fields::[TBind] ->
          FieldType(l,n,expType(e,selfType,valueEnv,cnstrEnv,typeEnv)):fieldTypes(fields);
        fields::[TBind] -> throw[[Type]] TypeError(l,'unknown field representation: ' + fields);
      }
  in RecordType(l,fieldTypes(fields));
  

forType(l::Loc,p::Pattern,list::AST,body::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let listType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
  in case listType {
    ListType(l::Loc,t::Type) ->
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type 
        expType(body,selfType,valueEnv,cnstrEnv,typeEnv));
    t::Type -> throw[Type] TypeError(l,'for type expects a list: ' + list);
  }

patternTypes(l::Loc,ps::[Pattern],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::([Type],TEnv)->Type)::Type = {
  //print[Str]('patternTypes ' + ppPatterns(ps) + ' ' + ppTypes(ts));
  case ps,ts {
    [][Pattern],[][Type] -> f([][Type],valueEnv);
    p::Pattern:ps::[Pattern],t::Type:ts::[Type] -> 
      let ps::[Pattern] = ps; ts::[Type] = ts; in // Closure Bug!!!!!
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type 
        patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(tailTypes::[Type],valueEnv::TEnv)::Type 
          f(headType:tailTypes,valueEnv)));
    ps::[Pattern],ts::[Type] -> throw[Type] TypeError(l, 'somthing wrong with ' + ps + ' ' + ts);
  }}

getPatternType(l::Loc,p::Pattern,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case p {
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> throw[Type] 'should this happen?';
    PBool(l::Loc,b::Bool) -> BoolType(l);
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PBagCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PSetCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PNil(l::Loc) -> ForallType(l,['T'],ListType(l,VarType(l,'T')));
    PNull(l::Loc) -> ForallType(l,['T'],VarType(l,'T')); 
    PEmptyBag(l::Loc) -> ForallType(l,['T'],BagType(l,VarType(l,'T')));
    PEmptySet(l::Loc) -> ForallType(l,['T'],SetType(l,VarType(l,'T')));
    PInt(l::Loc,n::Int) -> IntType(l);
    PVar(l::Loc,n::Str,pt::Type) -> substTypeEnv(typeEnv,pt);
    PStr(l::Loc,s::Str) -> StrType(l);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> lookupType(n,cnstrEnv);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

patternType(l::Loc,p::Pattern,t::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('patternType ' + ppPattern(p) + ' ' + ppType(t));
  case p {
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> applyTypePatternType(l,p,substTypesEnv(typeEnv,args),t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PBool(l::Loc,b::Bool) -> if isBoolType(t) then f(BoolType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Bool and ' + ppType(t,typeEnv));
    PBagCons(l::Loc,hd::Pattern,tl::Pattern) -> bagConsPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PSetCons(l::Loc,hd::Pattern,tl::Pattern) -> setConsPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> consPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PNil(l::Loc) -> nilType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PNull(l::Loc) -> f(t,valueEnv);
    PEmptyBag(l::Loc) -> emptyBagType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PEmptySet(l::Loc) -> emptySetType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PInt(l::Loc,n::Int) -> if isIntType(t) then f(IntType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Int and ' + ppType(t,typeEnv));
    PVar(l::Loc,n::Str,pt::Type) -> f(t,[Map(n,t)]+valueEnv);
    PStr(l::Loc,s::Str) -> if isStrType(t) then f(StrType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Str and ' + ppType(t,typeEnv));
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> termPatternType(l,n,substTypesEnv(typeEnv,ts),ps,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

applyTypePatternType(l::Loc,p::Pattern,args::[Type],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  patternType(l,p,valueType,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type { 
    case typeNF(pType,typeEnv) {
      TypeFun(fl::Loc,ns::[Str],t::Type) ->
        if length[Type](args) = length[Str](ns)
        then 
          let t::Type = substTypeEnv(zipTypeEnv(ns,args)+typeEnv,t);
          in if typeEqual(t,valueType)
             then f(t,valueEnv);
             else throw[Type] TypeError(l,'value type ' + ppType(valueType,typeEnv) + ' does not match pattern type ' + ppType(t,typeEnv) + ' ' + ppTypeEnv(typeEnv));
        else throw[Type] TypeError(l,'expecting ' + length[Str](ns) + ' args, but suplied with ' + length[Type](args));
      ForallType(fl::Loc,ns::[Str],t::Type) ->
        // Not sure this would ever occur. Should always be a type fun?
        if length[Type](args) = length[Str](ns)
        then 
          let t::Type = substTypeEnv(zipTypeEnv(ns,args)+typeEnv,t);
          in if typeEqual(t,valueType)
             then f(t,valueEnv);
             else throw[Type] TypeError(l,'value type ' + ppType(valueType,typeEnv) + ' does not match pattern type ' + ppType(t,typeEnv) + ' ' + ppTypeEnv(typeEnv));
        else throw[Type] TypeError(l,'expecting ' + length[Str](ns) + ' args, but suplied with ' + length[Type](args));
      t::Type -> f(t,valueEnv);
    }});}

termPatternType(l::Loc,n::Str,genericArgs::[Type],ps::[Pattern],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('termPatternType ' + ppType(valueType) + ' ' + ppTypes(genericArgs));
  let patternType::Type = getTermPatternType(l,n,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(patternType,valueType)
     then
       case typeNF(valueType,typeEnv) {
         UnionType(ul::Loc,cs::[Type]) -> 
           letrec
             getCnstrArgs(cs::[Type])::[Type] =
               case cs {
                 [][Type] -> throw[[Type]] TypeError(l,'cannot find constructor for ' + n);
                 TermType(tl::Loc,m::Str,args::[Type]):cs::[Type] when m=n -> args;
                 t::Type:cs::[Type] -> getCnstrArgs(cs);
               }
           in let argTypes::[Type] = getCnstrArgs(cs);
              in if length[Pattern](ps) = length[Type](argTypes)
                 then patternTypes(l,ps,argTypes,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::[Type],valueEnv::TEnv)::Type f(typeNF(valueType,typeEnv),valueEnv));
                 else throw[Type] TypeError(l,'arity mismatch.');
         t::Type -> throw[Type] TypeError(l,'expecting a data type: ' + valueType);
       }
      else throw[Type] TypeError(l,'term pattern type ' + ppType(patternType,typeEnv) + ' does not match supplied value type ' + ppType(valueType,typeEnv));
    }

typeNF(t::Type,typeEnv::TEnv)::Type =
  case substTypeEnv(typeEnv,t) {
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) ->
      case typeNF(op,typeEnv) {
        TypeFun(l::Loc,ns::[Str],t::Type) ->
          if length[Type](args) = length[Str](ns)
          then typeNF(substTypeEnv(zipTypeEnv(ns,args),t),typeEnv);
          else throw[Type] TypeError(l,'function arity error');
        t::Type -> throw[Type] TypeError(l,'expecting a type function: ' + ppType(typeNF(op,typeEnv),typeEnv));
      }
    TypeClosure(f::()->Type) -> typeNF(f(),typeEnv);
    RecType(l::Loc,n::Str,t::Type) -> typeNF(substType(RecType(l,n,t),n,t),typeEnv);
    t::Type -> t;
  }

getTermPatternType(l::Loc,n::Str,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let t::Type = lookupType(n,cnstrEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unknown constructor ' + n);
     else
       if length[Type](genericArgs) > 0
       then getGenericTermPatternType(l,t,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
       else t;
}

getGenericTermPatternType(l::Loc,t::Type,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case t {
    RecType(rl::Loc,rn::Str,rt::Type) -> getGenericTermPatternType(l,substType(RecType(rl,rn,rt),rn,rt),genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
    TypeFun(al::Loc,ns::[Str],t::Type) ->
      if length[Str](ns) = length[Type](genericArgs)
      then 
        let e::TEnv = zipTypeEnv(ns,genericArgs);
        in substTypeEnv(e+typeEnv,t);
      else throw[Type] TypeError(l,'generic constructor mismatch');
    t::Type -> throw[Type] TypeError(l,'expecting a generic type: ' + ppType(t,typeEnv));
  }

nilType(l::Loc,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],ListType(l,VarType(l,'T'))),valueEnv);
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType,typeEnv));
  }  

emptyBagType(l::Loc,bagType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case bagType {
    BagType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],BagType(l,VarType(l,'T'))),valueEnv);
    bagType::Type -> throw[Type] TypeError(l,'expecting a bag type: ' + ppType(bagType,typeEnv));
  }    

emptySetType(l::Loc,setType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case setType {
    SetType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],SetType(l,VarType(l,'T'))),valueEnv);
    setType::Type -> throw[Type] TypeError(l,'expecting a set type: ' + ppType(setType,typeEnv));
  }   

consPatternType(l::Loc,h::Pattern,t::Pattern,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,listType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv);
        }));
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType,typeEnv));
  }  

bagConsPatternType(l::Loc,h::Pattern,t::Pattern,bagType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case bagType {
    BagType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,bagType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv); 
        }));
    bagType::Type -> throw[Type] TypeError(l,'expecting a bag type: ' + ppType(bagType,typeEnv));
  } 

setConsPatternType(l::Loc,h::Pattern,t::Pattern,setType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case setType {
    SetType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,setType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv); 
        }));
    setType::Type -> throw[Type] TypeError(l,'expecting a set type: ' + ppType(setType,typeEnv));
  }

binExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case op {
    '+' -> plusExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '-' -> subExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '*' -> mulExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '/' -> divExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    ':' -> consExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '=' -> eqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<>' -> neqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'and' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'andalso' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'or' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'orelse' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>' -> compareExpType(l,e1,'>',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>=' -> compareExpType(l,e1,'>=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<' -> compareExpType(l,e1,'<',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<=' -> compareExpType(l,e1,'<=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '..' -> dotDotExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '%' -> percentExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    op::Str -> throw[Type] TypeError(l,'unknown operator: ' + op);
  }

andExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'and expects boolean arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

dotDotExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then ListType(l,IntType(l));
     else throw[Type] TypeError(l,'.. expects integer arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

percentExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then IntType(l);
     else throw[Type] TypeError(l,'% expects integer arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

compareExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isNumType(t1) and isNumType(t2)
     then BoolType(l);
     else throw[Type] TypeError(l,op + ' expects numeric arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

orExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'or expects boolean arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

eqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'= expects types to agree: ' + ppType(t1,typeEnv) + ' <> ' + ppType(t2,typeEnv));

neqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'<> expects types to agree: ' + ppType(t1,typeEnv) + ' <> ' + ppType(t2,typeEnv));

consExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = typeNF(expType(e1,selfType,valueEnv,cnstrEnv,typeEnv),typeEnv);
      t2::Type = typeNF(expType(e2,selfType,valueEnv,cnstrEnv,typeEnv),typeEnv);
  in case t2,t1 {
    ListType(l::Loc,elementType::Type),headType::Type ->
      if typeEqual(headType,elementType)
      then t2;
      else throw[Type] TypeError(l,': expects head type ' + ppType(headType,typeEnv) + ' and element type ' + ppType(elementType,typeEnv) + ' to agree');
  }

divExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for /: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

mulExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    FloatType(l1::Loc),IntType(l2::Loc) -> t1;
    IntType(l1::Loc),FloatType(l2::Loc) -> t2;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for *: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

subExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    FloatType(l1::Loc),IntType(l2::Loc) -> t1;
    IntType(l1::Loc),FloatType(l2::Loc) -> t2; 
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for -: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

plusExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    StrType(l::Loc),t2::Type -> t1;
    t1,StrType(l::Loc) -> t2;
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    ListType(l1::Loc,t1::Type),ListType(l2::Loc,t2::Type) when typeEqual(t1,t2) -> ListType(l1,t1);
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for +: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

applyTypeExp(l::Loc,e::AST,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts::[Type] = substTypesEnv(typeEnv,ts);
      t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t {
       ForallType(l1::Loc,ns::[Str],t::Type) -> 
         if length[Str](ns) = length[Type](ts)
         then  
           let env::TEnv = zipTypeEnv(ns,ts); 
           in substTypeEnv(env + valueEnv,t);
         else throw[Type] TypeError(l,'universal type expects ' + length[Str](ns) + ' types, but supplied with ' + length[Type](ts));
       t::Type -> throw[Type] TypeError(l,'expecting a universal type: ' + t);
     } 

expTypes(es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] =
  map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);

applyType(l::Loc,op::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case expType(op,selfType,valueEnv,cnstrEnv,typeEnv) {
    FunType(l1::Loc,domain::[Type],range::Type) -> {
      let supplied::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
      in if length[Type](domain) = length[Type](supplied)
         then {
           if typesEqual(domain,supplied)
           then range; 
           else throw[Type] TypeError(l,'supplied argument types ' + ppTypes(supplied,typeEnv) + ' do not match function domain ' + ppTypes(domain,typeEnv));
         }
         else throw[Type] TypeError(l,'expecting ' + length[Type](domain) + ' args, but supplied with ' + length[Type](supplied)); }
    t::Type -> throw[Type] TypeError(l, 'unknown type for apply: ' + ppType(t,typeEnv));
  }}

ifType(l::Loc,e1::AST,e2::AST,e3::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let testType::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(testType)
     then
       let conseqType::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
           altType::Type = expType(e3,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(conseqType,altType)
          then conseqType;
          else throw[Type] TypeError(l,'conseq and alt types do not agree: ' + ppType(conseqType,typeEnv) + ' ' + ppType(altType,typeEnv));
     else throw[Type]('if expects a bool ' + ppType(testType,typeEnv));

checkDecs(ds::[TDec])::Void =
  case ds {
    [] -> null[Void];
    d::TDec:ds::[TDec] -> 
      if member[Str](decName(d),[ decName(d) | d::TDec <- ds ])
      then throw[Void] TypeError(decLoc(d),' duplicate argument ' + decName(d));
      else checkDecs(ds);
  }

funType(l::Loc,n::AST,args::[TDec],t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  checkDecs(args);
  let nType::Type = expType(n,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isStrType(nType)
     then 
       let declaredType::Type = substTypeEnv(typeEnv,t);
       in decTypes(args,valueEnv,typeEnv,fun(domain::[Type],valueEnv::TEnv)::Type {
            let actualRange::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
            in if typeEqual(declaredType,FunType(l,domain,actualRange))
               then FunType(l,domain,actualRange);
               else throw[Type] TypeError(l,'function declared type ' + ppType(declaredType,typeEnv) + ' but is ' + ppType(FunType(l,domain,actualRange),typeEnv));
          });
     else throw[Type] TypeError(l,'expecting a string for a function name: ' + n);
}

decTypes(decs::[TDec],valueEnv::TEnv,typeEnv::TEnv,consumer::([Type],TEnv)->Type)::Type =
  letrec
    processDecs(decs::[TDec],bindings::TEnv)::Type =
      case decs {
        [][TDec] -> consumer(reverse[Type](typeEnvRan(bindings)),bindings + valueEnv);
        Dec(l::Loc,n::Str,t::Type,st::Type):decs::[TDec] -> processDecs(decs,Map(n,substTypeEnv(typeEnv,t)):bindings);
      }
  in processDecs(decs,[][TMap]);

isStrType(t::Type)::Bool =
  case t {
    StrType(l::Loc) -> true;
    t::Type -> false;
  }

isIntType(t::Type)::Bool =
  case t {
    IntType(l::Loc) -> true;
    t::Type -> false;
  }

isNumType(t::Type)::Bool =
  case t {
    IntType(l::Loc) -> true;
    FloatType(l::Loc) -> true;
    t::Type -> false;
  }

isBoolType(t::Type)::Bool =
  case t {
    BoolType(l::Loc) -> true;
    t::Type -> false;
  }

termType(l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = { 
  let t0::Type = lookupType(n,cnstrEnv);
  in if t0 = null[Type]
     then throw[Type] TypeError(l,'cannot find cnstr ' + n);
     else 
       let t::Type = unfoldIf(t0);
       in termTypeCheckUnion(t,l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
}   
  
termTypeCheckUnion(t::Type,l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if t = null[Type]
     then throw[Type] TypeError(l,'cannot find constructor ' + n);
     else
       case t {
        TypeFun(lf::Loc,ns::[Str],body::Type) ->
          if length[Str](ns) = length[Type](ts)
          then 
            let args::[Type] = map[Type,Type](fun(t::Type)::Type substTypeEnv(typeEnv,t),ts); 
            in case substTypeEnv(zipTypeEnv(ns,args),body) {
                 UnionType(l1::Loc,terms::[Type]) ->
                   let ts2::[Type] = findTermArgTypes(n,terms);
                   in if length[AST](es) = length[Type](ts2)
                      then {
                        checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
                        UnionType(l1,terms);
                      }
                      else throw[Type](n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
               }
          else throw[Type] TypeError(l,'generic constructor ' + n + ' expects ' + length[Str](ns) + ' type arguments, but received ' + length[Type](ts));
        UnionType(l1::Loc,terms::[Type]) ->
          let ts2::[Type] = findTermArgTypes(n,terms);
          in if length[Type](ts) <> 0
             then throw[Type] TypeError(l,'generic application of non-generic constructior: ' + n);
             else if length[AST](es) = length[Type](ts2)
             then {
              checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
              t;
             }
             else throw[Type](n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
        t::Type -> throw[Type] TypeError(l,'expecting a union type for ' + n + ' but got ' + ppType(t,typeEnv));
       }

unfoldIf(t::Type)::Type =
  case t {
    RecType(l::Loc,n::Str,t::Type) -> unfoldIf(unfoldType(l,n,t));
    t::Type -> t; 
  }

findTermArgTypes(n::Str,terms::[Type])::[Type] =
  case terms {
    TermType(l::Loc,nn::Str,ts::[Type]):terms::[Type] when nn=n -> ts;
    [][Type] -> throw[[Type]]('cannot find constructor ' + n);
    t::Type:ts::[Type] -> findTermArgTypes(n,ts);
  }

checkTermArgTypes(l::Loc,es::[AST],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =
  case es,ts {
    (e::AST):es::[AST],t::Type:ts::[Type] ->
      let tt::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
      in {
        if typeEqual(t,tt)
         then checkTermArgTypes(l,es,ts,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Void] TypeError(l,'expected constructor arg type ' + ppType(t,typeEnv) + ' but supplied ' + ppType(tt,typeEnv));
      }
     [][AST],[][Type] -> null[Void];
  }
  

notType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  case expType(e,selfType,valueEnv,cnstrEnv,typeEnv) {
    BoolType(l::Loc) -> BoolType(l);
    t::Type -> throw[Type] TypeError(l,'expecting a boolean: ' + ppType(t,typeEnv));
  }
  
varType(l::Loc,n::Str,valueEnv::TEnv)::Type =
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else case t {
       TypeClosure(f::()->Type) -> f();
       t::Type -> t;
     }

blockType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t::Type = VoidType(l);
  in {
    for e::AST in es do
      t := expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    t;
  }     

listType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if es = [][AST]
  then ForallType(l,['T'],ListType(l,VarType(l,'T')));
  else
    let ts::[Type] = map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);
    in if allEqualTypes(head[Type](ts),tail[Type](ts))
       then ListType(l,head[Type](ts));
       else throw[Type] TypeError(l,'lists should have elements of the same type: ' + es);

allEqualTypes(t1::Type,ts::[Type])::Bool =
  case ts {
    [][Type] -> true;
    t2::Type:ts::[Type] when typeEqual(t1,t2) -> allEqualTypes(t1,ts);
    ts::[Type] -> false;
  }
    
substDec(newType::Type,n::Str,d::TDec)::TDec =
  case d {
    Dec(l::Loc,name::Str,t::Type,st::Type) -> Dec(l,name,substType(newType,n,t),st);
  }
  
substDecEnv(env::TEnv,d::TDec)::TDec =
  case d {
    Dec(l::Loc,name::Str,t::Type,st::Type) -> Dec(l,name,substTypeEnv(env,t),st);
  }
    
substMType(newType::Type,n::Str,m::MType)::MType = 
  case m {
    MessageType(l::Loc,ts::[Type]) -> MessageType(l,[ substType(newType,n,t) | t::Type <- ts]);
  }
    
substMTypeEnv(env::TEnv,m::MType)::MType = 
  case m {
    MessageType(l::Loc,ts::[Type]) -> MessageType(l,[ substTypeEnv(env,t) | t::Type <- ts]);
  }
  
substTypes(newType::Type,n::Str,oldTypes::[Type])::[Type] = {
  //print[Str]('substTypes ' + ppType(newType) + ' ' + n + ' ' + ppTypes(oldTypes));
  case oldTypes {
    [][Type] -> [][Type];
    t::Type:ts::[Type] -> substType(newType,n,t):substTypes(newType,n,ts);
  }}
    
substType(newType::Type,n::Str,oldType::Type)::Type = { 
  //print[Str]('subst type: ' + ppType(newType) + ' ' + n + ' ' + ppType(oldType));
  case oldType {
    ApplyType(l::Loc,m::Str,types::[Type]) -> 
      if m = n
      then ApplyTypeFun(l,newType,substTypes(newType,n,types));
      else ApplyType(l,m,substTypes(newType,n,types));
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ApplyTypeFun(l,substType(newType,n,op),substTypes(newType,n,args));
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 
      ActType(l,[substDec(newType,n,d) | d::TDec <- decs],[ substMType(newType,n,m) | m::MType <- handlers]);
    ArrayType(l::Loc,t::Type) -> ArrayType(l,substType(newType,n,t));
    BoolType(l::Loc) -> oldType;
    FloatType(l::Loc) -> oldType;
    ForallType(l::Loc,ns::[Str],t::Type) ->  if member[Str](n,ns) then oldType; else ForallType(l,ns,substType(newType,n,t));
    FunType(l::Loc,d::[Type],r::Type) -> FunType(l,substTypes(newType,n,d),substType(newType,n,r));
    IntType(l::Loc) -> oldType;
    ListType(l::Loc,t::Type) -> ListType(l,substType(newType,n,t));
    NullType(l::Loc) -> oldType;
    RecordType(l::Loc,fs::[Type]) -> RecordType(l,substTypes(newType,n,fs));
    RecType(l::Loc,a::Str,t::Type) ->  if n = a then oldType; else RecType(l,a,substType(newType,n,t));
    StrType(l::Loc) -> oldType;
    TermType(l::Loc,f::Str,ts::[Type]) -> TermType(l,f,substTypes(newType,n,ts));
    TypeClosure(f::()->Type) -> oldType; // Type closures should not have free variables.
    TypeFun(l::Loc,ns::[Str],t::Type) -> if member[Str](n,ns) then oldType; else TypeFun(l,ns,substType(newType,n,t));
    UnfoldType(l::Loc,t::Type) -> UnfoldType(l,substType(newType,n,t));
    UnionType(l::Loc,ts::[Type]) -> UnionType(l,substTypes(newType,n,ts));
    VarType(l::Loc,name::Str) -> if name = n then newType; else oldType;
    VoidType(l::Loc) -> oldType;
    UnionRef(l::Loc,t::Type,name::Str) -> UnionRef(l,substType(newType,n,t),name); 
    x::Type -> throw[Type]x;
  }
}
 
substTypesEnv(env::TEnv,types::[Type])::[Type] =
  case types {
    [][Type] -> [][Type];
    t::Type:ts::[Type] -> substTypeEnv(env,t):substTypesEnv(env,ts);
  }
    
substTypeEnv(env::TEnv,oldType::Type)::Type = { //print[Str]('subst type env: ' + oldType);
  case oldType {
    ApplyType(l::Loc,n::Str,types::[Type]) -> 
      let op::Type = lookupType(n,env);
      in if op = null[Type]
         then ApplyType(l,n,substTypesEnv(env,types));
         else ApplyTypeFun(l,op,substTypesEnv(env,types));
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ApplyTypeFun(l,substTypeEnv(env,op),substTypesEnv(env,args));
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 
      ActType(l,[substDecEnv(env,d) | d::TDec <- decs],[ substMTypeEnv(env,m) | m::MType <- handlers]);
    ArrayType(l::Loc,t::Type) -> ArrayType(l,substTypeEnv(env,t)); 
    BoolType(l::Loc) -> oldType;
    FloatType(l::Loc) -> oldType;
    ForallType(l::Loc,ns::[Str],t::Type) -> ForallType(l,ns,substTypeEnv(removeFromDom(env,ns),t));
    FieldType(l::Loc,n::Str,t::Type) -> FieldType(l,n,substTypeEnv(env,t));
    FunType(l::Loc,d::[Type],r::Type) -> FunType(l,[substTypeEnv(env,t) | t::Type <- d],substTypeEnv(env,r));
    TaggedFunType(l::Loc,d::[Type],p::Str,r::Type) -> FunType(l,[substTypeEnv(env,t) | t::Type <- d],substTypeEnv(env,r));
    IntType(l::Loc) -> oldType;
    ListType(l::Loc,t::Type) -> ListType(l,substTypeEnv(env,t));
    SetType(l::Loc,t::Type) -> SetType(l,substTypeEnv(env,t));
    BagType(l::Loc,t::Type) -> BagType(l,substTypeEnv(env,t)); 
    NullType(l::Loc) -> oldType;
    RecType(l::Loc,a::Str,t::Type) ->  RecType(l,a,substTypeEnv(removeFromDom(env,[a]),t));
    RecordType(l::Loc,fs::[Type]) -> RecordType(l,substTypesEnv(env,fs));
    StrType(l::Loc) -> oldType;
    TermType(l::Loc,f::Str,ts::[Type]) -> TermType(l,f,[substTypeEnv(env,t) | t::Type <- ts]);
    TypeClosure(f::()->Type) -> oldType; //TypeClosure(fun['substTypeEnv_closure']()::Type substTypeEnv(env,f()));
    TypeFun(l::Loc,ns::[Str],t::Type) -> TypeFun(l,ns,substTypeEnv(removeFromDom(env,ns),t));
    UnfoldType(l::Loc,t::Type) -> UnfoldType(l,substTypeEnv(env,t));
    UnionType(l::Loc,ts::[Type]) -> UnionType(l,[substTypeEnv(env,t) | t::Type <- ts]);
    VarType(l::Loc,name::Str) -> if member[Str](name,typeEnvDom(env)) then lookupType(name,env); else oldType;
    VoidType(l::Loc) -> oldType;
    UnionRef(l::Loc,t::Type,name::Str) -> UnionRef(l,substTypeEnv(env,t),name); 
    x::Type -> throw[Type]oldType;
  }
}
    
recTypes(env::TEnv)::TEnv =
  letrec

    fixEnv(env::TEnv)::TEnv =
      let e::TEnv = null[TEnv];
      in let fenv::TEnv = [ Map(n,TypeClosure(fun['lookup: ' + n]()::Type lookupType(n,e))) | t::Type <- typeEnvRan(env), n::Str <- typeFV(t) ];
         in let env1::TEnv = substOnce(env,fenv);
            in { e := env1; env1; }
    
   
    introduceRecTypes(env::TEnv)::TEnv = {
      case env {
        [][TMap] -> env;
        Map(n::Str,t::Type):e::TEnv ->
          if member[Str](n,typeFV(t))
          then Map(n,RecType(p0,n,t)):introduceRecTypes(e);
          else Map(n,t):introduceRecTypes(e);
      }
    }
    substOnceOld(env::TEnv,getType::(Str)->Type)::TEnv = 
      let
        map1(m::TMap)::TMap =
          case m {
            Map(n::Str,t::Type) -> Map(n,substTypeEnv([ Map(n,getType(n)) | n::Str <- typeFV(t) ],t));
          }
      in map[TMap,TMap](map1,env);
      
    substOnce(env::TEnv,fenv::TEnv)::TEnv = 
      let 
        map1(m::TMap)::TMap =
          case m {
            Map(n::Str,t::Type) -> Map(n,substTypeEnv([ Map(n,lookupType(n,fenv)) | n::Str <- typeFV(t) ],t));
          }
      in map[TMap,TMap](map1,env);
  in fixEnv(introduceRecTypes(env));
         
    
typeFV(t::Type)::[Str] = (removeDups[Str](varTypeNames(typeFV1(t,[][Type])))); 

varTypeNames(vs::[Type])::[Str] = map[Type,Str](varTypeName,vs);
  
varTypeName(t::Type)::Str =
  case t {
    VarType(l::Loc,n::Str) -> n;
    x::Type -> '<var>';
  }
  
tdecsFV1(decs::[TDec],fv::[Type])::[Type] =
  case decs {
    [][TDec] -> fv;
    d::TDec:ds::[TDec] -> tdecFV1(d,tdecsFV1(ds,fv));
  }
  
tdecFV1(d::TDec,fv::[Type])::[Type] =
  case d { 
    Dec(l::Loc,n::Str,t::Type,st::Type) -> 
      typeFV1(t,fv); 
  }
  
handlersFV1(handlers::[MType],fv::[Type])::[Type] =
  case handlers {
    [][MType] -> fv;
    m::MType:hs::[MType] -> handlerFV1(m,handlersFV1(hs,fv));
  }
  
handlerFV1(m::MType,fv::[Type])::[Type] =
  case m { 
    MessageType(l::Loc,ts::[Type]) -> 
      typesFV1(ts,fv); 
  }
  
typesFV1(ts::[Type],fv::[Type])::[Type] = 
  case ts {
    [][Type] -> fv;
    t::Type:ts::[Type] -> typeFV1(t,typesFV1(ts,fv));
  }
    
typeFV1(t::Type,fv::[Type])::[Type] = { //print[Str]('FV ' + t);
 
  // Return a list of VarTypes that are not bound. The VarType contains the 
  // position if we need to raise a positional error...
  
  case t {
    ArrayType(l::Loc,t::Type) -> typeFV1(t,fv);
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> tdecsFV1(decs,handlersFV1(handlers,fv));
    ApplyType(l::Loc,n::Str,types::[Type]) -> typesFV1(types,VarType(l,n):fv);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> typesFV1(args,typeFV1(op,fv));
    BoolType(l::Loc) -> fv;
    FieldType(l::Loc,n::Str,t::Type) -> typeFV1(t,fv);
    FloatType(l::Loc) -> fv;
    ForallType(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    FunType(l::Loc,d::[Type],r::Type) -> typesFV1(d,typeFV1(r,fv));
    IntType(l::Loc) -> fv;
    ListType(l::Loc,t::Type) -> typeFV1(t,fv);
    BagType(l::Loc,t::Type) -> typeFV1(t,fv);
    SetType(l::Loc,t::Type) -> typeFV1(t,fv);
    NullType(l::Loc) -> fv; 
    RecordType(l::Loc,fs::[Type]) -> typesFV1(fs,fv); 
    RecType(l::Loc,a::Str,t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(n = a); },typeFV1(t,[][Type])) + fv;
    StrType(l::Loc) -> fv;
    TypeClosure(f::()->Type) -> [][Type];
    TermType(l::Loc,n::Str,ts::[Type]) -> typesFV1(ts,fv);
    TypeFun(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    UnfoldType(l::Loc,t::Type) -> typeFV1(t,fv);
    UnionType(l::Loc,ts::[Type]) -> typesFV1(ts,fv);
    VarType(l::Loc,n::Str) -> t:fv;
    VoidType(l::Loc) -> fv;
    UnionRef(l::Loc,t::Type,n::Str) ->typeFV1(t,fv);
    x::Type -> throw[[Type]]x; 
  }
}

act main::Main {
  -> {
   try {
    typeCheckModule('esl/compiler/test1.esl'); 
    //typeCheckModule(parse[AST]('new_esl/tmp/lists.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    //typeCheckModule(parse[AST]('new_esl/tmp/test5.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    //typeCheckModule(parse[AST]('new_esl/tmp/collisions.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    //typeCheckModule(parse[AST]('new_esl/tmp/test6.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
   }
   catch {
      message::Str ->  print[Str]('Type Error: ' + message); 
    }
  print[Str]('DONE');
  stopAll();
  }
}