/********************************************************************************************************************************
 *                                                                                                                              *
 *                                                 The ESL Type Checker                                                         *
 *                                                 ====================                                                         *
 *                                                                                                                              *
 *   This file implements the ESL type checker that recursively descends into an ESL module and checks the declared types.      *
 *   The checker performs minimal type inference on patterns, but otherwise relies on the declarations in the source.           *
 *   Where a type mismatch occurs, the source code maintains character start and end positions of each abstract syntax          *
 *   construct and can raise a TypeError containing the location of the problem. The type checker maintains a cache so that     *
 *   imported modules are not re-checked during a single cycle of the type-checker. Care is taken with recursive types to       *
 *   ensure that top-level type bindings refer to the same value and are therefore = rather than equal and can short-circuit    *
 *   comparison (otherwise unfolding in typeEqual will not terminate). Care is also taken to replace all named type references  *
 *   before the source is checked so that no free type variables occur in the type expressions. Note that types are compared    *
 *   for structural equivalence.                                                                                                *
 *                                                                                                                              *
 *                                                                                                                              *
 ********************************************************************************************************************************/

export main,typeCheckModule,typeCheckEntryPoint;

import 'esl/lists.esl','esl/compiler/types.esl','esl/tables.esl','esl/displays.esl'; 

type Main = Act { }

ppPattern(p::Pattern)::Str = 
  case p { 
    PAdd(l::Loc,p1::Pattern,p2::Pattern) -> ppPattern(p1) + ' + ' + ppPattern(p2);
    PVar(l::Loc,n::Str,t::Type) -> n;
    PTerm(l::Loc,n::Str,[][Type],ps::[Pattern]) -> n + ppPatterns(ps);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> n + ppTypes(ts,[]) + '' + ppPatterns(ps); 
    PApplyType(l::Loc,p::Pattern,ts::[Type]) -> ppPattern(p) + ppTypes(ts,[]);
    PNil(l::Loc) -> '[]';
    PEmptySet(l::Loc) -> 'Set{}';
    PEmptyBag(l::Loc) -> 'Bag{}';
    PInt(l::Loc,n::Int) -> ''+n;
    PBool(l::Loc,b::Bool) -> ''+b;
    PStr(l::Loc,s::Str) -> s;
    PCons(l::Loc,h::Pattern,t::Pattern) -> ppPattern(h) + ':' + ppPattern(t);
    PSetCons(l::Loc,p1::Pattern,p2::Pattern) -> 'Set{' + ppPattern(p1) + ' | ' + ppPattern(p2) + '}';
    PBagCons(l::Loc,p1::Pattern,p2::Pattern) -> 'Bag{' + ppPattern(p1) + ' | ' + ppPattern(p2) + '}';
    p::Pattern -> '<unknown: ' + p + '>';
  }

ppPatterns(ps::[Pattern])::[Str] = map[Pattern,Str](ppPattern,ps);

p0::Loc = Pos(0,0);
actType0::Type = ActType(p0,[],[]);

contentType::Type = UnionType(p0,[TermType(p0,'RawText',[StrType(p0)]),TermType(p0,'ESLSource',[StrType(p0),StrType(p0)]),TermType(p0,'JavaSource',[StrType(p0),StrType(p0),StrType(p0)])]);

editMessage::MType = MessageType(p0,[TermType(p0,'Edit',[contentType])]);

env0::TEnv = [
  Map('edb',ActType(p0,[Dec(p0,'button',FunType(p0,[StrType(p0),StrType(p0),StrType(p0),StrType(p0),FunType(p0,[],VoidType(p0))],VoidType(p0)),null[Type]),Dec(p0,'display',ForallType(p0,['T'],FunType(p0,[StrType(p0),VarType(p0,'T')],VarType(p0,'T'))),null[Type])],[editMessage])),
  Map('kill',ForallType(p0,['T'],FunType(p0,[VarType(p0,'T')],VoidType(p0)))),
  Map('print',ForallType(p0,['T'],FunType(p0,[VarType(p0,'T')],VoidType(p0)))),
  Map('parse',ForallType(p0,['T'],FunType(p0,[StrType(p0)],VarType(p0,'T')))),
  Map('random',FunType(p0,[IntType(p0)],IntType(p0))),
  Map('wait',FunType(p0,[IntType(p0)],VoidType(p0))),
  Map('stopAll',FunType(p0,[],VoidType(p0))),
  Map('isqrt',FunType(p0,[IntType(p0)],FloatType(p0))),
  Map('builtin',ForallType(p0,['T'],FunType(p0,[StrType(p0),StrType(p0),IntType(p0)],VarType(p0,'T'))))
];

cnstrEnv0::TEnv = [
  Map('Time',UnionType(p0,[TermType(p0,'Time',[IntType(p0)])]))
];

tenv0::TEnv = [
  Map('EditType',contentType),
  Map('Time',UnionType(p0,[TermType(p0,'Time',[IntType(p0)])])),
  Map('Point',UnionType(p0,[TermType(p0,'Point',[IntType(p0),IntType(p0)])]))
];

ppTypeEnv(env::TEnv)::Str =
  let s::Str = '[';
  in {
    for Map(n::Str,t::Type) in env do
      s := s + n + '->' + ppType(t,env) + ',';
    s+']';
  }

ppTypes(ts::[Type],env::TEnv)::[Str] = map[Type,Str](ppType0(env),ts);

getTypeName(t0::Type,env::TEnv)::Str =
  let name::Str = null[Str];
  in { 
    for Map(n::Str,t::Type) in env do {
      if typeEqual(t0,t)
      then name := n;
      else {}
    }
    name;
  }

ppType0(env::TEnv)::(Type) ->Str = fun(t::Type)::Str ppType(t,env); 

ppHandlers(handlers::[MType],env::TEnv)::Str =
  case handlers {
    [] -> '';
    MessageType(l::Loc,t::Type:ts::[Type]):hs::[MType] -> ppType(t,env) + '; ' + ppHandlers(hs,env);
  }
ppDecs(decs::[TDec],env::TEnv)::Str =
  case decs {
    [] -> '';
    Dec(l,n,t,d):decs::[TDec] -> n + '::' + ppType(t,env) + '; ' + ppDecs(decs,env);
  }
  
ppType(t::Type,env::TEnv)::Str = { if getTypeName(t,env) <> null[Str] then getTypeName(t,env); else
  case t {
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 'Act { ' + ppHandlers(handlers,env) + ' }';
    ApplyType(l::Loc,n::Str,args::[Type]) -> n + map[Type,Str](ppType0(env),args);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ppType(op,env) + map[Type,Str](ppType0(env),args);
    ArrayType(l::Loc,t::Type) -> 'Array[' + ppType(t,env) + ']';
    BagType(l::Loc,t::Type) -> 'Set{'+ ppType(t,env) + '}';
    BoolType(l::Loc) -> 'Bool';
    ExtendedAct(l::Loc,parent::Type,decs::[TDec],handlers::[MType]) -> 'Act extends ' + ppType(parent,env) + ' { ' + ppHandlers(handlers,env) + ' }';
    FloatType(l::Loc) -> 'Float';
    FieldType(l::Loc,n::Str,t::Type) -> n + '::' + ppType(t,env);
    ForallType(l::Loc,ns::[Str],t::Type) -> 'Forall' + ns + '.' + ppType(t,env);
    FunType(l::Loc,d::[Type],r::Type) -> map[Type,Str](ppType0(env),d) + '->' + ppType(r,env);
    TaggedFunType(l::Loc,d::[Type],p::Str,r::Type) -> map[Type,Str](ppType0(env),d) + '->' + ppType(r,env);
    IntType(l::Loc) -> 'Int';
    ListType(l::Loc,t::Type) -> '[' + ppType(t,env) + ']';
    NullType(l::Loc) -> 'Null';
    RecType(l::Loc,n::Str,t::Type) -> 'rec ' + n + '.' + ppType(t,env);
    RecordType(l::Loc,fs::[TDec])  -> '{' + ppDecs(fs,env) + '}';
    SetType(l::Loc,t::Type) -> 'Set{'+ ppType(t,env) + '}';
    StrType(l::Loc) -> 'Str';
    TableType(l::Loc,k::Type,v::Type) -> 'Hash[' + ppType(k,env) + ',' + ppType(v,env) + ']';
    TermType(l::Loc,n::Str,ts::[Type]) -> n + map[Type,Str](ppType0(env),ts);
    TypeFun(l::Loc,ns::[Str],t::Type) -> 'Fun' + ns + '.' + ppType(t,env);
    UnfoldType(l::Loc,t::Type) -> 'unfold ' + ppType(t,env);
    UnionType(l::Loc,ts::[Type]) -> 'union ' + map[Type,Str](ppType0(env),ts);
    VarType(l::Loc,n::Str) -> n;
    VoidType(l::Loc) -> 'Void';
    UnionRef(l::Loc,t::Type,n::Str) -> ppType(t,env) + '.' + n;
    TypeClosure(f::()->Type) -> f + '';
    x::Type -> '<unknown ' + x + '>';
  }
}
  
typeEnv(defs::[TBind])::TEnv =
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    b::TBind:ds::[TBind] -> typeEnv(ds);
  }
  
cnstrEnv(defs::[TBind],env::TEnv)::TEnv = 
  // For legacy reasons, handle data type definitions that use union explicitly...
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,RecType(ll::Loc,m::Str,UnionType(lll::Loc,ts::[Type])),e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    TypeBind(l::Loc,n::Str,UnionType(lll::Loc,ts::[Type]),e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> cnstrEnv(ds,env);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    b::TBind:ds::[TBind] -> cnstrEnv(ds,env);
  } 

getConstructors(l::Loc,dataType::Type,t::Type)::TEnv = { //print[Str]('get constructors ' + ppType(t));
  // The type name may refer to a normal union, a recursive union, a type function, or a recursive type function...
  // rec Tree.Fun[X].union [Leaf[X],Pair[Tree[X],Tree[X]]]
  case t {
      RecType(l::Loc,n::Str,t::Type) -> getConstructors(l,dataType,t);
      TypeFun(l::Loc,ns::[Str],t::Type) ->  getConstructors(l,dataType,t);
      UnionType(l::Loc,ts::[Type]) ->
        map[Type,TMap](fun(t::Type)::TMap case t { TermType(l::Loc,n::Str,tts::[Type]) -> Map(n,dataType); },ts);
      t -> throw[TEnv] TypeError(l,'cannot extract constructors from ' + ppType(t,[]));
  }}

checkFreeTypes(e::TEnv)::Void =

  // Assumes that the types are all recursive and will throw an error
  // if the types in the environment have a free type variable reference
  // that is not bound by the environment...
  
  let dom::[Str] = typeEnvDom(e);
      ran::[Type] = typeEnvRan(e); in
  let freeNames::[Str] = removeAll[Str](dom,flatten[Str](map[Type,[Str]](typeFV,ran)));
  in if freeNames = [][Str]
     then null[Void];
     else throw[Void] TypeError(Pos(0,0),'Unbound Types: ' + freeNames);
     
checkSingletonTypes(e::TEnv)::Void =
  
  // Check that no types have the same name...
 
  case e {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):e::TEnv -> 
      if member[Str](n,typeEnvDom(e))
      then throw[Void] TypeError(Pos(0,0),'Duplicate type name: ' + n);
      else checkSingletonTypes(e);
  }
     
checkSingletonConstructors(cnstrEnv::TEnv)::Void = 
  
  // Check that no types have the same name...
 
  case cnstrEnv {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):cnstrEnv::TEnv ->
      if member[Str](n,typeEnvDom(cnstrEnv))
      then 
        letrec
          throwError(t::Type)::Void = 
            case t {
              UnionType(l,ts)    -> throw[Void] TypeError(l,'Duplicate constructor name: ' + n);
              ForallType(l,ns,t) -> throwError(t);
              RecType(l,n,t)     -> throwError(t);
              TypeFun(l,ns,t)    -> throwError(t);
              t                  -> throw[Void]('Duplicate constructor name: ' + n + ' ' + t);
            }
        in throwError(t);
      else checkSingletonConstructors(cnstrEnv);
  }


valueDefs(defs::[TBind])::[TBind] =
  case defs {
    [][TBind] -> [][TBind];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    DataBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    CnstrBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    b::TBind:ds::[TBind] -> b:valueDefs(ds);
  }

 valueDefsToTEnv(defs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv = { 
   case defs {
     [][TBind] -> [][TMap];
     FunBinds(n,FunCase(l,args,t,g,e):cases):ds ->
       Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
     FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,st::Type,b::AST,g::AST):ds::[TBind] ->
       Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
     Binding(l::Loc,n::Str,t::Type,st::Type,e::AST):ds::[TBind] -> 
       Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
   }
 }

data TRecord = 
  Typed(AST,TEnv,TEnv,TEnv)
| Undefined;

getCache()::Table[Str,TRecord] =
  let cache::Table[Str,TRecord] = edb.getProperty[Table[Str,TRecord]]('typeCheckCache');
  in if cache = null[Table[Str,TRecord]]
     then emptyTable[Str,TRecord];
     else cache;

setCache(cache::Table[Str,TRecord])::Void =
  edb.setProperty[Table[Str,TRecord]]('typeCheckCache',cache);

updateCache(path::Str,record::TRecord,cache::Table[Str,TRecord])::Table[Str,TRecord] = {
  let cache::Table[Str,TRecord] = addEntry[Str,TRecord](path,record,cache);
  in {
    setCache(cache);
    cache;
  }
}

typeCheckModule(path::Str)::Void = {
  print[Str]('[ type check ' + path + ']');
  typeCheckModuleInternal(path,getCache(),fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
}
 
typeCheckModuleInternal(path::Str,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) ->Void)::Void =
  if hasEntry[Str,TRecord](path,cache)
  then 
    case lookup[Str,TRecord](path,cache) {
      Typed(m::AST,vEnv::TEnv,cEnv::TEnv,tEnv::TEnv) -> handler(cache,vEnv,cEnv,tEnv);
      Undefined                                      -> throw[Void]('recursive reference to ' + path);
    }
  else 
    let m::AST = parse[AST](path);
    in typeCheckModuleCache(m,updateCache(path,Undefined,cache),fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void 
      handler(updateCache(path,Typed(m,valueEnv,cnstrEnv,typeEnv),cache),valueEnv,cnstrEnv,typeEnv));

typeCheckEntryPoint(module::AST)::Void = {
  typeCheckModuleCache(module,getCache(),fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
}
typeCheckModuleCache(module::AST,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) -> Void)::Void =
  typeCheckModule0(module,cache,fun(cache::Table[Str,TRecord],valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void 
    case module {
        Module(path::Str,name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> { 
          handler(cache,restrictTypeEnv(valueEnv,exports),restrictTypeEnv(cnstrEnv,exports),restrictTypeEnv(typeEnv,exports));
        }
    });

typeCheckModule0(module::AST,cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) ->Void)::Void = 

  // Called to process a module (including dealing with imports)
  // and to generate type errors where they occur...

  letrec

    processImports(imports::[Str],cache::Table[Str,TRecord],handler::(Table[Str,TRecord],TEnv,TEnv,TEnv) -> Void)::Void =

      case imports {
        [][Str] -> handler(cache,[][TMap],[][TMap],[][TMap]);
        path::Str:imports::[Str] ->
          let imports::[Str] = imports; in // Closure bug, pattern vars are not closed in...
          typeCheckModuleInternal(path,cache,fun(cache::Table[Str,TRecord],valueEnv0::TEnv,cnstrEnv0::TEnv,typeEnv0::TEnv)::Void
            processImports(imports,cache,fun(cache::Table[Str,TRecord],valueEnv1::TEnv,cnstrEnv1::TEnv,typeEnv1::TEnv)::Void
              handler(cache,valueEnv1+valueEnv0,cnstrEnv1+cnstrEnv0,typeEnv1+typeEnv0)));
      }
  
    main()::Void =
      case module {
        Module(path::Str,name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> { 
          processImports(imports,cache,fun(cache::Table[Str,TRecord],ivalueEnv::TEnv,icnstrEnv::TEnv,itypeEnv::TEnv)::Void
            let e::TEnv = typeEnv(defs);
                defs::[TBind] = mergeFunDefs(defs);
            in { 
              checkDupBindings(defs);
              checkFreeTypes(e+itypeEnv+tenv0);
              checkSingletonTypes(e);
              let typeEnv::TEnv = recTypes(e + itypeEnv + tenv0); in 
              let cnstrEnv::TEnv = cnstrEnv(defs,typeEnv) + icnstrEnv + cnstrEnv0; 
              in { 
                //print[Str]('******************************************************');
                //print[Str]('module = ' + name);
                //print[Str]('itypeEnv = ' + ppTypeEnv(itypeEnv));
                //print[Str]('typeEnv = ' + ppTypeEnv(typeEnv));
                //print[Str]('cnstrEnv = ' + ppTypeEnv(cnstrEnv));
                //print[Str]('value defs = ' + valueDefs(defs));
                checkSingletonConstructors(cnstrEnv); 
                // Add in the definitions into the type env and
                // then type check each of the definitions and
                // compare the generated type with the declared
                // type...
                let valueEnv::TEnv = typeCheckValues(valueDefs(defs),NullType(p0),ivalueEnv,typeEnv,cnstrEnv);
                in handler(cache,valueEnv,cnstrEnv,typeEnv);
              }
            });
      }
      }
  in main();

typeCheckValues(valueDefs::[TBind],selfType::Type,ivalueEnv::TEnv,typeEnv::TEnv,cnstrEnv::TEnv)::TEnv =

  // Create a value-to-type environment...

  let valueEnv::TEnv = valueDefsToTEnv(valueDefs,selfType,[][TMap],cnstrEnv,typeEnv) + ivalueEnv + env0;
  in {
    for def::TBind in valueDefs do {
    // Get the type of the defined expression and compare it to the
    // declared type...
    typeCheckDef(def,selfType,valueEnv,valueEnv,cnstrEnv,typeEnv);
   }
   valueEnv;
}

genericize(l::Loc,t::Type)::Type = if length[Str](typeFV(t)) = 0 then t; else ForallType(l,typeFV(t),t);

checkPatterns(l::Loc,ps::[Pattern])::Void =
  let names::[Str] = [ n | p::Pattern <- ps, n::Str <- patternNames(p) ];
  in if removeDups[Str](names) <> names 
     then throw[Void] TypeError(l,'duplicate pattern variables');
     else null[Void];

typeCheckDef(def::TBind,selfType::Type,baseValueEnv::TEnv,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =

  // Type check any binding that could occur at the top level, in a behaviour definition, a let-binding, a let-rec-binding.
  
  case def {
    FunBinds(n,cases) -> {
      letrec
        checkArities(cases::[FunCase],arity::Int)::Void =
          case cases {
            [] -> {}
            FunCase(l,args,t,g,e):cases ->
              if arity = -1 or length[Pattern](args) = arity 
              then checkArities(cases,length[Pattern](args));
              else throw[Void] TypeError(l,'inconsistent overloaded arity');
          }
        checkLoneVars(cases::[FunCase])::Void =
          case cases {
            [] -> {}
            FunCase(l,args,t,g,e):cases -> {
              for arg::Pattern in args do {
                checkLoneVar(arg);
              }
              checkLoneVars(cases);
            }
          }
        checkLoneVar(p::Pattern)::Void = { 
          case p {
            PVar(l,n,VoidType(tl)) ->
              throw[Void] TypeError(l,'top level variables should be typed.');
            p -> {}
          }
        }
       in {
        checkArities(cases,-1);
        checkLoneVars(cases); // Extend to check that vars all all typed.
        // extract signatures.
        // compare signatures.
        // match signatures with bodies.
       }
    }
    FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,st::Type,b::AST,g::AST) -> {
      checkPatterns(l,ps);
      let argTypes::[Type] = map[Pattern,Type](fun(p::Pattern)::Type case p { PVar(l::Loc,n::Str,t::Type) -> substTypeEnv(typeEnv,t); },ps);
          argNames::[Str] = map[Pattern,Str](fun(p::Pattern)::Str case p { PVar(l::Loc,n::Str,t::Type) -> n; },ps);
      in let bodyType::Type = guardedExpType(l,g,b,selfType,zipTypeEnv(argNames,argTypes) + baseValueEnv,cnstrEnv,typeEnv); in
      let fType::Type = case t { ForallType(l::Loc,ns::[Str],t::Type) -> genericize(l,FunType(l,argTypes,bodyType)); t::Type -> FunType(l,argTypes,bodyType); }
          dType::Type = substTypeEnv(typeEnv,t);
      in { 
        if subType(fType,dType) //typeEqual(fType,dType)
        then {} //print[Str](n + '::' + ppType(lookupType(n,valueEnv)) + ' = ' + ppType(bodyType));
        else throw[Void] TypeError(l,'type of ' + n + '::' + ppType(fType,typeEnv) + ' does not match declaration ' + ppType(dType,typeEnv));
      }
    }
    Binding(l::Loc,n::Str,dt::Type,st::Type,e::AST) -> { //print[Str]('type check def ' + def);
      let valueType::Type = expType(e,selfType,baseValueEnv,cnstrEnv,typeEnv); in
      let valueFV::[Str] = typeFV(valueType);
          declaredType::Type = lookupType(n,valueEnv); in
      let valueType::Type = if valueFV = [][Str] then valueType; else ForallType(l,valueFV,valueType);
      in { 
        if subType(valueType,declaredType) //typeEqual(valueType,declaredType)
        then {} //print[Str](n + '::' + ppType(declaredType) + ' = ' + ppType(valueType));
        else throw[Void] TypeError(l,'type of ' + n + ' ' + ppType(valueType,typeEnv) + ' does not match declared type = ' + ppType(declaredType,typeEnv));
      }
    }
  }

guardedExpType(l::Loc,g::AST,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bt::Type = expType(g,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(bt) 
     then expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
     else throw[Type] TypeError(l,'guarded expression requires a boolean value: ' + ppType(bt,typeEnv));

expType(e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = { //print[Str]('exp type: ' + e); 
  case e {
    ActExp(l::Loc,n::AST,args::[TDec],exports::[Str],parent::AST,bindings::[TBind],init::AST,arms::[Arm]) -> actType(l,n,args,parent,exports,bindings,init,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Apply(l::Loc,op::AST,args::[AST]) -> applyType(l,op,args,selfType,valueEnv,cnstrEnv,typeEnv);
    ApplyTypeExp(l::Loc,e::AST,ts::[Type]) -> applyTypeExp(l,e,ts,selfType,valueEnv,cnstrEnv,typeEnv);
    ArrayUpdate(l::Loc,a::AST,i::AST,v::AST) -> arrayUpdateType(l,a,i,v,selfType,valueEnv,cnstrEnv,typeEnv);
    ArrayRef(l::Loc,a::AST,i::AST) -> arrayRefType(l,a,i,selfType,valueEnv,cnstrEnv,typeEnv);
    BagExp(l::Loc,es::[AST]) -> bagType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Become(l::Loc,e::AST) -> becomeType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    BinExp(l::Loc,e1::AST,op::Str,e2::AST) -> binExpType(l,e1,op,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    Block(l::Loc,es::[AST]) -> blockType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    BoolExp(l::Loc,b::Bool) -> BoolType(l);
    Case(l::Loc,decs::[TDec],es::[AST],arms::[Arm]) -> caseType(l,es,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Cmp(l::Loc,e::AST,qs::[Qualifier]) -> cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
    Grab(l::Loc,refs::[DRef],e::AST) -> expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    FloatExp(l::Loc,f::Float) -> FloatType(l);
    Fold(l::Loc,t::Type,e::AST) -> foldType(l,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    For(l::Loc,p::Pattern,list::AST,e::AST) -> forType(l,p,list,e,selfType,valueEnv,cnstrEnv,typeEnv);
    FunExp(l::Loc,n::AST,args::[TDec],t::Type,e::AST) -> funType(l,n,args,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    If(l::Loc,e1::AST,e2::AST,e3::AST) -> ifType(l,e1,e2,e3,selfType,valueEnv,cnstrEnv,typeEnv);
    IntExp(l::Loc,n::Int) -> IntType(l);
    Let(l::Loc,bs::[TBind],e::AST) -> letType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Letrec(l::Loc,bs::[TBind],e::AST) -> letrecType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    List(l::Loc,es::[AST]) -> listType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Now(l::Loc) -> IntType(l);
    Probably(l::Loc,p::AST,t::Type,e1::AST,e2::AST) -> probablyType(l,p,t,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    PLet(l::Loc,bs::[TBind],e::AST) -> letType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Record(l::Loc,fields::[TBind]) -> recordType(l,fields,selfType,valueEnv,cnstrEnv,typeEnv);
    Ref(l::Loc,e::AST,n::Str) -> refType(l,e,n,selfType,valueEnv,cnstrEnv,typeEnv);
    RefSuper(l::Loc,n::Str) -> refType(l,Var(l,'$super'),n,selfType,valueEnv,cnstrEnv,typeEnv);
    Self(l::Loc) -> selfType;
    Send(l::Loc,target::AST,Term(tl::Loc,n::Str,ts::[Type],args::[AST])) -> sendType(l,target,n,args,selfType,valueEnv,cnstrEnv,typeEnv);
    SendTimeSuper(l::Loc) -> VoidType(l);
    SendSuper(l::Loc,e::AST) -> VoidType(l);
    SetExp(l::Loc,es::[AST]) -> setType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    StrExp(l::Loc,s::Str) -> StrType(l);
    Term(l::Loc,n::Str,ts::[Type],es::[AST]) -> termType(l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Throw(l::Loc,t::Type,e::AST) -> throwType(l,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Try(l::Loc,e::AST,arms::[Arm]) -> tryType(l,e,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    New(l::Loc,b::AST,args::[AST]) -> newType(l,b,args,selfType,valueEnv,cnstrEnv,typeEnv);
    NewArray(l::Loc,t::Type,i::AST) -> newArrayType(l,t,i,selfType,valueEnv,cnstrEnv,typeEnv);
    NewTable(l::Loc,key::Type,value::Type) -> TableType(l,substTypeEnv(typeEnv,key),substTypeEnv(typeEnv,value));
    NewJava(l::Loc,path::Str,t::Type,args::[AST]) -> { for a::AST in args do expType(a,selfType,valueEnv,cnstrEnv,typeEnv); substTypeEnv(typeEnv,t); }
    Not(l::Loc,e::AST) -> notType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    NullExp(l::Loc) -> ForallType(l,['T'],VarType(l,'T'));
    Unfold(l::Loc,t::Type,e::AST) -> unfoldTypeExp(l,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Update(l::Loc,n::Str,e::AST) -> updateType(l,n,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Var(l::Loc,n::Str) -> varType(l,n,valueEnv);
  }}

throwType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let valType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in substTypeEnv(typeEnv,t); 

foldType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let eType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(substTypeEnv(typeEnv,t),eType)
     then eType;
     else throw[Type] TypeError(l,'fold type ' + ppType(t,typeEnv) + ' does not equal ' + ppType(eType,typeEnv));

unfoldTypeExp(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let eType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
      recType::Type = substTypeEnv(typeEnv,t);
  in {
    case recType {
       RecType(rl,n,t) -> 
         if typeEqual(substType(eType,n,t),eType)
         then eType;
         else throw[Type] TypeError(l,'unfold type ' + ppType(substType(eType,n,t),typeEnv) + ' does not equal ' + ppType(eType,typeEnv));
       t -> throw[Type] TypeError(l,'unfold type expects a rec type' + ppType(recType,typeEnv));
    }
  }

arrayUpdateType(l::Loc,a::AST,i::AST,v::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let aType::Type = expType(a,selfType,valueEnv,cnstrEnv,typeEnv);
      iType::Type = expType(i,selfType,valueEnv,cnstrEnv,typeEnv);
      vType::Type = expType(v,selfType,valueEnv,cnstrEnv,typeEnv);
  in case aType {
    ArrayType(al::Loc,t::Type) ->
      if isIntType(iType)
      then 
        if typeEqual(vType,t)
        then aType;
        else throw[Type] TypeError(l,'value type ' + vType + ' does not match array type ' + t);
      else throw[Type] TypeError(l,'array index should be an integer ' + i);
    t::Type -> throw[Type] TypeError(l,'expecting an array ' + aType);
  }

arrayRefType(l::Loc,a::AST,i::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let aType::Type = expType(a,selfType,valueEnv,cnstrEnv,typeEnv);
      iType::Type = expType(i,selfType,valueEnv,cnstrEnv,typeEnv);
  in case aType {
    ArrayType(al::Loc,t::Type) ->
      if isIntType(iType)
      then t;
      else throw[Type] TypeError(l,'array index should be an integer ' + i);
    t::Type -> throw[Type] TypeError(l,'expecting an array ' + aType);
  }

newArrayType(l::Loc,t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
   let i::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
   in if isIntType(i)
      then ArrayType(l,substTypeEnv(typeEnv,t));
      else throw[Type] TypeError(l,'expecting an integer type: ' + i);

becomeType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(bType,selfType)
     then bType;
     else throw[Type] TypeError(l,'expecting become to match self type: ' + ppType(bType,typeEnv) + ' ' + ppType(selfType,typeEnv));

probablyType(l::Loc,p::AST,t::Type,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let pt::Type = expType(p,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(pt)
     then
       let t::Type = substTypeEnv(typeEnv,t);
           t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
           t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(t,t1) and typeEqual(t,t2)
          then t;
          else throw[Type] TypeError(l,'expecting probably arm types to agree: ' + ppType(t1,typeEnv) + ' ' + ppType(t,typeEnv) + ' ' + ppType(t2,typeEnv));
     else throw[Type] TypeError(l,'expecting an integer: ' + ppType(pt,typeEnv));

newType(l::Loc,b::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  expType(Apply(l,b,args),selfType,valueEnv,cnstrEnv,typeEnv);

sendType(l::Loc,target::AST,n::Str,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case typeNF(derefType(expType(target,selfType,valueEnv,cnstrEnv,typeEnv)),typeEnv) {
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      letrec
        findHandler(handlers::[MType])::MType = 
          case handlers {
            [][MType] -> throw[MType] TypeError(l,'cannot find message handler named ' + n);
            MessageType(ml::Loc,[TermType(tl::Loc,m::Str,ts::[Type])]):rest::[MType] when m = n -> head[MType](handlers);
            m::MType:handlers::[MType] -> findHandler(handlers);
          }
      in case findHandler(handlers) {
        MessageType(ml::Loc,[TermType(tl::Loc,n::Str,ts1::[Type])]) ->
          let ts2::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
          in if length[Type](ts1) = length[Type](ts2)
             then 
               if subTypes(ts2,ts1)
               then {
                expType(target,selfType,valueEnv,cnstrEnv,typeEnv);
                VoidType(l);
               }
               else throw[Type] TypeError(l,'message argument types ' + ppTypes(ts2,typeEnv) + ' do not match expected types ' + ppTypes(ts1,typeEnv));
             else throw[Type] TypeError(l,'expecting ' + length[Type](ts1) + ' args, but received ' + length[Type](ts2));
        m::MType -> throw[Type] TypeError(l,'cannot find message handler named ' + n + ' in ' + handlers);
      }
    t -> throw[Type] TypeError(l, 'expecting a behaviour type: ' + typeNF(derefType(expType(target,selfType,valueEnv,cnstrEnv,typeEnv)),typeEnv));
  }

actType(l::Loc,n::AST,args::[TDec],parent::AST,exports::[Str],bindings::[TBind],init::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 

  // Create a behaviour type based on the exported bindings and the message types in the type body.
  // The values of the bindings, the initialiser and the bodies of the message handlers must be 
  // checked and must be supplied with the behaviour type as the self type.
  
  letrec
    findLoc(n::Str,bindings::[TBind])::Loc =
      case bindings {
        [][TBind] -> p0;
        Binding(l::Loc,m::Str,t::Type,st::Type,e::AST):bindings::[TBind] when m=n -> l;
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,st::Type,g::AST,e::AST):bindings::[TBind] when m=n -> l;
        b::TBind:bindings::[TBind] -> findLoc(n,bindings);
      }
    findType(n::Str,bindings::[TBind])::Type =
      case bindings {
        [][TBind] -> null[Type];
        Binding(l::Loc,m::Str,t::Type,st::Type,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,st::Type,g::AST,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        b::TBind:bindings::[TBind] -> findType(n,bindings);
      }
    decs(exports::[Str])::[TDec] =
      case exports {
        [][Str] -> [][TDec];
        m::Str:exports::[Str] -> 
          let t::Type = findType(m,bindings);
              l::Loc = findLoc(m,bindings);
          in if t = null[Type]
             then throw[[TDec]] TypeError(l,'cannot find exported name ' + m);
             else Dec(l,m,t,t):decs(exports);
      }
    getMessageTypes(arms::[Arm])::[MType] =
      case arms {
        [][Arm] -> [][MType];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> getMessageType(ps):getMessageTypes(arms);
      }
    getMessageType(ps::[Pattern])::MType =
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in MessageType(pl,[TermType(pl,termName,ts)]);
      }
    typeCheckArms(arms::[Arm],selfType::Type,valueEnv::TEnv)::Void =
      case arms {
        [][Arm] -> null[Void];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> {
          typeCheckArm(l,ps,g,e,selfType,valueEnv);
          typeCheckArms(arms,selfType,valueEnv);
        }
      }
    typeCheckArm(l::Loc,ps::[Pattern],g::AST,e::AST,selfType::Type,valueEnv::TEnv)::Void = 
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in {
            patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(ts::[Type],valueEnv::TEnv)::Type {
              expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
            });
            null[Void];
          }
      }
  in let parentType::Type = if parent = null[AST] then actType0; else expType(parent,selfType,valueEnv,cnstrEnv,typeEnv);
         localEnv::TEnv = parBind(bindings,selfType,valueEnv,cnstrEnv,typeEnv); in
     let exportedDecs::[TDec] = decs(exports); in
     let messageTypes::[MType] = getMessageTypes(arms); in
     let selfType::Type = ExtendedAct(l,parentType,exportedDecs,messageTypes);
         superEnv::TEnv = [Map('$super',parentType)];
     in { 
      typeCheckExports(l,exportedDecs,bindings,selfType,localEnv + valueEnv,typeEnv,cnstrEnv);
      typeCheckValues(valueDefs(bindings),selfType,superEnv + localEnv + valueEnv,typeEnv,cnstrEnv);
      expType(init,selfType,superEnv + localEnv + valueEnv,cnstrEnv,typeEnv);
      typeCheckArms(arms,selfType,superEnv + localEnv + valueEnv);
      selfType;
     }

typeCheckExports(l::Loc,exports::[TDec],defs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void = {
  
  // Check that the behaviour definitions meet the exports in the behaviour type.
  // Inheriting client names start with a $ which must be removed.
  
  for e::TDec in exports do {
    if exists[TBind](fun(b::TBind)::Bool (bindingName(b) = decName(e)) and typeEqual(lookupType(decName(e),valueEnv),decType(e)),defs)
    then {}
    else throw[Void] TypeError(l,' cannot find export for ' + decName(e));
  }
}

bTypeExports(t::Type)::[TDec] =
  case t {
    ExtendedAct(l::Loc,parent::Type,exports::[TDec],message::[MType]) -> bTypeExports(parent) + exports;
    ActType(l::Loc,exports::[TDec],message::[MType])                  -> exports; 
    TypeClosure(f::()->Type)                                          -> bTypeExports(f());
    RecType(l::Loc,n::Str,t::Type)                                    -> bTypeExports(substType(RecType(l,n,t),n,t));
  }

cmpType(l::Loc,e::AST,qs::[Qualifier],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case qs {
    [][Qualifier] -> 
      let t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv); 
      in ListType(l,t);
    BQual(l::Loc,p::Pattern,list::AST):qs::[Qualifier] -> 
      let lType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
      in case lType {
        ListType(ll::Loc,t::Type) ->
          let qs::[Qualifier] = qs; in // Closure bug...
          patternType(l,p,substTypeEnv(typeEnv,t),selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type
            cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv));
        t::Type -> throw[Type] TypeError(l,'qualifier binding expects a list: ' + ppType(t,typeEnv));
      }
    PQual(l::Loc,b::AST):qs::[Qualifier] ->
      let bType::Type = expType(b,selfType,valueEnv,cnstrEnv,typeEnv);
      in if isBoolType(bType)
         then cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Type] TypeError(l,'qualifier expects a boolean type: ' + ppType(bType,typeEnv));
  }

updateType(l::Loc,n::Str,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else 
       let valueType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(valueType,t)
          then valueType;
          else throw[Type] TypeError(l,'type of variable ' + n + '::' + ppType(t,typeEnv) + ' does not agree with value type ' + ppType(valueType,typeEnv));

letType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = parBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in {
    for b::TBind in bs do typeCheckDef(b,selfType,valueEnv,env+valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }
  
letrecType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = recBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in { 
    for b::TBind in bs do typeCheckDef(b,selfType,env + valueEnv,env + valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }
    
checkDupBindings(bs::[TBind])::Void = 
  case bs {
    [] -> null[Void];
    b::TBind:bs::[TBind] -> 
      if member[Str](bindingName(b),[ bindingName(b) | b::TBind <- bs ])
      then throw[Void] TypeError(bindingLoc(b),'duplicate definitions for ' + bindingName(b));
      else checkDupBindings(bs);
  }

parBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv = {
  checkDupBindings(bs);
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);
}

recBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv =
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);

caseType(l::Loc,es::[AST],arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts1::[Type] = expTypes(es,selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'case arm types do not agree: ' + ppTypes(ts1,typeEnv) + ' ' + ppTypes(ts2,typeEnv));

tryType(l::Loc,e::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let ts1::[Type] = expTypes([e],selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'try arm types do not agree: ' + ppTypes(ts1,typeEnv) + ' ' + ppTypes(ts2,typeEnv));
}

armTypes(arms::[Arm],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] = 
  case arms {
    [][Arm] -> [][Type];
    a::Arm:arms::[Arm] -> armType(a,ts,selfType,valueEnv,cnstrEnv,typeEnv):armTypes(arms,ts,selfType,valueEnv,cnstrEnv,typeEnv);
  }

armType(arm::Arm,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case arm {
    BArm(l::Loc,ps::[Pattern],guard::AST,exp::AST) -> {
      checkPatterns(l,ps);
      if length[Pattern](ps) = length[Type](ts)
      then patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(types::[Type],valueEnv::TEnv)::Type guardedExpType(l,guard,exp,selfType,valueEnv,cnstrEnv,typeEnv));
      else throw[Type] TypeError(l,'number of patterns ' + length[Pattern](ps) + ' does not match supplied values: ' + length[Type](ts));
    }
  }
}
  
refType(l::Loc,e::AST,n::Str,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    t::Type = derefType(expType(e,selfType,valueEnv,cnstrEnv,typeEnv));
    findExport(decs::[TDec])::Type = 
      case decs {
        [][TDec] -> null[Type];
        Dec(l::Loc,m::Str,t::Type,st::Type):decs::[TDec] when m=n -> t;
        d::TDec:decs::[TDec] -> findExport(decs);
      }
    findField(fs::[TDec])::Type =
      case fs {
        [][TDec] -> throw[Type] TypeError(l,'cannot find field name ' + n);
        Dec(l::Loc,m::Str,t::Type,ds::Type):fs::[Type] when m=n -> t;
        t::TDec:fs::[TDec] -> findField(fs);
      }
  in case typeNF(t,typeEnv) {
    StrType(sl::Loc) when n = 'explode' -> ListType(sl,IntType(sl));
    StrType(sl::Loc) when n = 'writeDate' -> FloatType(sl);
    TableType(l::Loc,k::Type,v::Type) when n = 'get' -> FunType(l,[k],v);
    TableType(l::Loc,k::Type,v::Type) when n = 'put' -> FunType(l,[k,v],t);
    TableType(l::Loc,k::Type,v::Type) when n = 'keys' -> ListType(l,k);
    TableType(l::Loc,k::Type,v::Type) when n = 'vals' -> ListType(l,v);
    TableType(l::Loc,k::Type,v::Type) when n = 'hasKey' -> FunType(l,[k],BoolType(l));
    ListType(ll::Loc,t::Type) when n = 'implode' -> StrType(ll);
    RecordType(rl::Loc,fs::[TDec]) -> findField(fs);
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      let t::Type = findExport(exports);
      in if t = null[Type]
         then throw[Type] TypeError(l,'behaviour type does not export ' + n);
         else substTypeEnv(typeEnv,t);
    t::Type -> throw[Type] TypeError(l,'expecting a record type, but received ' + ppType(t,typeEnv));
  }

derefType(t::Type)::Type =
  case t {
    TypeClosure(f::()->Type) -> derefType(f());
    t::Type -> t;
  }

recordType(l::Loc,fields::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    fieldTypes(fields::[TBind])::[TDec] =
      case fields {
        [][TBind] -> [][TDec];
        Binding(l::Loc,n::Str,t::Type,st::Type,e::AST):fields::[TBind] ->
          let t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
          in Dec(l,n,t,t):fieldTypes(fields);
        fields::[TBind] -> throw[[TDec]] TypeError(l,'unknown field representation: ' + fields);
      }
  in RecordType(l,fieldTypes(fields));
  

forType(l::Loc,p::Pattern,list::AST,body::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let listType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
  in case listType {
    ListType(l::Loc,t::Type) ->
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type 
        expType(body,selfType,valueEnv,cnstrEnv,typeEnv));
    t::Type -> throw[Type] TypeError(l,'for type expects a list: ' + list);
  }

patternTypes(l::Loc,ps::[Pattern],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::([Type],TEnv)->Type)::Type = {
  //print[Str]('patternTypes ' + ppPatterns(ps) + ' ' + ppTypes(ts));
  case ps,ts {
    [][Pattern],[][Type] -> f([][Type],valueEnv);
    p::Pattern:ps::[Pattern],t::Type:ts::[Type] -> 
      let ps::[Pattern] = ps; ts::[Type] = ts; in // Closure Bug!!!!!
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type 
        patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(tailTypes::[Type],valueEnv::TEnv)::Type 
          f(headType:tailTypes,valueEnv)));
    ps::[Pattern],ts::[Type] -> throw[Type] TypeError(l, 'somthing wrong with ' + ps + ' ' + ts);
  }}

getPatternType(l::Loc,p::Pattern,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case p {
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> throw[Type] 'should this happen?';
    PBool(l::Loc,b::Bool) -> BoolType(l);
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PBagCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PSetCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PNil(l::Loc) -> ForallType(l,['T'],ListType(l,VarType(l,'T')));
    PNull(l::Loc) -> ForallType(l,['T'],VarType(l,'T')); 
    PEmptyBag(l::Loc) -> ForallType(l,['T'],BagType(l,VarType(l,'T')));
    PEmptySet(l::Loc) -> ForallType(l,['T'],SetType(l,VarType(l,'T')));
    PInt(l::Loc,n::Int) -> IntType(l);
    PVar(l::Loc,n::Str,pt::Type) -> substTypeEnv(typeEnv,pt);
    PStr(l::Loc,s::Str) -> StrType(l);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> lookupType(n,cnstrEnv);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

patternType(l::Loc,p::Pattern,t::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('patternType ' + ppPattern(p) + ' ' + ppType(t));
  case p {
    PAdd(l::Loc,p1::Pattern,p2::Pattern) -> addPatternType(l,p1,p2,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> applyTypePatternType(l,p,substTypesEnv(typeEnv,args),t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PBool(l::Loc,b::Bool) -> if isBoolType(t) then f(BoolType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Bool and ' + ppType(t,typeEnv));
    PBagCons(l::Loc,hd::Pattern,tl::Pattern) -> bagConsPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PSetCons(l::Loc,hd::Pattern,tl::Pattern) -> setConsPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> consPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PNil(l::Loc) -> nilType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PNull(l::Loc) -> f(t,valueEnv);
    PEmptyBag(l::Loc) -> emptyBagType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PEmptySet(l::Loc) -> emptySetType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PInt(l::Loc,n::Int) -> if isIntType(t) then f(IntType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Int and ' + ppType(t,typeEnv));
    PVar(l::Loc,n::Str,pt::Type) -> f(t,[Map(n,t)]+valueEnv);
    PStr(l::Loc,s::Str) -> if isStrType(t) then f(StrType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Str and ' + ppType(t,typeEnv));
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> termPatternType(l,n,substTypesEnv(typeEnv,ts),ps,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

addPatternType(l::Loc,p1::Pattern,p2::Pattern,valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  patternType(l,p1,valueType,selfType,valueEnv,cnstrEnv,typeEnv,fun(leftType::Type,valueEnv::TEnv)::Type 
     patternType(l,p2,valueType,selfType,valueEnv,cnstrEnv,typeEnv,fun(rightType::Type,valueEnv::TEnv)::Type 
       case valueType {
         ListType(tl::Loc,t::Type) -> 
           case p1,p2 {
            PCons(l1,p,PNil(l3)),PVar(l4,n2,t2) -> f(valueType,valueEnv);
            PVar(l1,n,t),PCons(l2,p,PNil(l3)) -> f(valueType,valueEnv);
            PAdd(l1,PVar(l2,n1,t1),PCons(l3,p,PNil(l5))),PVar(l6,n3,t3) -> f(valueType,valueEnv);
            PVar(l1,n1,t1),PAdd(l2,PCons(l3,p,PNil(l5)),PVar(l6,n3,t3)) -> f(valueType,valueEnv);
            p1,p2 -> throw[Type] TypeError(l,'patterns must be [p] + p, p + [p] + p, or p + [p]');
           }
         TypeClosure(g) -> addPatternType(l,p1,p2,g(),selfType,valueEnv,cnstrEnv,typeEnv,f);
         t -> throw[Type] TypeError(l,'+ expects lists: ' + ppType(valueType,typeEnv));
       }));

applyTypePatternType(l::Loc,p::Pattern,args::[Type],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  patternType(l,p,valueType,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type { 
    case typeNF(pType,typeEnv) {
      TypeFun(fl::Loc,ns::[Str],t::Type) ->
        if length[Type](args) = length[Str](ns)
        then 
          let t::Type = substTypeEnv(zipTypeEnv(ns,args)+typeEnv,t);
          in if typeEqual(t,valueType)
             then f(t,valueEnv);
             else throw[Type] TypeError(l,'value type ' + ppType(valueType,typeEnv) + ' does not match pattern type ' + ppType(t,typeEnv) + ' ' + ppTypeEnv(typeEnv));
        else throw[Type] TypeError(l,'expecting ' + length[Str](ns) + ' args, but suplied with ' + length[Type](args));
      ForallType(fl::Loc,ns::[Str],t::Type) ->
        // Not sure this would ever occur. Should always be a type fun?
        if length[Type](args) = length[Str](ns)
        then 
          let t::Type = substTypeEnv(zipTypeEnv(ns,args)+typeEnv,t);
          in if typeEqual(t,valueType)
             then f(t,valueEnv);
             else throw[Type] TypeError(l,'value type ' + ppType(valueType,typeEnv) + ' does not match pattern type ' + ppType(t,typeEnv) + ' ' + ppTypeEnv(typeEnv));
        else throw[Type] TypeError(l,'expecting ' + length[Str](ns) + ' args, but suplied with ' + length[Type](args));
      t::Type -> f(t,valueEnv);
    }});}

termPatternType(l::Loc,n::Str,genericArgs::[Type],ps::[Pattern],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('termPatternType ' + ppType(valueType) + ' ' + ppTypes(genericArgs));
  let patternType::Type = getTermPatternType(l,n,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(patternType,valueType)
     then
       case typeNF(valueType,typeEnv) {
         UnionType(ul::Loc,cs::[Type]) -> 
           letrec
             getCnstrArgs(cs::[Type])::[Type] =
               case cs {
                 [][Type] -> throw[[Type]] TypeError(l,'cannot find constructor for ' + n);
                 TermType(tl::Loc,m::Str,args::[Type]):cs::[Type] when m=n -> args;
                 t::Type:cs::[Type] -> getCnstrArgs(cs);
               }
           in let argTypes::[Type] = getCnstrArgs(cs);
              in if length[Pattern](ps) = length[Type](argTypes)
                 then patternTypes(l,ps,argTypes,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::[Type],valueEnv::TEnv)::Type f(typeNF(valueType,typeEnv),valueEnv));
                 else throw[Type] TypeError(l,'arity mismatch.');
         t::Type -> throw[Type] TypeError(l,'expecting a data type: ' + valueType);
       }
      else throw[Type] TypeError(l,'term pattern type ' + ppType(patternType,typeEnv) + ' does not match supplied value type ' + ppType(valueType,typeEnv));
    }

typeNF(t::Type,typeEnv::TEnv)::Type =
  case substTypeEnv(typeEnv,t) {
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) ->
      case typeNF(op,typeEnv) {
        TypeFun(l::Loc,ns::[Str],t::Type) ->
          if length[Type](args) = length[Str](ns)
          then typeNF(substTypeEnv(zipTypeEnv(ns,args),t),typeEnv);
          else throw[Type] TypeError(l,'function arity error');
        t::Type -> throw[Type] TypeError(l,'expecting a type function: ' + ppType(typeNF(op,typeEnv),typeEnv));
      }
    TypeClosure(f::()->Type) -> typeNF(f(),typeEnv);
    RecType(l::Loc,n::Str,t::Type) -> typeNF(substType(RecType(l,n,t),n,t),typeEnv);
    ExtendedAct(l1::Loc,parent::Type,decs1::[TDec],ms1::[MType]) ->
      case typeNF(parent,typeEnv) {
        ActType(l2::Loc,decs2::[TDec],ms2::[MType]) ->
          ActType(l1,decs2+decs1,ms2+ms1);
      }
    t::Type -> t;
  }

getTermPatternType(l::Loc,n::Str,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let t::Type = lookupType(n,cnstrEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unknown constructor ' + n);
     else
       if length[Type](genericArgs) > 0
       then getGenericTermPatternType(l,t,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
       else t;
}

getGenericTermPatternType(l::Loc,t::Type,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case t {
    RecType(rl::Loc,rn::Str,rt::Type) -> getGenericTermPatternType(l,substType(RecType(rl,rn,rt),rn,rt),genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
    TypeFun(al::Loc,ns::[Str],t::Type) ->
      if length[Str](ns) = length[Type](genericArgs)
      then 
        let e::TEnv = zipTypeEnv(ns,genericArgs);
        in substTypeEnv(e+typeEnv,t);
      else throw[Type] TypeError(l,'generic constructor mismatch');
    t::Type -> throw[Type] TypeError(l,'expecting a generic type: ' + ppType(t,typeEnv));
  }

nilType(l::Loc,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],ListType(l,VarType(l,'T'))),valueEnv);
    TypeClosure(g) -> nilType(l,g(),selfType,valueEnv,cnstrEnv,typeEnv,f);
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType,typeEnv));
  }  

emptyBagType(l::Loc,bagType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case bagType {
    BagType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],BagType(l,VarType(l,'T'))),valueEnv);
    bagType::Type -> throw[Type] TypeError(l,'expecting a bag type: ' + ppType(bagType,typeEnv));
  }    

emptySetType(l::Loc,setType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case setType {
    SetType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],SetType(l,VarType(l,'T'))),valueEnv);
    setType::Type -> throw[Type] TypeError(l,'expecting a set type: ' + ppType(setType,typeEnv));
  }   

consPatternType(l::Loc,h::Pattern,t::Pattern,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,listType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv);
        }));
    TypeClosure(g) -> consPatternType(l,h,t,g(),selfType,valueEnv,cnstrEnv,typeEnv,f);
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType,typeEnv));
  }  

bagConsPatternType(l::Loc,h::Pattern,t::Pattern,bagType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case bagType {
    BagType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,bagType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv); 
        }));
    bagType::Type -> throw[Type] TypeError(l,'expecting a bag type: ' + ppType(bagType,typeEnv));
  } 

setConsPatternType(l::Loc,h::Pattern,t::Pattern,setType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case setType {
    SetType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,setType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv); 
        }));
    setType::Type -> throw[Type] TypeError(l,'expecting a set type: ' + ppType(setType,typeEnv));
  }

binExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case op {
    '+' -> plusExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '-' -> subExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '*' -> mulExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '/' -> divExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    ':' -> consExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '=' -> eqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<>' -> neqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'and' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'andalso' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'or' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'orelse' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>' -> compareExpType(l,e1,'>',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>=' -> compareExpType(l,e1,'>=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<' -> compareExpType(l,e1,'<',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<=' -> compareExpType(l,e1,'<=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '..' -> dotDotExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '%' -> percentExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '@' -> atExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    op::Str -> throw[Type] TypeError(l,'unknown operator: ' + op);
  }

andExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'and expects boolean arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

atExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then t1;
     else throw[Type] TypeError(l,'@ expects arguments to be same type: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

dotDotExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then ListType(l,IntType(l));
     else throw[Type] TypeError(l,'.. expects integer arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

percentExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then IntType(l);
     else throw[Type] TypeError(l,'% expects integer arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

compareExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isNumType(t1) and isNumType(t2)
     then BoolType(l);
     else throw[Type] TypeError(l,op + ' expects numeric arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

orExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'or expects boolean arguments: ' + ppType(t1,typeEnv) + ' ' + ppType(t2,typeEnv));

eqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'= expects types to agree: ' + ppType(t1,typeEnv) + ' <> ' + ppType(t2,typeEnv));

neqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'<> expects types to agree: ' + ppType(t1,typeEnv) + ' <> ' + ppType(t2,typeEnv));

consExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = typeNF(expType(e1,selfType,valueEnv,cnstrEnv,typeEnv),typeEnv);
      t2::Type = typeNF(expType(e2,selfType,valueEnv,cnstrEnv,typeEnv),typeEnv);
  in case t2,t1 {
    ListType(l::Loc,elementType::Type),headType::Type ->
      if subType(headType,elementType)
      then t2;
      else throw[Type] TypeError(l,': expects head type ' + ppType(headType,typeEnv) + ' and element type ' + ppType(elementType,typeEnv) + ' to agree');
  }

divExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for /: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

mulExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    FloatType(l1::Loc),IntType(l2::Loc) -> t1;
    IntType(l1::Loc),FloatType(l2::Loc) -> t2;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for *: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

subExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv); 
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    FloatType(l1::Loc),IntType(l2::Loc) -> t1;
    IntType(l1::Loc),FloatType(l2::Loc) -> t2;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for -: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

plusExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    StrType(l::Loc),t2::Type -> t1;
    t1,StrType(l::Loc) -> t2;
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    ListType(l1::Loc,t1::Type),ListType(l2::Loc,t2::Type) when typeEqual(t1,t2) -> ListType(l1,t1);
    SetType(l1::Loc,t1::Type),SetType(l2::Loc,t2::Type) when typeEqual(t1,t2) -> SetType(l1,t1);
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for +: ' + ppType(t1,typeEnv) + ' and ' + ppType(t2,typeEnv));
  }

applyTypeExp(l::Loc,e::AST,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts::[Type] = substTypesEnv(typeEnv,ts);
      t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t {
       ForallType(l1::Loc,ns::[Str],t::Type) -> 
         if length[Str](ns) = length[Type](ts)
         then  
           let env::TEnv = zipTypeEnv(ns,ts); 
           in substTypeEnv(env + valueEnv,t);
         else throw[Type] TypeError(l,'universal type expects ' + length[Str](ns) + ' types, but supplied with ' + length[Type](ts));
       t::Type -> throw[Type] TypeError(l,'expecting a universal type: ' + t);
     } 

expTypes(es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] =
  map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);

applyType(l::Loc,op::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case typeNF(expType(op,selfType,valueEnv,cnstrEnv,typeEnv),typeEnv) {
    FunType(l1::Loc,domain::[Type],range::Type) -> {
      let supplied::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
      in if length[Type](domain) = length[Type](supplied)
         then { //print[Str](' apply subtypes = ' + subTypes(supplied,domain) + ' for ' + args + ' in ' + op); 
           if subTypes(supplied,domain) //typesEqual(domain,supplied)
           then range;
           else throw[Type] TypeError(l,'supplied argument types ' + ppTypes(supplied,typeEnv) + ' do not match function domain ' + ppTypes(domain,typeEnv));
         }
         else throw[Type] TypeError(l,'expecting ' + length[Type](domain) + ' args, but supplied with ' + length[Type](supplied)); }
    t::Type -> throw[Type] TypeError(l, 'unknown type for apply: ' + ppType(t,typeEnv));
  }}

ifType(l::Loc,e1::AST,e2::AST,e3::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let testType::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(testType)
     then
       let conseqType::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
           altType::Type = expType(e3,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(conseqType,altType)
          then conseqType;
          else throw[Type] TypeError(l,'conseq and alt types do not agree: ' + ppType(conseqType,typeEnv) + ' ' + ppType(altType,typeEnv));
     else throw[Type]('if expects a bool ' + ppType(testType,typeEnv));

checkDecs(ds::[TDec])::Void =
  case ds {
    [] -> null[Void];
    d::TDec:ds::[TDec] -> 
      if member[Str](decName(d),[ decName(d) | d::TDec <- ds ])
      then throw[Void] TypeError(decLoc(d),' duplicate argument ' + decName(d));
      else checkDecs(ds);
  }

funType(l::Loc,n::AST,args::[TDec],t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  checkDecs(args);
  let nType::Type = expType(n,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isStrType(nType)
     then 
       let declaredType::Type = substTypeEnv(typeEnv,t);
       in decTypes(args,valueEnv,typeEnv,fun(domain::[Type],valueEnv::TEnv)::Type {
            let actualRange::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
            in { 
              //print[Str]('fun type ' + subType(FunType(l,domain,actualRange),declaredType));
              if subType(FunType(l,domain,actualRange),declaredType) //typeEqual(declaredType,FunType(l,domain,actualRange))
               then FunType(l,domain,actualRange);
               else throw[Type] TypeError(l,'function declared type ' + ppType(declaredType,typeEnv) + ' but is ' + ppType(FunType(l,domain,actualRange),typeEnv));
            }
          });
     else throw[Type] TypeError(l,'expecting a string for a function name: ' + n);
}

decTypes(decs::[TDec],valueEnv::TEnv,typeEnv::TEnv,consumer::([Type],TEnv)->Type)::Type =
  letrec
    processDecs(decs::[TDec],bindings::TEnv)::Type =
      case decs {
        [][TDec] -> consumer(reverse[Type](typeEnvRan(bindings)),bindings + valueEnv);
        Dec(l::Loc,n::Str,t::Type,st::Type):decs::[TDec] -> processDecs(decs,Map(n,substTypeEnv(typeEnv,t)):bindings);
      }
  in processDecs(decs,[][TMap]);

termType(l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let t0::Type = lookupType(n,cnstrEnv);
  in if t0 = null[Type]
     then throw[Type] TypeError(l,'cannot find cnstr ' + n);
     else 
       let t::Type = unfoldIf(t0);
       in termTypeCheckUnion(t,l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
}   
  
termTypeCheckUnion(t::Type,l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if t = null[Type]
     then throw[Type] TypeError(l,'cannot find constructor ' + n);
     else
       case t {
        TypeFun(lf::Loc,ns::[Str],body::Type) ->
          if length[Str](ns) = length[Type](ts)
          then 
            let args::[Type] = map[Type,Type](fun(t::Type)::Type substTypeEnv(typeEnv,t),ts); 
            in case substTypeEnv(zipTypeEnv(ns,args),body) {
                 UnionType(l1::Loc,terms::[Type]) ->
                   let ts2::[Type] = findTermArgTypes(n,terms);
                   in if length[AST](es) = length[Type](ts2)
                      then {
                        checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
                        UnionType(l1,terms);
                      }
                      else throw[Type] TypeError(l,n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
               }
          else throw[Type] TypeError(l,'generic constructor ' + n + ' expects ' + length[Str](ns) + ' type arguments, but received ' + length[Type](ts));
        UnionType(l1::Loc,terms::[Type]) ->
          let ts2::[Type] = findTermArgTypes(n,terms);
          in if length[Type](ts) <> 0
             then throw[Type] TypeError(l,'generic application of non-generic constructior: ' + n);
             else if length[AST](es) = length[Type](ts2)
             then {
              checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
              t;
             }
             else throw[Type] TypeError(l,n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
        t::Type -> throw[Type] TypeError(l,'expecting a union type for ' + n + ' but got ' + ppType(t,typeEnv));
       }

unfoldIf(t::Type)::Type =
  case t {
    RecType(l::Loc,n::Str,t::Type) -> unfoldIf(unfoldType(l,n,t));
    t::Type -> t; 
  }

findTermArgTypes(n::Str,terms::[Type])::[Type] =
  case terms {
    TermType(l::Loc,nn::Str,ts::[Type]):terms::[Type] when nn=n -> ts;
    [][Type] -> throw[[Type]]('cannot find constructor ' + n);
    t::Type:ts::[Type] -> findTermArgTypes(n,ts);
  }

checkTermArgTypes(l::Loc,es::[AST],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =
  case es,ts {
    (e::AST):es::[AST],t::Type:ts::[Type] ->
      let tt::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
      in {
        if typeEqual(t,tt)
         then checkTermArgTypes(l,es,ts,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Void] TypeError(l,'expected constructor arg type ' + ppType(t,typeEnv) + ' but supplied ' + ppType(tt,typeEnv));
      }
     [][AST],[][Type] -> null[Void];
  }
  

notType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  case expType(e,selfType,valueEnv,cnstrEnv,typeEnv) {
    BoolType(l::Loc) -> BoolType(l);
    t::Type -> throw[Type] TypeError(l,'expecting a boolean: ' + ppType(t,typeEnv));
  }
  
varType(l::Loc,n::Str,valueEnv::TEnv)::Type =
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else case t {
       TypeClosure(f::()->Type) -> f();
       t::Type -> t;
     }

blockType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t::Type = VoidType(l);
  in {
    for e::AST in es do
      t := expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    t;
  }     

listType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if es = [][AST]
  then ForallType(l,['T'],ListType(l,VarType(l,'T')));
  else
    let ts::[Type] = map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);
    in if allEqualTypes(head[Type](ts),tail[Type](ts))
       then ListType(l,head[Type](ts));
       else throw[Type] TypeError(l,'lists should have elements of the same type: ' + es);   

setType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if es = [][AST]
  then ForallType(l,['T'],SetType(l,VarType(l,'T')));
  else
    let ts::[Type] = map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);
    in if allEqualTypes(head[Type](ts),tail[Type](ts))
       then SetType(l,head[Type](ts));
       else throw[Type] TypeError(l,'sets should have elements of the same type: ' + es);   

bagType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if es = [][AST]
  then ForallType(l,['T'],BagType(l,VarType(l,'T')));
  else
    let ts::[Type] = map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);
    in if allEqualTypes(head[Type](ts),tail[Type](ts))
       then BagType(l,head[Type](ts));
       else throw[Type] TypeError(l,'bags should have elements of the same type: ' + es); 
    
recTypes(env::TEnv)::TEnv =
  letrec

    fixEnv(env::TEnv)::TEnv =
      let e::TEnv = null[TEnv];
      in let fenv::TEnv = [ Map(n,TypeClosure(fun['lookup: ' + n]()::Type lookupType(n,e))) | t::Type <- typeEnvRan(env), n::Str <- typeFV(t) ];
         in let env1::TEnv = substOnce(env,fenv);
            in { e := env1; env1; }
   
    introduceRecTypes(env::TEnv)::TEnv = {
      case env {
        [][TMap] -> env;
        Map(n::Str,RecordType(l,fs)):e -> Map(n,RecordType(l,fs)):introduceRecTypes(e);
        Map(n::Str,t::Type):e::TEnv ->
          if member[Str](n,typeFV(t))
          then Map(n,RecType(p0,n,t)):introduceRecTypes(e);
          else Map(n,t):introduceRecTypes(e);
      }
    }
      
    substOnce(env::TEnv,fenv::TEnv)::TEnv = 
      let 
        map1(m::TMap)::TMap =
          case m {
            Map(n::Str,t::Type) -> Map(n,substTypeEnv([ Map(n,lookupType(n,fenv)) | n::Str <- typeFV(t) ],t));
          }
      in map[TMap,TMap](map1,env);
  in fixEnv(introduceRecTypes(env));
         
    
typeFV(t::Type)::[Str] = (removeDups[Str](varTypeNames(typeFV1(t,[][Type])))); 

varTypeNames(vs::[Type])::[Str] = map[Type,Str](varTypeName,vs);
  
varTypeName(t::Type)::Str =
  case t {
    VarType(l::Loc,n::Str) -> n;
    x::Type -> '<var>';
  }
  
tdecsFV1(decs::[TDec],fv::[Type])::[Type] =
  case decs {
    [][TDec] -> fv;
    d::TDec:ds::[TDec] -> tdecFV1(d,tdecsFV1(ds,fv));
  }
  
tdecFV1(d::TDec,fv::[Type])::[Type] =
  case d { 
    Dec(l::Loc,n::Str,t::Type,st::Type) -> 
      typeFV1(t,fv); 
  }
  
handlersFV1(handlers::[MType],fv::[Type])::[Type] =
  case handlers {
    [][MType] -> fv;
    m::MType:hs::[MType] -> handlerFV1(m,handlersFV1(hs,fv));
  }
  
handlerFV1(m::MType,fv::[Type])::[Type] =
  case m { 
    MessageType(l::Loc,ts::[Type]) -> 
      typesFV1(ts,fv); 
  }
  
typesFV1(ts::[Type],fv::[Type])::[Type] = 
  case ts {
    [][Type] -> fv;
    t::Type:ts::[Type] -> typeFV1(t,typesFV1(ts,fv));
  }
    
typeFV1(t::Type,fv::[Type])::[Type] = { //print[Str]('FV ' + t);
 
  // Return a list of VarTypes that are not bound. The VarType contains the 
  // position if we need to raise a positional error...
  
  case t {
    ArrayType(l::Loc,t::Type) -> typeFV1(t,fv);
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> tdecsFV1(decs,handlersFV1(handlers,fv));
    ExtendedAct(l::Loc,parent::Type,decs::[TDec],handlers::[MType]) -> tdecsFV1(decs,handlersFV1(handlers,typeFV1(parent,fv)));
    ApplyType(l::Loc,n::Str,types::[Type]) -> typesFV1(types,VarType(l,n):fv);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> typesFV1(args,typeFV1(op,fv));
    BoolType(l::Loc) -> fv;
    FieldType(l::Loc,n::Str,t::Type) -> typeFV1(t,fv);
    FloatType(l::Loc) -> fv;
    ForallType(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    FunType(l::Loc,d::[Type],r::Type) -> typesFV1(d,typeFV1(r,fv));
    IntType(l::Loc) -> fv;
    ListType(l::Loc,t::Type) -> typeFV1(t,fv);
    BagType(l::Loc,t::Type) -> typeFV1(t,fv);
    SetType(l::Loc,t::Type) -> typeFV1(t,fv);
    NullType(l::Loc) -> fv; 
    RecordType(l::Loc,fs::[TDec]) -> typesFV1([ t | Dec(l,n,t,dt) <- fs ],fv); 
    RecType(l::Loc,a::Str,t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(n = a); },typeFV1(t,[][Type])) + fv;
    StrType(l::Loc) -> fv;
    TableType(l::Loc,k::Type,v::Type) -> typeFV1(k,typeFV1(v,fv));
    TypeClosure(f::()->Type) -> [][Type];
    TermType(l::Loc,n::Str,ts::[Type]) -> typesFV1(ts,fv);
    TypeFun(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    UnfoldType(l::Loc,t::Type) -> typeFV1(t,fv);
    UnionType(l::Loc,ts::[Type]) -> typesFV1(ts,fv);
    VarType(l::Loc,n::Str) -> t:fv;
    VoidType(l::Loc) -> fv;
    UnionRef(l::Loc,t::Type,n::Str) ->typeFV1(t,fv);
    x::Type -> throw[[Type]]x; 
  }
}

act main::Main {
  -> {
   try {
    typeCheckModule('esl/compiler/test1.esl'); 
   }
   catch {
      message::Str ->  print[Str]('Type Error: ' + message); 
    }
  print[Str]('DONE');
  stopAll();
  }
}