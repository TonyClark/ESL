export main;

import 'esl/lists.esl';

type Main = Act { Time(Int) };

type Chopstick = Act { export id::Int;active::Bool; Time(Int) };

type Philosopher = Act { export eating::Bool; Time(Int) };

eats::Int = 0;

act chopstick(i::Int)::Chopstick {
  export id,active;
  id::Int = i;
  active::Bool = false
  Time(n::Int) -> {}
};

act philosopher(i::Int,left::Chopstick,right::Chopstick)::Philosopher {
  export eating;
  eating::Bool = false
  Time(n::Int) -> {
    grab(left.active,right.active) {
      print[Str](self + ' eats using ' + left.id + ' and ' + right.id);
      eats := eats + 1;
      eating := true;
      for x::Int in 0..random(100) do {};
      eating := false;
      print[Str](self + ' releases ' + left.id + ' and ' + right.id)
    }  
  }
};

act philosopher2(i::Int,left::Chopstick,right::Chopstick)::Philosopher {

  // This version of a philosopher may lead to deadlock because each of the chopsticks are
  // grabbed independently (and there is a delay in between)...
  
  export eating;
  eating::Bool = false
  Time(n::Int) -> {
    grab(left.active) {
      for x::Int in 0..random(100) do {};
      grab(right.active) {
        print[Str](self + ' eats using ' + left.id + ' and ' + right.id);
        eats := eats + 1;
        eating := true;
        for x::Int in 0..random(100) do {};
        eating := false
      }    
    }
  }
};

max::Int = 3;

chopsticks::[Chopstick] = [ new chopstick(i) | i::Int <- 0..(max) ];

// The first version should be OK...

philosophers::[Philosopher] = [ new philosopher1(i,nth[Chopstick](chopsticks,i),nth[Chopstick](chopsticks,(i+1)%max)) | i::Int <- 0..max ];

// Comment out the above and uncomment the below to get a deadlock version...

// philosophers::[Philosopher] = [ new philosopher2(i,nth[Chopstick](chopsticks,i),nth[Chopstick](chopsticks,(i+1)%max)) | i::Int <- 0..max ];

act main::Main {

  Time(100) -> { print[Str]('Total eating = ' + eats); stopAll() };
  Time(n::Int) -> {}

}



















