export main;

import 'esl/lists','esl/noticeboard';

opp(Red) = Green;
opp(Green) = Red;

act customer(pcred,frequency,availability) {

  // A customer produces opportunities at a given frequency.
  // Each opportunity is either Red or Green and there is
  // a pcred %-age chance of it being Red. The opportunity
  // is available for a given number of time clicks.
   
  export history,numberOf;
  
  next = 0;                                                     // Controls the frequency.
  history = [];                                                 // A list of opportunity colours.
  numberOf(c) = count(c,history);                               // Calculate the number of a colour
  offer() = nb <- Add(new opportunity(self,Red,availability))   when random(100) < pcred;
  offer() = nb <- Add(new opportunity(self,Green,availability))
  
  Time(_) ? next=frequency -> { next := 0; offer() };           // If frequency reached then offer.
  Time(_) -> next := next + 1;                                  // Move towards next offering.
  Done(colour) -> history := colour:history                     // Record a completed opportunity.
};

act opportunity(customer,colour,availability) {

  // An opportunity keeps track of the bids by vendors and
  // will inform the winning vendor. For a vendor to win 
  // they must bid the same colour as the opportunity. If
  // multiple vendors bid the same colour then one is chosen
  // at random.
  
  tryAward(Bid(_,v),true)  = { v <- Failed; true };
  tryAward(Bid(c,v),false) = { v <- Award;  true } when c = colour;
  tryAward(Bid(_,v),false) = { v <- Failed; false };
  bids = []                                                     // Record the bids.
  b=Bid(colour,vendor) -> bids := b:bids;                       // Add a new bid.
  Time(_) ? (availability = 0) and (bids <> []) -> {            // Check whether to award opportunity.
    let won = false in for b in shuffle(bids) do won := tryAward(b,won);                                   
    bids := [];                                                 // Once awarded, reset.
    nb <- Remove(self);                                         // Remove from notice-board.
    customer <- Done(colour)                                    // Inform the customer.
  };
  Time(_) ? (availability = 0) -> {                             // No bids made.
    nb <- Remove(self);                                         // Reset everything.
    customer <- Done(colour);
    availability := availability - 1                            // Causes opportunity to become inactive.
  };
  Time(_) -> availability := availability - 1                   // Causes opportunity to become inactive.
};

nb = new noticeboard;                                          // A global notice-board.

act vendorGoal(colour,vendor,customer) {

  // A vendor goal monitors a vendor. We have just one customer
  // so the goal can access the history of the customer in case
  // it is useful. The goal also encodes the adaptor for its
  // vendor: if the goal is not satisfied then the adaptor changes
  // the behaviour by sending the vendor a message.
  
  checkChange() = { 
    colour := opp(colour); 
    vendor <- Change(colour) 
  } when customer.numberOf(opp(colour)) > customer.numberOf(colour)
  
  Time(_) -> 
    case vendor.history {
      Fail:Fail:Fail:_ ->  checkChange();
      _ -> {}
    }
};

act vendor(colour) {
  
  // A vendor has a colour that controls the bids for
  // opportunities. When an opportunity is available via the
  // notice-board, the vendor will have to guess what the
  // colour of the opportunity is.
  
  export history;                                                 
  history = [];
  bidding = false;
  record(x) = history := x:history;
  bid(o:_) = { o <- Bid(colour,self); bidding := true }
  Time(_) ? (nb.data <> []) and (bidding = false) -> bid(nb.data);
  Award -> { 
    record(Succ);
    bidding := false
  };
  Failed -> { 
    record(Fail);
    bidding := false
  };
  Change(c ? c <> colour) -> { 
    colour := c; 
    record(Changed) 
  };
  Change(_) -> {};
  Time(_) -> {}
};

act simulation(duration) {
  c = new customer(5,4,4);
  v1 = new vendor(Red);
  v2 = new vendor(Green);
  v3 = new vendor(Red);
  vs = [v1,v2,v3];
  gs = [new vendorGoal(Red,v1,c),new vendorGoal(Green,v2,c),new vendorGoal(Red,v3,c)]
  -> print('Start Simulation');
  Time(t ? t = duration) -> {
    stopAll();
    for v in vs do {
      print('Vendor: ' + v + ' success=' + count(Succ,v.history) + ' fail=' + count(Fail,v.history));
      print(v.history)
    };
    print(c.history)
  };
  Time(_) -> {}
};

act main {
  -> new simulation(900);
  Time(_) -> {}
}
  