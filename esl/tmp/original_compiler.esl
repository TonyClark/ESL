export main;

import 'new_esl/tmp/lists.esl';

type Main = Act { Time(Int); }

data Loc = Pos(Int,Int);
data TDec = Dec(Loc,Str,Type);
data DRef = VarDyamicRef(Loc,Str);

data TMap = Map(Str,Type);
type TEnv = [TMap];
data MType = MessageType(Loc,[Type]);  

data Error =
  TypeError(Loc,Str);
 
type Type  = rec T. union { 
  ApplyType(Loc,Str,[T]),
  ApplyTypeFun(Loc,T,[T]),
  StrType(Loc),
  IntType(Loc),
  FloatType(Loc),
  BoolType(Loc),
  NullType(Loc),
  ActType(Loc,[TDec],[MType]),
  UnionType(Loc,[T]),
  TermType(Loc,Str,[T]),
  VarType(Loc,Str),
  RecType(Loc,Str,T),
  RecordType(Loc,[T]),
  FieldType(Loc,Str,T),
  ListType(Loc,T),
  UnionRef(Loc,T,Str),
  UnfoldType(Loc,T),
  FunType(Loc,[T],T),
  VoidType(Loc),
  ForallType(Loc,[Str],T),
  TypeFun(Loc,[Str],T),
  TypeClosure(() -> T)
}

cnstr ApplyType = unfold[Type].ApplyType;
cnstr ApplyTypeFun = unfold[Type].ApplyTypeFun;
cnstr StrType = unfold[Type].StrType;
cnstr IntType = unfold[Type].IntType;
cnstr FieldType = unfold[Type].FieldType;
cnstr FloatType = unfold[Type].FloatType;
cnstr BoolType = unfold[Type].BoolType;
cnstr NullType = unfold[Type].NullType;
cnstr VoidType = unfold[Type].VoidType;
cnstr ActType = unfold[Type].ActType;
cnstr UnionType = unfold[Type].UnionType;
cnstr TermType = unfold[Type].TermType;
cnstr VarType = unfold[Type].VarType;
cnstr RecType = unfold[Type].RecType;
cnstr RecordType = unfold[Type].RecordType;
cnstr ListType = unfold[Type].ListType;
cnstr UnfoldType = unfold[Type].UnfoldType;
cnstr UnionRef = unfold[Type].UnionRef;
cnstr FunType = unfold[Type].FunType;
cnstr TypeFun = unfold[Type].TypeFun;
cnstr ForallType = unfold[Type].ForallType;
cnstr TypeClosure = unfold[Type].TypeClosure;

type Pattern = rec P. union {
  PVar(Loc,Str,Type),
  PTerm(Loc,Str,[Type],[P]),
  PApplyType(Loc,P,[Type]),
  PNil(Loc),
  PInt(Loc,Int),
  PStr(Loc,Str),
  PBool(Loc,Bool),
  PCons(Loc,P,P)
}

cnstr PVar = unfold[Pattern].PVar;
cnstr PTerm = unfold[Pattern].PTerm;
cnstr PApplyType = unfold[Pattern].PApplyType;
cnstr PNil = unfold[Pattern].PNil;
cnstr PInt = unfold[Pattern].PInt;
cnstr PStr = unfold[Pattern].PStr;
cnstr PBool = unfold[Pattern].PBool;
cnstr PCons = unfold[Pattern].PCons;

ppPattern(p::Pattern)::Str = 
  case p {
    PVar(l::Loc,n::Str,t::Type) -> n;
    PTerm(l::Loc,n::Str,[][Type],ps::[Pattern]) -> n + ppPatterns(ps);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> n + ppTypes(ts) + '' + ppPatterns(ps);
    PApplyType(l::Loc,p::Pattern,ts::[Type]) -> ppPattern(p) + ppTypes(ts);
    PNil(l::Loc) -> '[]';
    PInt(l::Loc,n::Int) -> ''+n;
    PBool(l::Loc,b::Bool) -> ''+b;
    PStr(l::Loc,s::Str) -> s;
    PCons(l::Loc,h::Pattern,t::Pattern) -> ppPattern(h) + ':' + ppPattern(t);
    p::Pattern -> '<unknown: ' + p + '>';
  }

ppPatterns(ps::[Pattern])::[Str] = map[Pattern,Str](ppPattern,ps);

data TBind = 
   TypeBind(Loc,Str,Type,AST)
|  CnstrBind(Loc,Str,Type,AST)
|  FunBind(Loc,Str,[Pattern],Type,AST,AST)
|  Binding(Loc,Str,Type,AST)
|  DataBind(Loc,Str,Type,AST);

data Arm = BArm(Loc,[Pattern],AST,AST);

data Qualifier =
   BQual(Loc,Pattern,AST)
|  PQual(Loc,AST);

type AST = rec A. union {
  Module(Str,[Str],[Str],Null,Null,[TBind]),
  FunExp(Loc,A,[TDec],Type,A),
  IntExp(Loc,Int),
  StrExp(Loc,Str),
  BoolExp(Loc,Bool),
  FloatExp(Loc,Int,Int),
  Term(Loc,Str,[Type],[A]),
  List(Loc,[A]),
  NullExp(Loc),
  Case(Loc,[TDec],[A],[Arm]),
  Var(Loc,Str),
  Block(Loc,[A]),
  Apply(Loc,A,[A]),
  ApplyTypeExp(Loc,A,[Type]),
  BinExp(Loc,A,Str,A),
  For(Loc,Pattern,A,A),
  Throw(Loc,Type,A),
  ActExp(Loc,A,[TDec],[Str],Str,[TBind],A,[Arm]),
  If(Loc,A,A,A),
  Ref(Loc,A,Str),
  Update(Loc,Str,A),
  Self(Loc),
  Send(Loc,A,A),
  Cmp(Loc,A,[Qualifier]),
  New(Loc,A,[A]),
  NewJava(Loc,Str,Type,[A]),
  Let(Loc,[TBind],A),
  Letrec(Loc,[TBind],A),
  Grab(Loc,[DRef],A),
  Probably(Loc,A,Type,A,A),
  Not(Loc,A),
  Fold(Loc,Type,A),
  Unfold(Loc,Type,A),
  Now(Loc),
  Become(Loc,A),
  Try(Loc,A,[Arm]),
  Record(Loc,[TBind])
}
cnstr Module = unfold[AST].Module;
cnstr FunExp = unfold[AST].FunExp;
cnstr StrExp = unfold[AST].StrExp;
cnstr IntExp = unfold[AST].IntExp;
cnstr BoolExp = unfold[AST].BoolExp;
cnstr FloatExp = unfold[AST].FloatExp;
cnstr Term = unfold[AST].Term;
cnstr List = unfold[AST].List;
cnstr NullExp = unfold[AST].NullExp;
cnstr Case = unfold[AST].Case;
cnstr Var = unfold[AST].Var;
cnstr Block = unfold[AST].Block;
cnstr Apply = unfold[AST].Apply;
cnstr ApplyTypeExp = unfold[AST].ApplyTypeExp;
cnstr BinExp = unfold[AST].BinExp;
cnstr For = unfold[AST].For;
cnstr Throw = unfold[AST].Throw;
cnstr ActExp = unfold[AST].ActExp;
cnstr If = unfold[AST].If;
cnstr Ref = unfold[AST].Ref;
cnstr Update = unfold[AST].Update;
cnstr Self = unfold[AST].Self;
cnstr Send = unfold[AST].Send;
cnstr Cmp = unfold[AST].Cmp;
cnstr New = unfold[AST].New;
cnstr NewJava = unfold[AST].NewJava;
cnstr Let = unfold[AST].Let;
cnstr Letrec = unfold[AST].Letrec;
cnstr Grab = unfold[AST].Grab;
cnstr Probably = unfold[AST].Probably;
cnstr Not = unfold[AST].Not;
cnstr Fold = unfold[AST].Fold;
cnstr Unfold = unfold[AST].Unfold;
cnstr Now = unfold[AST].Now;
cnstr Become = unfold[AST].Become;
cnstr Try = unfold[AST].Try;
cnstr Record = unfold[AST].Record;

env0::TEnv = [
  Map('kill',ForallType(Pos(0,0),['T'],FunType(Pos(0,0),[VarType(Pos(0,0),'T')],VoidType(Pos(0,0))))),
  Map('print',ForallType(Pos(0,0),['T'],FunType(Pos(0,0),[VarType(Pos(0,0),'T')],VoidType(Pos(0,0))))),
  Map('parse',ForallType(Pos(0,0),['T'],FunType(Pos(0,0),[StrType(Pos(0,0))],VarType(Pos(0,0),'T')))),
  Map('random',FunType(Pos(0,0),[IntType(Pos(0,0))],IntType(Pos(0,0)))),
  Map('wait',FunType(Pos(0,0),[IntType(Pos(0,0))],VoidType(Pos(0,0)))),
  Map('stopAll',FunType(Pos(0,0),[],VoidType(Pos(0,0))))
];

cnstrEnv0::TEnv = [
  Map('Time',UnionType(Pos(0,0),[TermType(Pos(0,0),'Time',[IntType(Pos(0,0))])])),
  Map('Point',UnionType(Pos(0,0),[TermType(Pos(0,0),'Point',[IntType(Pos(0,0)),IntType(Pos(0,0))])]))
];

ppTypeEnv(env::TEnv)::Str =
  let s::Str = '[';
  in {
    for Map(n::Str,t::Type) in env do
      s := s + n + '->' + ppType(t) + ',';
    s+']';
  }

ppTypes(ts::[Type])::[Str] = map[Type,Str](ppType,ts);
  
ppType(t::Type)::Str =
  case t {
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> '' + t;
    ApplyType(l::Loc,n::Str,args::[Type]) -> n + map[Type,Str](ppType,args);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ppType(op) + map[Type,Str](ppType,args);
    BoolType(l::Loc) -> 'Bool';
    FloatType(l::Loc) -> 'Float';
    FieldType(l::Loc,n::Str,t::Type) -> n + '::' + ppType(t);
    ForallType(l::Loc,ns::[Str],t::Type) -> 'Forall' + ns + '.' + ppType(t);
    FunType(l::Loc,d::[Type],r::Type) -> map[Type,Str](ppType,d) + '->' + ppType(r);
    IntType(l::Loc) -> 'Int';
    ListType(l::Loc,t::Type) -> '[' + ppType(t) + ']';
    NullType(l::Loc) -> 'Null';
    RecType(l::Loc,n::Str,t::Type) -> 'rec ' + n + '.' + ppType(t);
    RecordType(l::Loc,fs::[Type])  -> '{' + ppTypes(fs) + '}';
    StrType(l::Loc) -> 'Str';
    TermType(l::Loc,n::Str,ts::[Type]) -> n + map[Type,Str](ppType,ts);
    TypeFun(l::Loc,ns::[Str],t::Type) -> 'Fun' + ns + '.' + ppType(t);
    UnfoldType(l::Loc,t::Type) -> 'unfold ' + ppType(t);
    UnionType(l::Loc,ts::[Type]) -> 'union ' + map[Type,Str](ppType,ts);
    VarType(l::Loc,n::Str) -> n;
    VoidType(l::Loc) -> 'Void';
    UnionRef(l::Loc,t::Type,n::Str) -> ppType(t) + '.' + n;
    TypeClosure(f::()->Type) -> f + '';
    x::Type -> '<unknown ' + x + '>';
  }
  
typeEnv(defs::[TBind])::TEnv =
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,t):typeEnv(ds);
    b::TBind:ds::[TBind] -> typeEnv(ds);
  }
  
cnstrEnv(defs::[TBind],env::TEnv)::TEnv = 
  case defs {
    [][TBind] -> [][TMap];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> cnstrEnv(ds,env);
    DataBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> getConstructors(l,lookupType(n,env),lookupType(n,env)) + cnstrEnv(ds,env);
    b::TBind:ds::[TBind] -> cnstrEnv(ds,env);
  }

getConstructors(l::Loc,dataType::Type,t::Type)::TEnv = { //print[Str]('get constructors ' + ppType(t));
  // The type name may refer to a normal union, a recursive union, a type function, or a recursive type function...
  // rec Tree.Fun[X].union [Leaf[X],Pair[Tree[X],Tree[X]]]
  case t {
      RecType(l::Loc,n::Str,t::Type) -> getConstructors(l,dataType,t);
      TypeFun(l::Loc,ns::[Str],t::Type) ->  getConstructors(l,dataType,t);
      UnionType(l::Loc,ts::[Type]) ->
        map[Type,TMap](fun(t::Type)::TMap case t { TermType(l::Loc,n::Str,tts::[Type]) -> Map(n,dataType); },ts);
      t -> throw[TEnv] TypeError(l,'cannot extract constructors from ' + ppType(t));
  }}

zipTypeEnv(ns::[Str],ts::[Type])::TEnv =
  case ns,ts {
    [][Str],[][Type] -> [][TMap];
    n::Str:ns::[Str],t::Type:ts::[Type] -> Map(n,t):zipTypeEnv(ns,ts);
  }
  
lookupType(name::Str,env::TEnv)::Type =
  case env {
    [][TMap] -> null[Type];
    Map(n::Str,t::Type):e::TEnv when n = name -> t;
    m::TMap:e::TEnv -> lookupType(name,e);
  }
  
typeEnvDom(e::TEnv)::[Str] =
  case e {
    [][TMap] -> [][Str];
    Map(n::Str,t::Type):x::TEnv -> n:typeEnvDom(x);
  }
  
removeFromDom(e::TEnv,ns::[Str])::TEnv =
  case e {
    [][TMap] -> [][TMap];
    Map(n::Str,t::Type):e::TEnv when member[Str](n,ns) -> removeFromDom(e,ns);
    Map(n::Str,t::Type):e::TEnv -> Map(n,t):removeFromDom(e,ns);
  }
  
restrictTypeEnv(e::TEnv,ns::[Str])::TEnv =
  case e {
    [][TMap] -> [][TMap];
    Map(n::Str,t::Type):e::TEnv when not(member[Str](n,ns)) -> restrictTypeEnv(e,ns);
    Map(n::Str,t::Type):e::TEnv -> Map(n,t):restrictTypeEnv(e,ns);
  }
  
typeEnvRan(e::TEnv)::[Type] =
  case e {
    [][TMap] -> [][Type];
    Map(n::Str,t::Type):x::TEnv -> t:typeEnvRan(x);
  }

checkFreeTypes(e::TEnv)::Void =

  // Assumes that the types are all recursive and will throw an error
  // if the types in the environment have a free type variable reference
  // that is not bound by the environment...
  
  let dom::[Str] = typeEnvDom(e);
      ran::[Type] = typeEnvRan(e); in
  let freeNames::[Str] = removeAll[Str](dom,flatten[Str](map[Type,[Str]](typeFV,ran)));
  in if freeNames = [][Str]
     then null[Void];
     else throw[Void]('Unbound Types: ' + freeNames);
     
checkSingletonTypes(e::TEnv)::Void =
  
  // Check that no types have the same name...
 
  case e {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):e::TEnv ->
      if member[Str](n,typeEnvDom(e))
      then throw[Void]('Duplicate type name: ' + n);
      else checkSingletonTypes(e);
  }
     
checkSingletonConstructors(e::TEnv)::Void = 
  
  // Check that no types have the same name...
 
  case e {
    [][TMap] -> null[Void];
    Map(n::Str,t::Type):e::TEnv ->
      if member[Str](n,typeEnvDom(e))
      then throw[Void]('Duplicate constructor name: ' + n);
      else checkSingletonConstructors(e);
  }


valueDefs(defs::[TBind])::[TBind] =
  case defs {
    [][TBind] -> [][TBind];
    TypeBind(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    DataBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    CnstrBind(l1::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> valueDefs(ds);
    b::TBind:ds::[TBind] -> b:valueDefs(ds);
  }

 valueDefsToTEnv(defs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv = { 
   case defs {
     [][TBind] -> [][TMap];
     FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,b::AST,g::AST):ds::[TBind] ->
     
       // In principle we should be able to define cases of the same function
       // on different lines. That would require us to know the types of the
       // arguments to the function in order to check it. For now, assume just
       // single defintions with pattern-variables...

       Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
          
     Binding(l::Loc,n::Str,t::Type,e::AST):ds::[TBind] -> Map(n,substTypeEnv(typeEnv,t)):valueDefsToTEnv(ds,selfType,valueEnv,cnstrEnv,typeEnv);
   }
 }
 
typeCheckModule(module::AST,handler::(TEnv,TEnv,TEnv) ->Void)::Void =

  // Called to process a module (including dealing with imports)
  // and to generate type errors where they occur...

  letrec

    processImports(imports::[Str],handler::(TEnv,TEnv,TEnv) -> Void)::Void =

      case imports {
        [][Str] -> handler([][TMap],[][TMap],[][TMap]);
        path::Str:imports::[Str] ->
          let imports::[Str] = imports; in // Closure bug, pattern vars are not closed in...
          typeCheckModule(parse[AST](path),fun(valueEnv0::TEnv,cnstrEnv0::TEnv,typeEnv0::TEnv)::Void
            processImports(imports,fun(valueEnv1::TEnv,cnstrEnv1::TEnv,typeEnv1::TEnv)::Void
              handler(valueEnv1+valueEnv0,cnstrEnv1+cnstrEnv0,typeEnv1+typeEnv0)));
      }
  
    main()::Void =
      case module {
        Module(name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> { print[Str]('imports = ' + imports);
          processImports(imports,fun(ivalueEnv::TEnv,icnstrEnv::TEnv,itypeEnv::TEnv)::Void
            let e::TEnv = typeEnv(defs);
            in { 
              checkFreeTypes(e);
              checkSingletonTypes(e);
              let typeEnv::TEnv = recTypes(e) + itypeEnv; in 
              let cnstrEnv::TEnv = cnstrEnv(defs,typeEnv) + icnstrEnv + cnstrEnv0;
              in { 
                print[Str]('typeEnv = ' + ppTypeEnv(typeEnv));
                print[Str]('cnstrEnv = ' + ppTypeEnv(cnstrEnv));
                print[Str]('value defs = ' + valueDefs(defs));
                checkSingletonConstructors(cnstrEnv); 
                // Add in the definitions into the type env and
                // then type check each of the definitions and
                // compare the generated type with the declared
                // type...
                let valueEnv::TEnv = typeCheckValues(valueDefs(defs),NullType(Pos(0,0)),ivalueEnv,typeEnv,cnstrEnv);
                in handler(restrictTypeEnv(valueEnv,exports),restrictTypeEnv(cnstrEnv,exports),restrictTypeEnv(typeEnv,exports));
              }
            });
      }
      }
  in main();



typeCheckValues(valueDefs::[TBind],selfType::Type,ivalueEnv::TEnv,typeEnv::TEnv,cnstrEnv::TEnv)::TEnv =

  // Create a value-to-type environment...

  let valueEnv::TEnv = valueDefsToTEnv(valueDefs,selfType,[][TMap],cnstrEnv,typeEnv) + ivalueEnv + env0;
  in {
    for def::TBind in valueDefs do {
    // Get the type of the defined expression and compare it to the
    // declared type...
    typeCheckDef(def,selfType,valueEnv,valueEnv,cnstrEnv,typeEnv);
   }
   valueEnv;
}

genericize(l::Loc,t::Type)::Type = if length[Str](typeFV(t)) = 0 then t; else ForallType(l,typeFV(t),t);

typeCheckDef(def::TBind,selfType::Type,baseValueEnv::TEnv,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =
  case def {
              FunBind(l::Loc,n::Str,ps::[Pattern],t::Type,b::AST,g::AST) -> { 
                let argTypes::[Type] = map[Pattern,Type](fun(p::Pattern)::Type case p { PVar(l::Loc,n::Str,t::Type) -> substTypeEnv(typeEnv,t); },ps);
                    argNames::[Str] = map[Pattern,Str](fun(p::Pattern)::Str case p { PVar(l::Loc,n::Str,t::Type) -> n; },ps);
                in let bodyType::Type = guardedExpType(l,g,b,selfType,zipTypeEnv(argNames,argTypes) + valueEnv,cnstrEnv,typeEnv); in
                   let fType::Type = case t { ForallType(l::Loc,ns::[Str],t::Type) -> genericize(l,FunType(l,argTypes,bodyType)); t::Type -> FunType(l,argTypes,bodyType); }
                       dType::Type = substTypeEnv(typeEnv,t);
                   in if typeEqual(fType,dType)
                      then print[Str](n + '::' + ppType(lookupType(n,valueEnv)) + ' = ' + ppType(bodyType));
                      else throw[Void] TypeError(l,'type of ' + n + '::' + ppType(fType) + ' does not match declaration ' + ppType(dType));
              }
              Binding(l::Loc,n::Str,dt::Type,e::AST) ->
               let valueType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv); in
               let valueFV::[Str] = typeFV(valueType);
                   declaredType::Type = lookupType(n,baseValueEnv); in
               let valueType::Type = if valueFV = [][Str] then valueType; else ForallType(l,valueFV,valueType);
               in {
                if typeEqual(valueType,declaredType)
                then print[Str](n + '::' + ppType(declaredType) + ' = ' + ppType(valueType));
                else throw[Void]('type of ' + n + ' ' + ppType(valueType) + ' does not match declared type = ' + ppType(declaredType));
               }
           }

typeEqual(t1::Type,t2::Type)::Bool = {
  let b::Bool = typeEqual1(t1,t2);
  in {
    //print[Str]('type equal ' + ppType(t1) + ' ' + ppType(t2) + ' = ' + b);
    b;
  }
}

typeEqual1(t1::Type,t2::Type)::Bool = { //print[Str]('type equal: ' + ppType(t1) + ' = ' + ppType(t2));
  if t1 = t2
  then true;
  else case t1,t2 {
    ActType(l1::Loc,exports1::[TDec],handlers1::[MType]),ActType(l2::Loc,exports2::[TDec],handlers2::[MType]) -> actEqual(exports1,exports1,handlers1,handlers2);
    ApplyTypeFun(l1::Loc,op1::Type,args1::[Type]),ApplyTypeFun(l2::Loc,op2::Type,args2::[Type]) -> typeEqual(op1,op2) and typesEqual(args1,args2);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]),t2::Type -> typeEqual(applyTypeFun(l,forceType(op),args),t2);
    t1::Type,ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> typeEqual(t1,applyTypeFun(l,forceType(op),args));
    BoolType(l1::Loc),BoolType(l2::Loc) -> true;
    FloatType(l1::Loc),FloatType(l2::Loc) -> true;
    IntType(l1::Loc),IntType(l2::Loc) -> true;
    ListType(l1::Loc,t1::Type),ListType(l2::Loc,t2::Type) -> typeEqual(t1,t2);
    StrType(l1::Loc),StrType(l2::Loc) -> true;
    VoidType(l1::Loc),t::Type -> true;
    t::Type,VoidType(l1::Loc) -> true;
    FieldType(l1::Loc,n1::Str,t1::Type),FieldType(l2::Loc,n2::Str,t2::Type) -> n1=n2 and typeEqual(t1,t2);
    TermType(l1::Loc,n1::Str,args1::[Type]),TermType(l2::Loc,n2::Str,args2::[Type]) -> if n1=n2 then typesEqual(args1,args2); else false;
    TermType(l1::Loc,n1::Str,args1::[Type]),t2::Type -> false;
    t1::Type,TermType(l2::Loc,n2::Str,args2::[Type]) -> false;
    FunType(l1::Loc,d1::[Type],r1::Type),FunType(l2::Loc,d2::[Type],r2::Type) -> typeEqual(r1,r2) and typesEqual(d1,d2);
    TypeClosure(f::()->Type),t2::Type -> typeEqual(f(),t2);
    t1::Type,TypeClosure(f::()->Type) -> typeEqual(t1,f());
    RecordType(l1::Loc,fs1::[Type]),RecordType(l2::Loc,fs2::[Type]) -> recordTypeEqual(fs1,fs2);
    RecType(l1::Loc,n1::Str,t1::Type),t2::Type -> typeEqual(substType(RecType(l1,n1,t1),n1,t1),t2);
    t1::Type,RecType(l2::Loc,n2::Str,t2::Type) -> typeEqual(t1,substType(RecType(l2,n2,t2),n2,t2));
    UnionType(l1::Loc,terms1::[Type]),UnionType(l2::Loc,terms2::[Type]) -> typeSetEqual(terms1,terms2);
    VarType(l1::Loc,n1::Str),VarType(l2::Loc,n2::Str) -> n1 = n2;
    ForallType(l1::Loc,ns1::[Str],t1::Type),ForallType(l1::Loc,ns2::[Str],t2::Type) -> ns1 = ns2 and typeEqual(t1,t2);
    t1::Type,t2::Type -> false;
  }}

actEqual(exports1::[TDec],exports2::[TDec],handlers1::[MType],handlers2::[MType])::Bool =
  forall[TDec](fun(d1::TDec)::Bool exists[TDec](fun(d2::TDec)::Bool equalDec(d1,d2),exports2),exports1) and
  forall[TDec](fun(d1::TDec)::Bool exists[TDec](fun(d2::TDec)::Bool equalDec(d1,d2),exports1),exports2) and
  forall[MType](fun(m1::MType)::Bool exists[MType](fun(m2::MType)::Bool equalMessage(m1,m2),handlers2),handlers1) and
  forall[MType](fun(m1::MType)::Bool exists[MType](fun(m2::MType)::Bool equalMessage(m1,m2),handlers1),handlers2);

equalDec(d1::TDec,d2::TDec)::Bool =
  case d1,d2 {
    Dec(l1::Loc,n1::Str,t1::Type),Dec(l2::Loc,n2::Str,t2::Type) -> n1=n2 and typeEqual(t1,t2);
  }

equalMessage(m1::MType,m2::MType)::Bool =
  case m1,m2 {
    MessageType(l1::Loc,ts1::[Type]),MessageType(l2::Loc,ts2::[Type]) -> typesEqual(ts1,ts2);
  }

recordTypeEqual(fields1::[Type],fields2::[Type])::Bool = 
  forall[Type](fun(t1::Type)::Bool exists[Type](fun(t2::Type)::Bool typeEqual(t1,t2),fields2),fields1) and
  forall[Type](fun(t1::Type)::Bool exists[Type](fun(t2::Type)::Bool typeEqual(t1,t2),fields1),fields2);

applyTypeFun(l::Loc,op::Type,args::[Type])::Type =
  case op {
    RecType(lr::Loc,n::Str,t::Type) -> applyTypeFun(l,unfoldType(lr,n,t),args);
    TypeFun(l::Loc,names::[Str],t::Type) ->
      if length[Type](args) = length[Str](names)
      then substTypeEnv(zipTypeEnv(names,args),t);
      else throw[Type] TypeError(l,'type fun expects ' + length[Str](names) + ' args, but supplied with ' + length[Type](args));
    op::Type -> throw[Type] TypeError(l,'expecting a type function: ' + ppType(op));
  }

unfoldType(l::Loc,n::Str,t::Type)::Type = substType(RecType(l,n,t),n,t);

forceType(t::Type)::Type =
  case t {
    TypeClosure(f::()->Type) -> forceType(f());
    t::Type -> t;
  }

typesEqual(ts1::[Type],ts2::[Type])::Bool =
  case ts1,ts2 {
    [][Type],[][Type] -> true;
    [][Type],ts2::[Type] -> false;
    ts1::[Type],[][Type] -> false;
    t1::Type:ts1::[Type],t2::Type:ts2::[Type] -> typeEqual(t1,t2) and typesEqual(ts1,ts2);
  }

typeSetEqual(types1::[Type],types2::[Type])::Bool =
  typeSubset(types1,types2) and typeSubset(types2,types1);

typeSubset(sub::[Type],super::[Type])::Bool =
  case sub {
    [][Type] -> true;
    t::Type:sub::[Type] -> typeMember(t,super) and typeSubset(sub,super);
  }

typeMember(t::Type,types::[Type])::Bool =
  case types {
    [][Type] -> false;
    tt::Type:types::[Type] when typeEqual(t,tt) -> true;
    tt::Type:types::[Type] -> typeMember(t,types);
  }

guardedExpType(l::Loc,g::AST,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bt::Type = expType(g,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(bt)
     then expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
     else throw[Type] TypeError(l,'guarded expression requires a boolean value: ' + ppType(bt));

expType(e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = { 
  //print[Str]('exp type: ' + e);
  case e {
    ActExp(l::Loc,n::AST,args::[TDec],exports::[Str],spec::Str,bindings::[TBind],init::AST,arms::[Arm]) -> actType(l,n,args,exports,bindings,init,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Apply(l::Loc,op::AST,args::[AST]) -> applyType(l,op,args,selfType,valueEnv,cnstrEnv,typeEnv);
    ApplyTypeExp(l::Loc,e::AST,ts::[Type]) -> applyTypeExp(l,e,ts,selfType,valueEnv,cnstrEnv,typeEnv);
    Become(l::Loc,e::AST) -> becomeType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    BinExp(l::Loc,e1::AST,op::Str,e2::AST) -> binExpType(l,e1,op,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    Block(l::Loc,es::[AST]) -> blockType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    BoolExp(l::Loc,b::Bool) -> BoolType(l);
    Case(l::Loc,decs::[TDec],es::[AST],arms::[Arm]) -> caseType(l,es,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    Cmp(l::Loc,e::AST,qs::[Qualifier]) -> cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
    Grab(l::Loc,refs::[DRef],e::AST) -> expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    FloatExp(l::Loc,n1::Int,n2::Int) -> FloatType(l);
    For(l::Loc,p::Pattern,list::AST,e::AST) -> forType(l,p,list,e,selfType,valueEnv,cnstrEnv,typeEnv);
    FunExp(l::Loc,n::AST,args::[TDec],t::Type,e::AST) -> funType(l,n,args,t,e,selfType,valueEnv,cnstrEnv,typeEnv);
    If(l::Loc,e1::AST,e2::AST,e3::AST) -> ifType(l,e1,e2,e3,selfType,valueEnv,cnstrEnv,typeEnv);
    IntExp(l::Loc,n::Int) -> IntType(l);
    Let(l::Loc,bs::[TBind],e::AST) -> letType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Letrec(l::Loc,bs::[TBind],e::AST) -> letrecType(l,bs,e,selfType,valueEnv,cnstrEnv,typeEnv);
    List(l::Loc,es::[AST]) -> listType(l,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Now(l::Loc) -> IntType(l);
    Probably(l::Loc,p::AST,t::Type,e1::AST,e2::AST) -> probablyType(l,p,t,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    Record(l::Loc,fields::[TBind]) -> recordType(l,fields,selfType,valueEnv,cnstrEnv,typeEnv);
    Ref(l::Loc,e::AST,n::Str) -> refType(l,e,n,selfType,valueEnv,cnstrEnv,typeEnv);
    Self(l::Loc) -> selfType;
    Send(l::Loc,target::AST,Term(tl::Loc,n::Str,ts::[Type],args::[AST])) -> sendType(l,target,n,args,selfType,valueEnv,cnstrEnv,typeEnv);
    StrExp(l::Loc,s::Str) -> StrType(l);
    Term(l::Loc,n::Str,ts::[Type],es::[AST]) -> termType(l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
    Throw(l::Loc,t::Type,e::AST) -> substTypeEnv(typeEnv,t);
    Try(l::Loc,e::AST,arms::[Arm]) -> tryType(l,e,arms,selfType,valueEnv,cnstrEnv,typeEnv);
    New(l::Loc,b::AST,args::[AST]) -> newType(l,b,args,selfType,valueEnv,cnstrEnv,typeEnv);
    NewJava(l::Loc,path::Str,t::Type,args::[AST]) -> { for a::AST in args do expType(a,selfType,valueEnv,cnstrEnv,typeEnv); substTypeEnv(typeEnv,t); }
    Not(l::Loc,e::AST) -> notType(l,e,selfType,valueEnv,cnstrEnv,typeEnv);
    NullExp(l::Loc) -> ForallType(l,['T'],VarType(l,'T'));
    Update(l::Loc,n::Str,e::AST) -> updateType(l,n,e,selfType,valueEnv,cnstrEnv,typeEnv);
    Var(l::Loc,n::Str) -> varType(l,n,valueEnv);
  }}

becomeType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let bType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(bType,selfType)
     then bType;
     else throw[Type] TypeError(l,'expecting become to match self type: ' + ppType(bType) + ' ' + ppType(selfType));

probablyType(l::Loc,p::AST,t::Type,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let pt::Type = expType(p,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(pt)
     then
       let t::Type = substTypeEnv(typeEnv,t);
           t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
           t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(t,t1) and typeEqual(t,t2)
          then t;
          else throw[Type] TypeError(l,'expecting probably arm types to agree: ' + ppType(t1) + ' ' + ppType(t) + ' ' + ppType(t2));
     else throw[Type] TypeError(l,'expecting an integer: ' + ppType(pt));

newType(l::Loc,b::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  expType(Apply(l,b,args),selfType,valueEnv,cnstrEnv,typeEnv);

sendType(l::Loc,target::AST,n::Str,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case derefType(expType(target,selfType,valueEnv,cnstrEnv,typeEnv)) {
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      letrec
        findHandler(handlers::[MType])::MType = 
          case handlers {
            [][MType] -> null[MType];
            MessageType(ml::Loc,[TermType(tl::Loc,m::Str,ts::[Type])]):rest::[MType] when m = n -> head[MType](handlers);
            m::MType:handlers::[MType] -> findHandler(handlers);
          }
      in case findHandler(handlers) {
        MessageType(ml::Loc,[TermType(tl::Loc,n::Str,ts1::[Type])]) ->
          let ts2::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
          in if length[Type](ts1) = length[Type](ts2)
             then 
               if typesEqual(ts1,ts2)
               then {
                expType(target,selfType,valueEnv,cnstrEnv,typeEnv);
                VoidType(l);
               }
               else throw[Type] TypeError(l,'message argument types ' + ppTypes(ts2) + ' do not match expected types ' + ppTypes(ts1));
             else throw[Type] TypeError(l,'expecting ' + length[Type](ts1) + ' args, but received ' + length[Type](ts2));
        m::MType -> throw[Type] TypeError(l,'cannot find message handler named ' + n);
      }
  }

actType(l::Loc,n::AST,args::[TDec],exports::[Str],bindings::[TBind],init::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 

  // Create a behaviour type based on the exported bindings and the message types in the type body.
  // The values of the bindings, the initialiser and the bodies of the message handlers must be 
  // checked and must be supplied with the behaviour type as the self type.
  
  letrec
    findLoc(n::Str,bindings::[TBind])::Loc =
      case bindings {
        [][TBind] -> Pos(0,0);
        Binding(l::Loc,m::Str,t::Type,e::AST):bindings::[TBind] when m=n -> l;
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,g::AST,e::AST):bindings::[TBind] when m=n -> l;
        b::TBind:bindings::[TBind] -> findLoc(n,bindings);
      }
    findType(n::Str,bindings::[TBind])::Type =
      case bindings {
        [][TBind] -> null[Type];
        Binding(l::Loc,m::Str,t::Type,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        FunBind(l::Loc,m::Str,ps::[Pattern],t::Type,g::AST,e::AST):bindings::[TBind] when m=n -> substTypeEnv(typeEnv,t);
        b::TBind:bindings::[TBind] -> findType(n,bindings);
      }
    decs(exports::[Str])::[TDec] =
      case exports {
        [][Str] -> [][TDec];
        m::Str:exports::[Str] -> 
          let t::Type = findType(m,bindings);
              l::Loc = findLoc(m,bindings);
          in if t = null[Type]
             then throw[[TDec]] TypeError(l,'cannot find exported name ' + m);
             else Dec(l,m,t):decs(exports);
      }
    getMessageTypes(arms::[Arm])::[MType] =
      case arms {
        [][Arm] -> [][MType];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> getMessageType(ps):getMessageTypes(arms);
      }
    getMessageType(ps::[Pattern])::MType =
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in MessageType(pl,[TermType(pl,termName,ts)]);
      }
    typeCheckArms(arms::[Arm],selfType::Type,valueEnv::TEnv)::Void =
      case arms {
        [][Arm] -> null[Void];
        BArm(l::Loc,ps::[Pattern],g::AST,e::AST):arms::[Arm] -> {
          typeCheckArm(l,ps,g,e,selfType,valueEnv);
          typeCheckArms(arms,selfType,valueEnv);
        }
      }
    typeCheckArm(l::Loc,ps::[Pattern],g::AST,e::AST,selfType::Type,valueEnv::TEnv)::Void = 
      case ps {
        [PTerm(pl::Loc,termName::Str,targs::[Type],ps::[Pattern])] ->
          let ts::[Type] = map[Pattern,Type](fun(p::Pattern)::Type getPatternType(l,p,selfType,valueEnv,cnstrEnv,typeEnv),ps);
          in {
            patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(ts::[Type],valueEnv::TEnv)::Type {
              expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
            });
            null[Void];
          }
      }
  in let localEnv::TEnv = parBind(bindings,selfType,valueEnv,cnstrEnv,typeEnv); in
     let exportedDecs::[TDec] = decs(exports); in
     let messageTypes::[MType] = getMessageTypes(arms); in
     let selfType::Type = ActType(l,exportedDecs,messageTypes) ;
     in {
      typeCheckValues(valueDefs(bindings),selfType,localEnv + valueEnv,typeEnv,cnstrEnv);
      expType(init,selfType,localEnv + valueEnv,cnstrEnv,typeEnv);
      typeCheckArms(arms,selfType,localEnv+valueEnv);
      selfType;
     }

cmpType(l::Loc,e::AST,qs::[Qualifier],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case qs {
    [][Qualifier] -> 
      let t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
      in ListType(l,t);
    BQual(l::Loc,p::Pattern,list::AST):qs::[Qualifier] -> 
      let lType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
      in case lType {
        ListType(ll::Loc,t::Type) ->
          let qs::[Qualifier] = qs; in // Closure bug...
          patternType(l,p,substTypeEnv(typeEnv,t),selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type
            cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv));
        t::Type -> throw[Type] TypeError(l,'qualifier binding expects a list: ' + ppType(t));
      }
    PQual(l::Loc,b::AST):qs::[Qualifier] ->
      let bType::Type = expType(b,selfType,valueEnv,cnstrEnv,typeEnv);
      in if isBoolType(bType)
         then cmpType(l,e,qs,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Type] TypeError(l,'qualifier expects a boolean type: ' + ppType(bType));
  }

updateType(l::Loc,n::Str,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else 
       let valueType::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(valueType,t)
          then valueType;
          else throw[Type] TypeError(l,'type of variable ' + n + '::' + ppType(t) + ' does not agree with value type ' + ppType(valueType));

letType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = parBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in {
    for b::TBind in bs do typeCheckDef(b,selfType,env+valueEnv,valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }
  
letrecType(l::Loc,bs::[TBind],e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let env::TEnv = recBind(bs,selfType,valueEnv,cnstrEnv,typeEnv);
  in { print[Str]('rec bind value env = ' + env);
    for b::TBind in bs do typeCheckDef(b,selfType,env + valueEnv,env + valueEnv,cnstrEnv,typeEnv);
    expType(e,selfType,env + valueEnv,cnstrEnv,typeEnv);
  }

parBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv =
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);

recBind(bs::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::TEnv =
  valueDefsToTEnv(valueDefs(bs),selfType,valueEnv,cnstrEnv,typeEnv);

caseType(l::Loc,es::[AST],arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts1::[Type] = expTypes(es,selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'case arm types do not agree: ' + ppTypes(ts1) + ' ' + ppTypes(ts2));

tryType(l::Loc,e::AST,arms::[Arm],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts1::[Type] = expTypes([e],selfType,valueEnv,cnstrEnv,typeEnv); in
  let ts2::[Type] = armTypes(arms,ts1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if allEqualTypes(head[Type](ts2),tail[Type](ts2))
     then head[Type](ts2);
     else throw [Type] TypeError(l,'try arm types do not agree: ' + ppTypes(ts1) + ' ' + ppTypes(ts2));

armTypes(arms::[Arm],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] = 
  case arms {
    [][Arm] -> [][Type];
    a::Arm:arms::[Arm] -> armType(a,ts,selfType,valueEnv,cnstrEnv,typeEnv):armTypes(arms,ts,selfType,valueEnv,cnstrEnv,typeEnv);
  }

armType(arm::Arm,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  //print[Str]('armType ' + arm);
  case arm {
    BArm(l::Loc,ps::[Pattern],guard::AST,exp::AST) ->
      if length[Pattern](ps) = length[Type](ts)
      then patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(types::[Type],valueEnv::TEnv)::Type guardedExpType(l,guard,exp,selfType,valueEnv,cnstrEnv,typeEnv));
      else throw[Type] TypeError(l,'number of patterns ' + length[Pattern](ps) + ' does not match supplied values: ' + length[Type](ts));
  }}
  

refType(l::Loc,e::AST,n::Str,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    t::Type = derefType(expType(e,selfType,valueEnv,cnstrEnv,typeEnv));
    findExport(decs::[TDec])::Type = 
      case decs {
        [][TDec] -> null[Type];
        Dec(l::Loc,m::Str,t::Type):decs::[TDec] when m=n -> t;
        d::TDec:decs::[TDec] -> findExport(decs);
      }
    findField(fs::[Type])::Type =
      case fs {
        [][Type] -> throw[Type] TypeError(l,'cannot find field name ' + n);
        FieldType(l::Loc,m::Str,t::Type):fs::[Type] when m=n -> t;
        t::Type:fs::[Type] -> findField(fs);
      }
  in case t {
    RecordType(rl::Loc,fs::[Type]) -> findField(fs);
    ActType(al::Loc,exports::[TDec],handlers::[MType]) ->
      let t::Type = findExport(exports);
      in if t = null[Type]
         then throw[Type] TypeError(l,'behaviour type does not export ' + n);
         else substTypeEnv(typeEnv,t);
    t::Type -> throw[Type] TypeError(l,'expecting a record type, but received ' + ppType(t));
  }

derefType(t::Type)::Type =
  case t {
    TypeClosure(f::()->Type) -> derefType(f());
    t::Type -> t;
  }

recordType(l::Loc,fields::[TBind],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  letrec
    fieldTypes(fields::[TBind])::[Type] =
      case fields {
        [][TBind] -> [][Type];
        Binding(l::Loc,n::Str,t::Type,e::AST):fields::[TBind] ->
          FieldType(l,n,expType(e,selfType,valueEnv,cnstrEnv,typeEnv)):fieldTypes(fields);
        fields::[TBind] -> throw[[Type]] TypeError(l,'unknown field representation: ' + fields);
      }
  in RecordType(l,fieldTypes(fields));
  

forType(l::Loc,p::Pattern,list::AST,body::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let listType::Type = expType(list,selfType,valueEnv,cnstrEnv,typeEnv);
  in case listType {
    ListType(l::Loc,t::Type) ->
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type 
        expType(body,selfType,valueEnv,cnstrEnv,typeEnv));
    t::Type -> throw[Type] TypeError(l,'for type expects a list: ' + list);
  }

patternTypes(l::Loc,ps::[Pattern],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::([Type],TEnv)->Type)::Type = {
  //print[Str]('patternTypes ' + ppPatterns(ps) + ' ' + ppTypes(ts));
  case ps,ts {
    [][Pattern],[][Type] -> f([][Type],valueEnv);
    p::Pattern:ps::[Pattern],t::Type:ts::[Type] -> 
      let ps::[Pattern] = ps; ts::[Type] = ts; in // Closure Bug!!!!!
      patternType(l,p,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type 
        patternTypes(l,ps,ts,selfType,valueEnv,cnstrEnv,typeEnv,fun(tailTypes::[Type],valueEnv::TEnv)::Type 
          f(headType:tailTypes,valueEnv)));
    ps::[Pattern],ts::[Type] -> throw[Type] TypeError(l, 'somthing wrong with ' + ps + ' ' + ts);
  }}

getPatternType(l::Loc,p::Pattern,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  case p {
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> throw[Type] 'should this happen?';
    PBool(l::Loc,b::Bool) -> BoolType(l);
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> getPatternType(l,tl,selfType,valueEnv,cnstrEnv,typeEnv);
    PNil(l::Loc) -> ForallType(l,['T'],ListType(l,VarType(l,'T')));
    PInt(l::Loc,n::Int) -> IntType(l);
    PVar(l::Loc,n::Str,pt::Type) -> substTypeEnv(typeEnv,pt);
    PStr(l::Loc,s::Str) -> StrType(l);
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> lookupType(n,cnstrEnv);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

patternType(l::Loc,p::Pattern,t::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('patternType ' + ppPattern(p) + ' ' + ppType(t));
  case p {
    PApplyType(l::Loc,p::Pattern,args::[Type]) -> applyTypePatternType(l,p,substTypesEnv(typeEnv,args),t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PBool(l::Loc,b::Bool) -> if isBoolType(t) then f(BoolType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Bool and ' + ppType(t));
    PCons(l::Loc,hd::Pattern,tl::Pattern) -> consPatternType(l,hd,tl,t,selfType,valueEnv,cnstrEnv,typeEnv,fun(elementType::Type,valueEnv::TEnv)::Type f(ListType(l,elementType),valueEnv));
    PNil(l::Loc) -> nilType(l,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    PInt(l::Loc,n::Int) -> if isIntType(t) then f(IntType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Int and ' + ppType(t));
    PVar(l::Loc,n::Str,pt::Type) -> f(t,[Map(n,t)]+valueEnv);
    PStr(l::Loc,s::Str) -> if isStrType(t) then f(StrType(l),valueEnv); else throw[Type] TypeError(l,'type mismatch: Str and ' + ppType(t));
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> termPatternType(l,n,substTypesEnv(typeEnv,ts),ps,t,selfType,valueEnv,cnstrEnv,typeEnv,f);
    p::Pattern -> throw[Type] TypeError(l,'unknown type of pattern: ' +p);
  }}

applyTypePatternType(l::Loc,p::Pattern,args::[Type],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('applyTypePatternType ' + p + ' ' + args);
  patternType(l,p,valueType,selfType,valueEnv,cnstrEnv,typeEnv,fun(pType::Type,valueEnv::TEnv)::Type
    case pType {
      ForallType(fl::Loc,ns::[Str],t::Type) ->
        if length[Type](args) = length[Str](ns)
        then 
          let t::Type = substTypeEnv(zipTypeEnv(ns,args)+typeEnv,t);
          in if typeEqual(t,valueType)
             then f(t,valueEnv);
             else throw[Type] TypeError(l,'value type ' + ppType(valueType) + ' does not match pattern type ' + ppType(t) + ' ' + ppTypeEnv(typeEnv));
        else throw[Type] TypeError(l,'expecting ' + length[Str](ns) + ' args, but suplied with ' + length[Type](args));
      t::Type -> throw[Type] TypeError(l,'unknown type application pattern: ' + pType);
    });}

termPatternType(l::Loc,n::Str,genericArgs::[Type],ps::[Pattern],valueType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = {
  //print[Str]('termPatternType ' + ppType(valueType) + ' ' + ppTypes(genericArgs));
  let patternType::Type = getTermPatternType(l,n,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(patternType,valueType)
     then
       case typeNF(valueType,typeEnv) {
         UnionType(ul::Loc,cs::[Type]) -> 
           letrec
             getCnstrArgs(cs::[Type])::[Type] =
               case cs {
                 [][Type] -> throw[[Type]] TypeError(l,'cannot find constructor for ' + n);
                 TermType(tl::Loc,m::Str,args::[Type]):cs::[Type] when m=n -> args;
                 t::Type:cs::[Type] -> getCnstrArgs(cs);
               }
           in let argTypes::[Type] = getCnstrArgs(cs);
              in if length[Pattern](ps) = length[Type](argTypes)
                 then patternTypes(l,ps,argTypes,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::[Type],valueEnv::TEnv)::Type f(typeNF(valueType,typeEnv),valueEnv));
                 else throw[Type] TypeError(l,'arity mismatch.');
         t::Type -> throw[Type] TypeError(l,'expecting a data type: ' + valueType);
       }
      else throw[Type] TypeError(l,'term pattern type ' + ppType(patternType) + ' does not match supplied value type ' + ppType(valueType));
    }

typeNF(t::Type,typeEnv::TEnv)::Type =
  case substTypeEnv(typeEnv,t) {
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) ->
      case typeNF(op,typeEnv) {
        TypeFun(l::Loc,ns::[Str],t::Type) ->
          if length[Type](args) = length[Str](ns)
          then typeNF(substTypeEnv(zipTypeEnv(ns,args),t),typeEnv);
          else throw[Type] TypeError(l,'function arity error');
        t::Type -> throw[Type] TypeError(l,'expecting a type function: ' + ppType(typeNF(op,typeEnv)));
      }
    TypeClosure(f::()->Type) -> typeNF(f(),typeEnv);
    RecType(l::Loc,n::Str,t::Type) -> typeNF(substType(RecType(l,n,t),n,t),typeEnv);
    t::Type -> t;
  }

getTermPatternType(l::Loc,n::Str,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  let t::Type = lookupType(n,cnstrEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unknown constructor ' + n);
     else
       if length[Type](genericArgs) > 0
       then getGenericTermPatternType(l,t,genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
       else t;
}

getGenericTermPatternType(l::Loc,t::Type,genericArgs::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case t {
    RecType(rl::Loc,rn::Str,rt::Type) -> getGenericTermPatternType(l,substType(RecType(rl,rn,rt),rn,rt),genericArgs,selfType,valueEnv,cnstrEnv,typeEnv);
    TypeFun(al::Loc,ns::[Str],t::Type) ->
      if length[Str](ns) = length[Type](genericArgs)
      then 
        let e::TEnv = zipTypeEnv(ns,genericArgs);
        in substTypeEnv(e+typeEnv,t);
      else throw[Type] TypeError(l,'generic constructor mismatch');
    t::Type -> throw[Type] TypeError(l,'expecting a generic type: ' + ppType(t));
  }

nilType(l::Loc,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) -> f(ForallType(l,['T'],ListType(l,VarType(l,'T'))),valueEnv);
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType));
  }   

consPatternType(l::Loc,h::Pattern,t::Pattern,listType::Type,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv,f::(Type,TEnv)->Type)::Type = 
  case listType {
    ListType(ltl::Loc,et::Type) ->
      patternType(l,h,substTypeEnv(typeEnv,et),selfType,valueEnv,cnstrEnv,typeEnv,fun(headType::Type,valueEnv::TEnv)::Type
        patternType(l,t,listType,selfType,valueEnv,cnstrEnv,typeEnv,fun(tt::Type,valueEnv::TEnv)::Type {
          f(headType,valueEnv);
        }));
    listType::Type -> throw[Type] TypeError(l,'expecting a list type: ' + ppType(listType));
  }

binExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  case op {
    '+' -> plusExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '-' -> subExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '*' -> mulExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '/' -> divExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    ':' -> consExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '=' -> eqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<>' -> neqlExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'and' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'andalso' -> andExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'or' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    'orelse' -> orExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>' -> compareExpType(l,e1,'>',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '>=' -> compareExpType(l,e1,'>=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<' -> compareExpType(l,e1,'<',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '<=' -> compareExpType(l,e1,'<=',e2,selfType,valueEnv,cnstrEnv,typeEnv);
    '..' -> dotDotExpType(l,e1,e2,selfType,valueEnv,cnstrEnv,typeEnv);
    op::Str -> throw[Type] TypeError(l,'unknown operator: ' + op);
  }

andExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'and expects boolean arguments: ' + ppType(t1) + ' ' + ppType(t2));

dotDotExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then ListType(l,IntType(l));
     else throw[Type] TypeError(l,'.. expects integer arguments: ' + ppType(t1) + ' ' + ppType(t2));

compareExpType(l::Loc,e1::AST,op::Str,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isIntType(t1) and isIntType(t2)
     then BoolType(l);
     else throw[Type] TypeError(l,op + ' expects boolean arguments: ' + ppType(t1) + ' ' + ppType(t2));

orExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(t1) and isBoolType(t2)
     then t1;
     else throw[Type] TypeError(l,'or expects boolean arguments: ' + ppType(t1) + ' ' + ppType(t2));

eqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'= expects types to agree: ' + ppType(t1) + ' <> ' + ppType(t2));

neqlExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in if typeEqual(t1,t2)
     then BoolType(l);
     else throw[Type] TypeError(l,'<> expects types to agree: ' + ppType(t1) + ' <> ' + ppType(t2));

consExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t2,t1 {
    ListType(l::Loc,elementType::Type),headType::Type ->
      if typeEqual(headType,elementType)
      then t2;
      else throw[Type] TypeError(l,': expects head type ' + ppType(headType) + ' and element type ' + ppType(elementType) + ' to agree');
  }

divExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for /: ' + ppType(t1) + ' and ' + ppType(t2));
  }

mulExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for *: ' + ppType(t1) + ' and ' + ppType(t2));
  }

subExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for -: ' + ppType(t1) + ' and ' + ppType(t2));
  }

plusExpType(l::Loc,e1::AST,e2::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = 
  let t1::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
      t2::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t1,t2 {
    StrType(l::Loc),t2::Type -> t1;
    t1,StrType(l::Loc) -> t2;
    IntType(l1::Loc),IntType(l2::Loc) -> t1;
    FloatType(l1::Loc),FloatType(l2::Loc) -> t1;
    ListType(l1::Loc,t1::Type),ListType(l2::Loc,t2::Type) when typeEqual(t1,t2) -> ListType(l1,t1);
    t1::Type,t2::Type -> throw[Type] TypeError(l,'incomptible types for +: ' + ppType(t1) + ' and ' + ppType(t2));
  }

applyTypeExp(l::Loc,e::AST,ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let ts::[Type] = substTypesEnv(typeEnv,ts);
      t::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
  in case t {
       ForallType(l1::Loc,ns::[Str],t::Type) -> 
         if length[Str](ns) = length[Type](ts)
         then  
           let env::TEnv = zipTypeEnv(ns,ts);
           in substTypeEnv(env + valueEnv,t);
         else throw[Type] TypeError(l,'universal type expects ' + length[Str](ns) + ' types, but supplied with ' + length[Type](ts));
       t::Type -> throw[Type] TypeError(l,'expecting a universal type: ' + t);
     } 

expTypes(es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::[Type] =
  map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);

applyType(l::Loc,op::AST,args::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = {
  //print[Str]('apply type ' + op + '  ' + args);
  case expType(op,selfType,valueEnv,cnstrEnv,typeEnv) {
    FunType(l1::Loc,domain::[Type],range::Type) ->
      let supplied::[Type] = expTypes(args,selfType,valueEnv,cnstrEnv,typeEnv);
      in if length[Type](domain) = length[Type](supplied)
         then
           if typesEqual(domain,supplied)
           then range;
           else throw[Type] TypeError(l,'supplied argument types ' + ppTypes(supplied) + ' do not match function domain ' + ppTypes(domain) + ' ' + valueEnv);
         else throw[Type] TypeError(l,'expecting ' + length[Type](domain) + ' args, but supplied with ' + length[Type](supplied));
    t::Type -> throw[Type] TypeError(l, 'unknown type for apply: ' + ppType(t));
  }}

ifType(l::Loc,e1::AST,e2::AST,e3::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let testType::Type = expType(e1,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isBoolType(testType)
     then
       let conseqType::Type = expType(e2,selfType,valueEnv,cnstrEnv,typeEnv);
           altType::Type = expType(e3,selfType,valueEnv,cnstrEnv,typeEnv);
       in if typeEqual(conseqType,altType)
          then conseqType;
          else throw[Type] TypeError(l,'conseq and alt types do not agree: ' + ppType(conseqType) + ' ' + ppType(altType));
     else throw[Type]('if expects a bool ' + ppType(testType));

funType(l::Loc,n::AST,args::[TDec],t::Type,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let nType::Type = expType(n,selfType,valueEnv,cnstrEnv,typeEnv);
  in if isStrType(nType)
     then 
       let declaredType::Type = substTypeEnv(typeEnv,t);
       in decTypes(args,valueEnv,typeEnv,fun(domain::[Type],valueEnv::TEnv)::Type {
        let actualRange::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
        in if typeEqual(declaredType,FunType(l,domain,actualRange))
           then FunType(l,domain,actualRange);
           else throw[Type] TypeError(l,'function declared type ' + ppType(declaredType) + ' but is ' + ppType(FunType(l,domain,actualRange)));
       });
     else throw[Type] TypeError(l,'expecting a string for a function name: ' + n);

decTypes(decs::[TDec],valueEnv::TEnv,typeEnv::TEnv,consumer::([Type],TEnv)->Type)::Type =
  letrec
    processDecs(decs::[TDec],bindings::TEnv)::Type =
      case decs {
        [][TDec] -> consumer(reverse[Type](typeEnvRan(bindings)),bindings + valueEnv);
        Dec(l::Loc,n::Str,t::Type):decs::[TDec] -> processDecs(decs,Map(n,substTypeEnv(typeEnv,t)):bindings);
      }
  in processDecs(decs,[][TMap]);

isStrType(t::Type)::Bool =
  case t {
    StrType(l::Loc) -> true;
    t::Type -> false;
  }

isIntType(t::Type)::Bool =
  case t {
    IntType(l::Loc) -> true;
    t::Type -> false;
  }

isBoolType(t::Type)::Bool =
  case t {
    BoolType(l::Loc) -> true;
    t::Type -> false;
  }

termType(l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type = { 
  let t::Type = unfoldIf(lookupType(n,cnstrEnv));
  in termTypeCheckUnion(t,l,n,ts,es,selfType,valueEnv,cnstrEnv,typeEnv);
}   
  
termTypeCheckUnion(t::Type,l::Loc,n::Str,ts::[Type],es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if t = null[Type]
     then throw[Type] TypeError(l,'cannot find constructor ' + n);
     else
       case t {
        TypeFun(lf::Loc,ns::[Str],body::Type) ->
          if length[Str](ns) = length[Type](ts)
          then 
            let args::[Type] = map[Type,Type](fun(t::Type)::Type substTypeEnv(typeEnv,t),ts); 
            in case substTypeEnv(zipTypeEnv(ns,args),body) {
                 UnionType(l1::Loc,terms::[Type]) ->
                   let ts2::[Type] = findTermArgTypes(n,terms);
                   in if length[AST](es) = length[Type](ts2)
                      then {
                        checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
                        UnionType(l1,terms);
                      }
                      else throw[Type](n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
               }
          else throw[Type] TypeError(l,'generic constructor ' + n + ' expects ' + length[Str](ns) + ' type arguments, but received ' + length[Type](ts));
        UnionType(l1::Loc,terms::[Type]) ->
          let ts2::[Type] = findTermArgTypes(n,terms);
          in if length[Type](ts) <> 0
             then throw[Type] TypeError(l,'generic application of non-generic constructior: ' + n);
             else if length[AST](es) = length[Type](ts2)
             then {
              checkTermArgTypes(l,es,ts2,selfType,valueEnv,cnstrEnv,typeEnv);
              t;
             }
             else throw[Type](n + ' expects ' + length[Type](ts2) + ' args, but you supplied ' + length[AST](es));
        t::Type -> throw[Type] TypeError(l,'expecting a union type for ' + n + ' but got ' + ppType(t));
       }

unfoldIf(t::Type)::Type =
  case t {
    RecType(l::Loc,n::Str,t::Type) -> unfoldIf(unfoldType(l,n,t));
    t::Type -> t;
  }

findTermArgTypes(n::Str,terms::[Type])::[Type] = 
  case terms {
    TermType(l::Loc,nn::Str,ts::[Type]):terms::[Type] when nn=n -> ts;
    [][Type] -> throw[[Type]]('cannot find constructor ' + n);
    t::Type:ts::[Type] -> findTermArgTypes(n,ts);
  }

checkTermArgTypes(l::Loc,es::[AST],ts::[Type],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void =
  case es,ts {
    (e::AST):es::[AST],t::Type:ts::[Type] ->
      let tt::Type = expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
      in {
        if typeEqual(t,tt)
         then checkTermArgTypes(l,es,ts,selfType,valueEnv,cnstrEnv,typeEnv);
         else throw[Void] TypeError(l,'expected constructor arg type ' + ppType(t) + ' but supplied ' + ppType(tt));
      }
     [][AST],[][Type] -> null[Void];
  }
  

notType(l::Loc,e::AST,selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  case expType(e,selfType,valueEnv,cnstrEnv,typeEnv) {
    BoolType(l::Loc) -> BoolType(l);
    t::Type -> throw[Type] TypeError(l,'expecting a boolean: ' + ppType(t));
  }
  
varType(l::Loc,n::Str,valueEnv::TEnv)::Type =
  let t::Type = lookupType(n,valueEnv);
  in if t = null[Type]
     then throw[Type] TypeError(l,'unbound variable ' + n);
     else case t {
       TypeClosure(f::()->Type) -> f();
       t::Type -> t;
     }

blockType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  let t::Type = VoidType(l);
  in {
    for e::AST in es do
      t := expType(e,selfType,valueEnv,cnstrEnv,typeEnv);
    t;
  }     

listType(l::Loc,es::[AST],selfType::Type,valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Type =
  if es = [][AST]
  then ForallType(l,['T'],ListType(l,VarType(l,'T')));
  else
    let ts::[Type] = map[AST,Type](fun(e::AST)::Type expType(e,selfType,valueEnv,cnstrEnv,typeEnv),es);
    in if allEqualTypes(head[Type](ts),tail[Type](ts))
       then ListType(l,head[Type](ts));
       else throw[Type] TypeError(l,'lists should have elements of the same type: ' + es);

allEqualTypes(t1::Type,ts::[Type])::Bool =
  case ts {
    [][Type] -> true;
    t2::Type:ts::[Type] when typeEqual(t1,t2) -> allEqualTypes(t1,ts);
    ts::[Type] -> false;
  }
   

walk(exp::AST)::Void = {// print[AST](exp);
  case exp {
    Module(name::Str,exports::[Str],imports::[Str],x::Void,y::Void,defs::[TBind]) -> {
      // Check the types
      let e::TEnv = typeEnv(defs);
      in {
        print[Str]('Checking types');
        checkFreeTypes(e);
        checkSingletonTypes(e);
        print[Str]('OK free types');
        let typeEnv::TEnv = recTypes(e); in
        let cnstrEnv::TEnv = cnstrEnv(defs,typeEnv);
        in {
          checkSingletonConstructors(cnstrEnv);
          print[Str]('cnstr env: ' + ppTypeEnv(cnstrEnv));
          print[Str]('type env: ' + ppTypeEnv(typeEnv)); 
        }
        for b::TBind in defs do
          walkBind(b);
      }
    }
    FunExp(l::Loc,n::AST,args::[TDec],t::Type,e::AST) -> {
      walk(n);
      for Dec(dl::Loc,dn::Str,dt::Type) in args do {
        walkType(dt);
      }
      walkType(t);
      walk(e);
    }
    StrExp(l::Loc,v::Str) -> {}
    IntExp(l::Loc,v::Int) -> {}
    BoolExp(l::Loc,v::Bool) -> {}
    NullExp(l::Loc) -> {}
    FloatExp(l::Loc,n::Int,m::Int) -> {}
    Term(l::Loc,n::Str,ts::[Type],es::[AST]) -> {
      for e::AST in es do walk(e);
      for t::Type in ts do walkType(t);
    }
    List(l::Loc,es::[AST]) -> {
      for e::AST in es do walk(e);
    }
    Block(l::Loc,es::[AST]) -> {
      for e::AST in es do walk(e);
    }
    Apply(l::Loc,op::AST,args::[AST]) -> {
      walk(op);
      for e::AST in args do walk(e);
    }
    ApplyTypeExp(l::Loc,op::AST,args::[Type]) -> {
      walk(op);
      for t::Type in args do walkType(t);
    }
    Case(l::Loc,ds::[TDec],es::[AST],as::[Arm]) -> {
      for Dec(dl::Loc,n::Str,t::Type) in ds do walkType(t);
      for e::AST in es do walk(e);
      for a::Arm in as do walkArm(a);
    }
    BinExp(l::Loc,e1::AST,op::Str,e2::AST) -> {
      walk(e1);
      walk(e2);
    }
    For(l::Loc,p::Pattern,e1::AST,e2::AST) -> {
      walkPattern(p);
      walk(e1);
      walk(e2);
    }
    Throw(l::Loc,t::Type,e::AST) -> {
      walkType(t);
      walk(e);
    }
    Try(l::Loc,e::AST,as::[Arm]) -> {
      walk(e);
      for a::Arm in as do walkArm(a);
    }
    ActExp(l::Loc,n::AST,args::[TDec],x::[Str],spec::Str,locals::[TBind],init::AST,handlers::[Arm]) -> {
      walk(n);
      for Dec(dl::Loc,dn::Str,dt::Type) in args do walkType(dt);
      for b::TBind in locals do walkBind(b);
      walk(init);
      for a::Arm in handlers do walkArm(a);
    }
    If(l::Loc,e1::AST,e2::AST,e3::AST) -> { 
      walk(e1);
      walk(e2);
      walk(e3);
    }
    Self(l::Loc) -> {}
    Update(l::Loc,n::Str,e::AST) -> walk(e);
    Ref(l::Loc,e::AST,n::Str) -> walk(e);
    Var(l::Loc,n::Str) -> {}
    Send(l::Loc,target::AST,message::AST) -> {
      walk(target);
      walk(message);
    }
    Cmp(l::Loc,e::AST,qs::[Qualifier]) -> {
      walk(e);
      for q::Qualifier in qs do walkQualifier(q);
    }
    New(l::Loc,b::AST,args::[AST]) -> {
      walk(b);
      for a::AST in args do walk(a);
    }
    NewJava(l::Loc,className::Str,t::Type,args::[AST]) -> {
      walkType(t);
      for a::AST in args do walk(a);
    }
    Let(l::Loc,bs::[TBind],e::AST) -> {
      for b::TBind in bs do walkBind(b);
      walk(e);
    }
    Letrec(l::Loc,bs::[TBind],e::AST) -> {
      for b::TBind in bs do walkBind(b);
      walk(e);
    }
    Grab(l::Loc,rs::[DRef],e::AST) -> {
      walk(e);
    }
    Probably(l::Loc,p::AST,t::Type,e1::AST,e2::AST) -> {
      walk(p);
      walkType(t);
      walk(e1);
      walk(e2);
    }
    Not(l::Loc,e::AST) -> walk(e);
    Fold(l::Loc,t::Type,e::AST) -> {
      walkType(t);
      walk(e);
    }
    Unfold(l::Loc,t::Type,e::AST) -> {
      walkType(t);
      walk(e);
    }
    Now(l::Loc) -> {}
    Become(l::Loc,e::AST) -> walk(e);
    x::AST -> throw [Void]Walk(x);
  }
}
      
walkQualifier(q::Qualifier)::Void = 
  case q {
    BQual(l::Loc,p::Pattern,e::AST) -> {
      walkPattern(p);
      walk(e);
    }
    PQual(l::Loc,p::AST) -> walk(p);
  }
      
walkArm(a::Arm)::Void = 
  case a {
    BArm(l::Loc,ps::[Pattern],guard::AST,e::AST) -> {
      for p::Pattern in ps do walkPattern(p);
      walk(guard);
      walk(e);
    }
  }
      
    
walkBind(b::TBind)::Void = 
  case b {
    Binding(l::Loc,name::Str,t::Type,value::AST) -> {
      walkType(t);
      walk(value);
    }
    TypeBind(l::Loc,name::Str,t::Type,ignore::AST) -> {
      walkType(t);
    }
    DataBind(l::Loc,name::Str,t::Type,ignore::AST) -> {
      walkType(t);
    }
    FunBind(l::Loc,n::Str,args::[Pattern],t::Type,body::AST,guard::AST) -> {
      for p::Pattern in args do
        walkPattern(p);
      walkType(t);
      walk(body);
      walk(guard);
    }
    CnstrBind(l::Loc,name::Str,t::Type,ignore::AST) -> {
      walkType(t);
    }
    x::TBind -> throw[Void](WalkBind(x));
  }
      
walkPattern(p::Pattern)::Void = { //print[Pattern](p);
  case p {
    PVar(l::Loc,n::Str,t::Type) -> {
      walkType(t);
    }
    PTerm(l::Loc,n::Str,ts::[Type],ps::[Pattern]) -> {
      for t::Type in ts do walkType(t);
      for p::Pattern in ps do walkPattern(p);
    }
    PApplyType(l::Loc,p::Pattern,ts::[Type]) -> {
      walkPattern(p);
      for t::Type in ts do walkType(t);
    }
    PNil(l::Loc) -> {}
    PInt(l::Loc,i::Int) -> {}
    PStr(l::Loc,s::Str) -> {}
    PBool(l::Loc,b::Bool) -> {}
    PCons(l::Loc,h::Pattern,t::Pattern) -> {
      walkPattern(h);
      walkPattern(t);
    }
    x::Pattern -> throw[Void] WalkPattern(x);
  }
}
    
walkType(t::Type)::Void =
  case t {
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> { 
    }
    BoolType(l::Loc) -> {}
    FloatType(l::Loc) -> {}
    ForallType(l::Loc,ns::[Str],t::Type) -> walkType(t);
    FunType(l::Loc,d::[Type],r::Type) -> {
      for t::Type in d do walkType(t);
      walkType(r);
    }  
    IntType(l::Loc) -> {}
    ListType(l::Loc,t::Type) -> {
      walkType(t);
    } 
    NullType(l::Loc) -> {}
    RecType(l::Loc,n::Str,t::Type) -> {
      walkType(t);
    }
    StrType(l::Loc) -> {}
    TermType(l::Loc,n::Str,ts::[Type]) -> {
      for t::Type in ts do walkType(t);
    }  
    UnfoldType(l::Loc,t::Type) -> {
      walkType(t);
    }    
    UnionType(l::Loc,ts::[Type]) -> {
      for t::Type in ts do walkType(t);
    }
    VarType(l::Loc,n::Str) -> {}
    VoidType(l::Loc) ->{}
    UnionRef(l::Loc,t::Type,n::Str) -> {
      walkType(t);
    }
    x::Type -> throw[Void](WalkType(x));
  }
    
substDec(newType::Type,n::Str,d::TDec)::TDec =
  case d {
    Dec(l::Loc,name::Str,t::Type) -> Dec(l,name,substType(newType,n,t));
  }
  
substDecEnv(env::TEnv,d::TDec)::TDec =
  case d {
    Dec(l::Loc,name::Str,t::Type) -> Dec(l,name,substTypeEnv(env,t));
  }
    
substMType(newType::Type,n::Str,m::MType)::MType = 
  case m {
    MessageType(l::Loc,ts::[Type]) -> MessageType(l,[ substType(newType,n,t) | t::Type <- ts]);
  }
    
substMTypeEnv(env::TEnv,m::MType)::MType = 
  case m {
    MessageType(l::Loc,ts::[Type]) -> MessageType(l,[ substTypeEnv(env,t) | t::Type <- ts]);
  }
  
substTypes(newType::Type,n::Str,oldTypes::[Type])::[Type] = {
  //print[Str]('substTypes ' + ppType(newType) + ' ' + n + ' ' + ppTypes(oldTypes));
  case oldTypes {
    [][Type] -> [][Type];
    t::Type:ts::[Type] -> substType(newType,n,t):substTypes(newType,n,ts);
  }}
    
substType(newType::Type,n::Str,oldType::Type)::Type = { 
  //print[Str]('subst type: ' + ppType(newType) + ' ' + n + ' ' + ppType(oldType));
  case oldType {
    ApplyType(l::Loc,m::Str,types::[Type]) -> 
      if m = n
      then ApplyTypeFun(l,newType,substTypes(newType,n,types));
      else ApplyType(l,m,substTypes(newType,n,types));
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ApplyTypeFun(l,substType(newType,n,op),substTypes(newType,n,args));
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 
      ActType(l,[substDec(newType,n,d) | d::TDec <- decs],[ substMType(newType,n,m) | m::MType <- handlers]);
    BoolType(l::Loc) -> oldType;
    FloatType(l::Loc) -> oldType;
    ForallType(l::Loc,ns::[Str],t::Type) ->  if member[Str](n,ns) then oldType; else ForallType(l,ns,substType(newType,n,t));
    FunType(l::Loc,d::[Type],r::Type) -> FunType(l,substTypes(newType,n,d),substType(newType,n,r));
    IntType(l::Loc) -> oldType;
    ListType(l::Loc,t::Type) -> ListType(l,substType(newType,n,t));
    NullType(l::Loc) -> oldType;
    RecordType(l::Loc,fs::[Type]) -> RecordType(l,substTypes(newType,n,fs));
    RecType(l::Loc,a::Str,t::Type) ->  if n = a then oldType; else RecType(l,a,substType(newType,n,t));
    StrType(l::Loc) -> oldType;
    TermType(l::Loc,f::Str,ts::[Type]) -> TermType(l,f,substTypes(newType,n,ts));
    TypeClosure(f::()->Type) -> oldType; // Type closures should not have free variables.
    TypeFun(l::Loc,ns::[Str],t::Type) -> if member[Str](n,ns) then oldType; else TypeFun(l,ns,substType(newType,n,t));
    UnfoldType(l::Loc,t::Type) -> UnfoldType(l,substType(newType,n,t));
    UnionType(l::Loc,ts::[Type]) -> UnionType(l,substTypes(newType,n,ts));
    VarType(l::Loc,name::Str) -> if name = n then newType; else oldType;
    VoidType(l::Loc) -> oldType;
    UnionRef(l::Loc,t::Type,name::Str) -> UnionRef(l,substType(newType,n,t),name); 
    x::Type -> throw[Type](SubstType(x));
  }
}

substTypesEnv(env::TEnv,types::[Type])::[Type] =
  case types {
    [][Type] -> [][Type];
    t::Type:ts::[Type] -> substTypeEnv(env,t):substTypesEnv(env,ts);
  }
    
substTypeEnv(env::TEnv,oldType::Type)::Type = { //print[Str]('subst type env: ' + oldType);
  case oldType {
    ApplyType(l::Loc,n::Str,types::[Type]) -> 
      let op::Type = lookupType(n,env);
      in if op = null[Type]
         then ApplyType(l,n,substTypesEnv(env,types));
         else ApplyTypeFun(l,op,substTypesEnv(env,types));
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> ApplyTypeFun(l,substTypeEnv(env,op),substTypesEnv(env,args));
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> 
      ActType(l,[substDecEnv(env,d) | d::TDec <- decs],[ substMTypeEnv(env,m) | m::MType <- handlers]);
    BoolType(l::Loc) -> oldType;
    FloatType(l::Loc) -> oldType;
    ForallType(l::Loc,ns::[Str],t::Type) -> ForallType(l,ns,substTypeEnv(removeFromDom(env,ns),t));
    FieldType(l::Loc,n::Str,t::Type) -> FieldType(l,n,substTypeEnv(env,t));
    FunType(l::Loc,d::[Type],r::Type) -> FunType(l,[substTypeEnv(env,t) | t::Type <- d],substTypeEnv(env,r));
    IntType(l::Loc) -> oldType;
    ListType(l::Loc,t::Type) -> ListType(l,substTypeEnv(env,t));
    NullType(l::Loc) -> oldType;
    RecType(l::Loc,a::Str,t::Type) ->  RecType(l,a,substTypeEnv(removeFromDom(env,[a]),t));
    RecordType(l::Loc,fs::[Type]) -> RecordType(l,substTypesEnv(env,fs));
    StrType(l::Loc) -> oldType;
    TermType(l::Loc,f::Str,ts::[Type]) -> TermType(l,f,[substTypeEnv(env,t) | t::Type <- ts]);
    TypeClosure(f::()->Type) -> oldType; //TypeClosure(fun['substTypeEnv_closure']()::Type substTypeEnv(env,f()));
    TypeFun(l::Loc,ns::[Str],t::Type) -> TypeFun(l,ns,substTypeEnv(removeFromDom(env,ns),t));
    UnfoldType(l::Loc,t::Type) -> UnfoldType(l,substTypeEnv(env,t));
    UnionType(l::Loc,ts::[Type]) -> UnionType(l,[substTypeEnv(env,t) | t::Type <- ts]);
    VarType(l::Loc,name::Str) -> if member[Str](name,typeEnvDom(env)) then lookupType(name,env); else oldType;
    VoidType(l::Loc) -> oldType;
    UnionRef(l::Loc,t::Type,name::Str) -> UnionRef(l,substTypeEnv(env,t),name); 
    x::Type -> throw[Type](SubstTypeEnv(x));
  }
}
    
recTypes(env::TEnv)::TEnv =
  letrec
    fixEnv(env::TEnv)::TEnv = { //print[Str]('fix env ' + env);
    
      // Take the fixed point by substituting all the types for themselves...
      
      let e::TEnv = null[TEnv];
      in let getType(n::Str)::Type = TypeClosure(fun['lookup: ' + n]()::Type lookupType(n,e));
         in let env1::TEnv = substOnce(env,getType);
            in { e := env1; env1; }}
   
    introduceRecTypes(env::TEnv)::TEnv = {
      case env {
        [][TMap] -> env;
        Map(n::Str,t::Type):e::TEnv ->
          if member[Str](n,typeFV(t))
          then Map(n,RecType(Pos(0,0),n,t)):introduceRecTypes(e);
          else Map(n,t):introduceRecTypes(e);
      }
    }
    substOnce(env::TEnv,getType::(Str)->Type)::TEnv = 
      let
        map1(m::TMap)::TMap =
          case m {
            Map(n::Str,t::Type) -> Map(n,substTypeEnv([ Map(n,getType(n)) | n::Str <- typeFV(t) ],t));
          }
      in map[TMap,TMap](map1,env);
  in fixEnv(introduceRecTypes(env));
         
    
typeFV(t::Type)::[Str] = (removeDups[Str](varTypeNames(typeFV1(t,[][Type])))); 

varTypeNames(vs::[Type])::[Str] = map[Type,Str](varTypeName,vs);
  
varTypeName(t::Type)::Str =
  case t {
    VarType(l::Loc,n::Str) -> n;
    x::Type -> '<var>';
  }
  
tdecsFV1(decs::[TDec],fv::[Type])::[Type] =
  case decs {
    [][TDec] -> fv;
    d::TDec:ds::[TDec] -> tdecFV1(d,tdecsFV1(ds,fv));
  }
  
tdecFV1(d::TDec,fv::[Type])::[Type] =
  case d { 
    Dec(l::Loc,n::Str,t::Type) -> 
      typeFV1(t,fv); 
  }
  
handlersFV1(handlers::[MType],fv::[Type])::[Type] =
  case handlers {
    [][MType] -> fv;
    m::MType:hs::[MType] -> handlerFV1(m,handlersFV1(hs,fv));
  }
  
handlerFV1(m::MType,fv::[Type])::[Type] =
  case m { 
    MessageType(l::Loc,ts::[Type]) -> 
      typesFV1(ts,fv); 
  }
  
typesFV1(ts::[Type],fv::[Type])::[Type] =
  case ts {
    [][Type] -> fv;
    t::Type:ts::[Type] -> typeFV1(t,typesFV1(ts,fv));
  }
    
typeFV1(t::Type,fv::[Type])::[Type] = { //print[Str]('FV ' + t);

  // Return a list of VarTypes that are not bound. The VarType contains the 
  // position if we need to raise a positional error...
  
  case t {
    ActType(l::Loc,decs::[TDec],handlers::[MType]) -> tdecsFV1(decs,handlersFV1(handlers,fv));
    ApplyType(l::Loc,n::Str,types::[Type]) -> typesFV1(types,VarType(l,n):fv);
    ApplyTypeFun(l::Loc,op::Type,args::[Type]) -> typesFV1(args,typeFV1(op,fv));
    BoolType(l::Loc) -> fv;
    FieldType(l::Loc,n::Str,t::Type) -> typeFV1(t,fv);
    FloatType(l::Loc) -> fv;
    ForallType(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    FunType(l::Loc,d::[Type],r::Type) -> typesFV1(d,typeFV1(r,fv));
    IntType(l::Loc) -> fv;
    ListType(l::Loc,t::Type) -> typeFV1(t,fv);
    NullType(l::Loc) -> fv;
    RecordType(l::Loc,fs::[Type]) -> typesFV1(fs,fv);
    RecType(l::Loc,a::Str,t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(n = a); },typeFV1(t,[][Type])) + fv;
    StrType(l::Loc) -> fv;
    TypeClosure(f::()->Type) -> [][Type];
    TermType(l::Loc,n::Str,ts::[Type]) -> typesFV1(ts,fv);
    TypeFun(l::Loc,ns::[Str],t::Type) -> filter[Type](fun(t::Type)::Bool case t { VarType(l::Loc,n::Str) -> not(member[Str](n,ns)); },typeFV1(t,[][Type])) + fv;
    UnfoldType(l::Loc,t::Type) -> typeFV1(t,fv);
    UnionType(l::Loc,ts::[Type]) -> typesFV1(ts,fv);
    VarType(l::Loc,n::Str) -> t:fv;
    VoidType(l::Loc) -> fv;
    UnionRef(l::Loc,t::Type,n::Str) ->typeFV1(t,fv);
    x::Type -> throw[[Type]](TypeFV1(x));
  }
}
  
act main::Main { 
  Time(t::Int) -> {
    print[Str]('Start of system');
    print[[Str]](typeFV(ForallType(Pos(0,0),['X'],FunType(Pos(0,0),[VarType(Pos(0,0),'Y'),VarType(Pos(0,0),'Y')],VarType(Pos(0,0),'X')))));
    print[TEnv](recTypes([
      Map('X',VarType(Pos(0,0),'X')),
      Map('Y',TermType(Pos(0,0),'T',[VarType(Pos(0,0),'X')])),
      Map('F',FunType(Pos(0,0),[VarType(Pos(0,0),'X'),VarType(Pos(0,0),'Y')],VarType(Pos(0,0),'X'))) 
    ]));
   try {
    typeCheckModule(parse[AST]('new_esl/tmp/test4.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]); 
    typeCheckModule(parse[AST]('new_esl/tmp/lists.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    typeCheckModule(parse[AST]('new_esl/tmp/test5.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    typeCheckModule(parse[AST]('new_esl/tmp/collisions.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
    typeCheckModule(parse[AST]('new_esl/tmp/test6.esl'),fun(valueEnv::TEnv,cnstrEnv::TEnv,typeEnv::TEnv)::Void null[Void]);
   }
   catch {
      message::Str ->  print[Str]('Type Error: ' + message); 
    }
    print[Str]('DONE');
    stopAll();
  }
}